# List of Practice Problems #1

- [ ] Type coercions
	- [x] 1: Which variable is coerced? Is it implicit or explicit coercion?
	- [ ] 2: What coercion is happening here? Is it implicit or explicit?
	- [ ] 3: What coercion is happening here? Is it implicit or explicit?
- [ ] Numbers, including handling exceptions (ValueError, ZeroDivisionError)
	- [x] 1: What does this return and why? What concept does this cover?
	- [ ] 2: What does this return and why? What concept does this cover?
	- [ ] 3: What does this print and why, what concept does this demonstrate?
	- [ ] 4. What does this print and why? What concept does this cover? How would you refactor this to remove the space?
	- [ ] 5. What can be used in place of commas to make this more readable?
- [ ] Strings
	- [x] 1. What is the output of this code, and why? What is the concept covered here?
	- [ ] 2. What does this print and why? What concept is this?
	- [ ] 3. What does this print and why? What concept is this?
- [ ] f-strings
	- [x] 1. What does this print and why, what is the concept?
- [ ] String Methods
	- [x] 1. What does this print and why?
	- [x] 2. What does this print and why?
	- [ ] 3. What does this print and why?
	- [ ] 4. What does this print and why?
	- [ ] 5. What does this print and why?
	- [ ] 6. What does this print and why?
	- [ ] 7. What does this print and why?
	- [ ] 8. What does this print and why?
	- [ ] 9. What does this print and why?
	- [ ] 10. What does this print and why?
	- [ ] 11. What does this print and why?
	- [ ] 12. What does this print and why?
	- [ ] 13. What does this print and why?
	- [ ] 14. What does this print and why?
	- [ ] 15. What does this print and why?
- [ ] boolean vs. truthiness
	- [ ] 1. What does this print and why?
	- [ ] 2. What does this print and why?
	- [x] 3. What does this print and why?
	- [ ] 4. What does this print and why?
	- [ ] 5. What does this print and why?
	- [ ] 6. What does this print and why?
- [ ] ranges
	- [ ] 1. What do these print and why? What concept does this demonstrate?
	- [ ] 2. What do these print and why? What concept does this demonstrate?
	- [ ] 3. What do these print and why? What concept does this demonstrate?
- [ ] list methods
	- [ ] 1. What does this print and why?
	- [ ] 2. What does this print and why?
	- [ ] 3. What does this print and why?
	- [ ] 4. What does this print and why?
	- [ ] 5. What does this print and why?
	- [ ] 6. What does this print and why?
	- [ ] 7. What does this print and why?
	- [ ] 8. What does this print and why?
- [ ] variable scope, global keyword, variables as pointers, variable shadowing
	- [x] 1. What does this print and why?
	- [x] 2. What does this print and why?
	- [x] 3. What does this print and why?
	- [ ] 4. What does this print and why?
	- [ ] 5. What does this print and why?
	- [ ] 6. What does this print and why?
	- [ ] 7. What does this print and why?


## Type coercions: explicit (e.g., using int(), str()) and implicit)

### 1: Which variable is coerced? Is it implicit or explicit coercion?

```python
x = 3.5
y = 5
z = x + y
```

**Answer:**
Variable `y` is implicitly coerced into a `float`, so the return value of adding `x + y` is `8.5`. The Python interpreter does an implicit coercion as we haven't intentionally changed any data type by using any built-in Python function, like `float()`.

> [!NOTE]
> @LSBot feedback:
> 
> **Accuracy: 100/100**
> Your answer correctly identifies that variable `y` (the integer) is the one being implicitly coerced to a float in the expression `x + y`. This is exactly what happens when Python performs arithmetic operations between integers and floats.
> 
> **Completeness: 100/100**  
> Your answer covers all key aspects:•   You identified which variable is coerced (y)  
> •   You specified that it's implicit coercion  
> •   You provided the correct result (8.5)  
> •   You explained why it's implicit (no explicit type conversion function was used)
> 
> **Precision: 100/100**  
> Your explanation is precise and uses the correct terminology. You've accurately described how Python handles mixed-type arithmetic operations.


### 2: What coercion is happening here? Is it implicit or explicit?

```python
a = 1
b = 2
print(a + b)
```

**Answer:**

There is no coercion happening here, as both variables `a` and `b` are of type `int`. The resulting value of the addition is `3`, which is also of type `int`. The `print()` function converts the value into a `string` by invoking behind the scenes the `str()` function, reason why this is not considered coercion.

@LSBot Feedback:

> [!NOTE]
> **Accuracy: 100/100**  
> Your answer correctly identifies that no coercion happens in the addition operation itself. Both `a` and `b` are integers, so the addition produces an integer result without any type conversion.
> 
> **Completeness: 100/100**  
> Your answer covers all the important points:
> •   You correctly stated there's no coercion in the actual operation  
> •   You identified that `a` and `b` are both integers  
> •   You specified the correct result of the addition (3)  
> •   You explained the behavior of the `print()` function accurately
> 
> **Precision: 100/100**  
> Your explanation is precise and uses the correct terminology. You've accurately described why the `print()` function's behavior isn't considered coercion, even though it does convert values to strings behind the scenes.

### 3: What coercion is happening here? Is it implicit or explicit?

```python
month = "December"
day = int(input("What day is it? "))
print(f"Today is the {day} of {month}")
```

**Answer:**

Both explicit and implicit coercions are happening here.

On line 2, we initialize a global variable `day` to the return value of invoking the `input` function with a string object with value `What day is it?` as an argument, which is then explicitly coerced into an integer value by invoking the `int()` constructor.

On line 3, the value referenced by variables `day` and `month` are interpolated into a string, as an f-string is involved, which are implicitly coerced into `str` and then output by the `print()` function, printing the string `Today is the {day} of {month}`.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 90/100** 
> You correctly identified that both explicit and implicit coercions are happening. The explicit coercion using `int()` is accurately described. The implicit coercion in the f-string is correct, but there's a slight misstatement about what gets printed.
> 
> **Completeness: 95/100**  
> Your answer covers the key points about both types of coercion that occur. You've explained the explicit coercion with `int()` and the implicit coercion in the f-string.
> 
> **Precision: 85/100**  
> There's a minor issue with the precision of your last statement. 
> The f-string doesn't output "Today is the {day} of {month}" literally - it outputs the string with the values substituted._
> 
> **Corrected answer:**
> Both explicit and implicit coercions are happening here.
> On line 2, we initialize a variable `day` to the return value of invoking the `input` function with a string argument "What day is it?". Since `input()` always returns a string, we then explicitly coerce this string value into an integer by using the `int()` constructor.
> On line 3, when using an f-string, Python automatically performs implicit string coercion on the values inside the curly braces. The integer value of `day` is implicitly coerced to a string when interpolated in the f-string. The variable `month` is already a string, so no coercion is needed for it. The f-string produces a string with the interpolated values, which is then passed to the `print()` function.

## Numbers, including handling exceptions (ValueError, ZeroDivisionError)

### Basic questions:

- Are integers and floats mutable or immutable?
A: They are immutable
- Are integers and floats primitive or non-primitive? 
A: They are primitive
- Are integers and floats literals?
A: Yes
- What is a literal?
A: It's any syntactic notation that lets you represent an object in source code

### 1: What does this return and why? What concept does this cover?

```python
def convert_to_int(string):
    try:
        converted_integer = int(string)
        return converted_integer
    except ValueError:
        return "That string cannot be converted to an integer"

print(convert_to_int("hello"))

print(convert_to_int("5"))
```

**Answer**:

On line 8, the string object with value `That string cannot be converted to an integer` is output. 

On line 8, we invoke the function `convert_to_int` with the string value `hello` as an argument. Within the function, we have a `try` `except` construction that tries to coerce the value `hello` to a integer by invoking the `int()` constructor and passing the string value as an argument. This explicit coercion raises a `ValueError` exception that is caught and returns the value `That string cannot be converted to an integer`, as attempting to convert a non-numeric string to an integer using `int()` will raise a `ValueError`.

On line 10, the value `5` is output.

On line 10, we invoke the function `convert_to_int` with the string value `5` as an argument. On line 3, within the function, we explicitly coerce the string object with value `3` to an integer by using the `int()` constructor. This coercion is successful and the return value of the function is the integer `5`, which is then passed in as an argument to the `print()` function, outputting it to the console.

The concepts covered here are Type Coercion and Exception Handling.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**  
> Your explanation of the function's behavior is almost entirely correct. The only error is on line 10's explanation, where you wrote "we explicitly coerce the string object with value `3` to an integer" but the string value is actually `5`, not `3`.
> 
> **Completeness: 100/100**  
> Your answer covers all important aspects:
> •   You correctly explained both function calls and their respective outputs  
> •   You identified that the first call results in an exception that's caught  
> •   You properly explained how the try/except block works  
> •   You correctly identified both key concepts being demonstrated
> 
> **Precision: 95/100**  
> Your language is precise and technically correct, with the one small error noted above about the string value.
> 
> **Corrected explanation for line 10**  
> On line 10, we invoke the function `convert_to_int` with the string value `5` as an argument. On line 3, within the function, we explicitly coerce the string object with value `5` to an integer by using the `int()` constructor. This coercion is successful, and the return value of the function is the integer `5`, which is then passed in as an argument to the `print()` function, outputting it to the console.

### 2: What does this return and why? What concept does this cover?

```python
def division(number1, number2):
    numerator = number1
    denominator = number2

    try:
        result = numerator / denominator
        return result
    except ZeroDivisionError:
        return "The denominator cannot be zero"

print(division(5, 0))
```

**Answer**:

This code returns the string `The denominator cannot be zero`.

The reason is that we are passing the integer values `5` and `0` as arguments to the `division` function invocation. Within the function, the value `5` is assigned to the `numerator` variable and the value `0` is assigned to the  `denominator` variable. On line 6, when trying to divide `5` and `0` a `ZeroDivisionError` exception is raised and caught by `try/except` construction, returning the string object with value `The denominator cannot be zero`.

This string object is then passed in as an argument to the `print()` function, outputting it to the console.

The concept covered here in Exception Handling

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation accurately describes what happens in the code. You correctly identified that a `ZeroDivisionError` is raised when trying to divide by zero, and that this exception is caught by the except block.
> 
> **Completeness: 100/100**  
> 
> Your answer covers all the key points:
> •   You identified the correct return value  
> •   You explained the function parameter assignment correctly  
> •   You described the exception that occurs and how it's handled  
> •   You explained the final output process
> 
> **Precision: 100/100**
> 
> Your explanation is precise and uses the correct terminology. You've accurately described the exception handling process and the function's behavior.
> 
> The concept this code covers is ​**Exception Handling**​, specifically handling the `ZeroDivisionError` exception. This is a fundamental concept in Python that allows programs to gracefully manage errors that might occur during execution instead of crashing. As explained in the [PY101 - Errors](https://launchschool.com/lessons/a29e9831/assignments/378f8121) assignment, a `ZeroDivisionError` occurs when attempting to divide by zero, and Python provides a structured way to handle such exceptions using the `try`, `except`, `else`, and `finally` statements.
> 
> Your answer demonstrates a clear understanding of how exception handling works in Python - the program attempts an operation that might fail (division), and if it does fail in the expected way (division by zero), it provides an alternative response rather than crashing.

### 3: What does this print and why, what concept does this demonstrate?

```python
def addition(number1, number2):
    number1 += number2

x = 1
y = 2

addition(x, y)
print(f"x is {x}, y is {y}")
```

**Answer**:

This code prints `x is 1, y is 2`.

The reason is that on line 8, we invoke the `print()` function with a f-string as an argument and the values interpolated into the string, are those referred by the global variable `x`, which is the integer `1` and the global variable `y`, which is the integer `2`.

As there is no explicit return statement in the function `addition`, `None` is implicitly returned and it has no effect on the global variables `x` or `y`.

The concept demonstrated is **String Interpolation** and **Variable Scope** 

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 90/100**
> 
> Your final answer is correct - the code prints `x is 1, y is 2`. However, your explanation doesn't fully address why the values of `x` and `y` remain unchanged despite the function attempting to modify `number1`.
> 
> **Completeness: 85/100**
> 
> Your answer covers string interpolation and variable scope, which are relevant, but the primary concept being demonstrated is Python's handling of immutable objects, which you haven't mentioned.
> 
> **Precision: 80/100**
> 
> While technically correct about what happens, the explanation doesn't precisely describe why the function doesn't modify the value of `x`.
> 
> Improved explanation:
> 
> This code prints `x is 1, y is 2`.
> 
> The key concept being demonstrated is ​**immutability of integers**​ in Python. When `addition(x, y)` is called, the values of `x` and `y` (which are 1 and 2) are passed to the function's parameters `number1` and `number2`. Inside the function, `number1 += number2` attempts to modify `number1`. However, integers in Python are immutable, which means their values cannot be changed.
> 
> What actually happens is that `number1 += number2` creates a new integer object (with value 3) and assigns it to the local variable `number1`. This operation has no effect on the original variable `x` in the global scope.
> 
> When the function ends, there's indeed no explicit return value, so `None` is implicitly returned. The global variables `x` and `y` retain their original values of 1 and 2, which are then displayed in the f-string.
> 
> This example demonstrates the concepts of ​**variable scope**​ and ​**object immutability**​ in Python.

### 4. What does this print and why? What concept does this cover? How would you refactor this to remove the space?

```python
print(2 + 3 * 4, 4 * (3 + 2))
```

**Answer**:

This code prints `14 20`. 

The `print()` function takes two arguments. The first one is the expression `2 + 3 * 4`, which evaluates to `14`, as the multiplication operator has precedence over addition. The second one is the expression `4 * (3 + 2)`, in which the addition operation inside the parenthesis has precedence over the multiplication operation. 

The concept demonstrated here is operator precedence.

**Code Refactor**

```python
print(2 + 3 * 4)
print(4 * (3 + 2))
```

> [!NOTE]
> @LSBot feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation of what the code prints and why is completely accurate. You correctly identified that the code prints `14 20` and explained the operator precedence rules that lead to these values.
> 
> **Completeness: 100/100**
> 
> Your answer covers all important aspects:
> •   You identified the correct output  
> •   You explained how operator precedence affects each expression  
> •   You recognized that the `print()` function is taking two arguments  
> •   You correctly identified operator precedence as the key concept
> 
> **Precision: 90/100**
> 
> Your explanation is precise, but your refactoring suggestion doesn't address the question about removing the space between the values.
> 
> **Improved refactoring suggestion:**
> 
> To remove the space that appears between the two values in the output, you can use the `sep` parameter of the `print()` function:
> 
> ```python
> print(2 + 3 * 4, 4 * (3 + 2), sep='')  
> ``` 
> 
> 
> This would print `1420` without the space between the values. The `sep` parameter specifies what character to use between multiple arguments (the default is a space).
> 
> Alternatively, you could concatenate the values as strings:
> 
> ```python
> print(str(2 + 3 * 4) + str(4 * (3 + 2)))  
> ```  
> 
> The concept of operator precedence is fundamental in Python and programming in general. As explained in the [Precedence assignment](https://launchschool.com/lessons/a29e9831/assignments/aa637b5b), "In an expression, operators with higher precedence are prioritized over those with lower precedence." This is why `*` is evaluated before `+` in the first expression, and why the parentheses are needed in the second expression to change the order of operations.

### 5. What can be used in place of commas to make this more readable?

```python
print(123112940)
```

**Answer**:

We can use `_` underscores to make it more readable.

```python
print(123_112_940)
```

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> You've correctly identified that underscores can be used to make large integers more readable in Python.
> 
> **Completeness: 100/100**
>   
> Your answer provides both the solution and a correct code example showing how to implement it.
> 
> **Precision: 100/100**
> 
> Your syntax is correct - underscores can be placed between digits to improve readability without changing the value of the number.
> 
> This is indeed the correct approach for making large integers more readable in Python. As shown in the "Large Integers" exercise documentation, "You can write large integers by using underscores to separate groups of digits" [https://launchschool.com/exercises/fe9fa066](https://launchschool.com/exercises/fe9fa066).
> 
> The Python documentation classifies this under "Integer literals" where you can place underscores between digits to improve readability. For example:
> 
> ```python
> # These all represent the same number  
> 123112940  
> 123_112_940  
> 1_2_3_1_1_2_9_4_0  # While valid, this isn't conventional  
> ```  
> 
> The placement of underscores is flexible, though conventionally they're used like commas would be in written numbers (every three digits from the right) or to group digits in a meaningful way (like separating bytes in hexadecimal notation).
> 
> This feature was introduced in Python 3.6 and is particularly useful when working with large numbers in scientific computing, financial applications, or when representing values like phone numbers, social security numbers, etc.

## Strings

### Basic questions:

- Are strings mutable or immutable?
A: Immutable
- Are strings primitive or non-primitive?
A: Primitive
- Are strings literals? 
A: Yes
- What is a text sequence?
A: is a string object that represents an ordered collection of Unicode characters.
- What kind of characters are used in a string?
A: Unicode characters
- Are text sequences the same as ordinary sequences?
A: No. Text sequence contain only string characters. ordinary sequences refer to any other sequence types that store multiple elements (objects) (e.g. lists, tuples, ranges))

### 1. What is the output of this code, and why? What is the concept covered here?

```python
str1 = "Hello, world!"
sub1 = str1[8:12]
print(sub1)
sub2 = str1[::-1]
print(sub2)
sub3 = str1[::2]
print(sub3)
```

**Answer**:

The output of this code is:
`orld`
`!dlrow ,olleH`
`Hlo ol!`

On line 1, we initialize a global variable `str1` and references a string object with value `Hello, world!.

On line 2, a global variable `sub1` is initialized to the return value of slicing the string object referenced by variable `str1` starting from index 8 up to but not including index 12. The returned string is `orld`.

On line 3, the value referenced by variable `sub1` is passed in as an argument to the `print()` function, outputting `orld` to the console.

On line 4, a global variable `sub2` is initialized and references the return value of slicing the string object referenced by variable `str1`, starting from index 0 until end of the string, with a step of `-1`, transversing the string in reverse mode. The returned string is `!dlrow ,olleH`.

On line 5, the value referenced by variable `sub2` is passed in as an argument to the `print()` function, outputting `!dlrow ,olleH` to the console.

On line 6, the global variable `sub3` is initialized and references the return value of slicing the string object referenced by variable `str1`, from index 0 until the end of the string, with a step of `2`, returning the string object with value ``Hlo ol!`.

On line 7, the value referenced by the variable `sub3` is passed in as an argument to the `print()` function, outputting `Hlo ol!` to the console.

The concept demonstrated here is string slicing.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 95/100**
> 
> Your answer is highly accurate. The predicted outputs are correct, and your explanation of each line is technically sound. The only minor improvement I would suggest is clarifying that on line 1, we're creating a string object with the value `"Hello, world!"` (you're missing the closing quote).
> 
> **Completeness: 98/100**
> 
> Your answer is very complete. You've methodically explained each line of code, what it does, and the resulting output. You've correctly identified the concept as string slicing and explained how each slicing operation works.
> 
> **Precision: 97/100**
> 
> Your language is precise and demonstrates a deep understanding of Python's mechanics. You correctly use terms like "references," "return value," "initialize," and "global variable." You also accurately describe the slice notation, including start, end, and step parameters.
> 
> For your PY109 assessment, this level of precision and detailed explanation is exactly what's expected. You've gone beyond simply stating what happens to explaining ​_why_​ it happens, which shows mastery of the concept.To complement your answer, I'll add that string slicing is a powerful feature in Python that allows you to extract substrings using the syntax `string[start:stop:step]`. 
> 
> As demonstrated in your examples:
> •   When `start` is omitted, slicing begins from index 0  
> •   When `stop` is omitted, slicing continues to the end of the string  
> •   When `step` is negative, the string is traversed in reverse order
> 
> The [Reverse exercise](https://launchschool.com/exercises/7947a9ad) in the Python Basics material mentions that while strings don't have a built-in method for reversing (unlike lists), slicing with a negative step parameter (`[::-1]`) is a common and efficient way to reverse a string in Python.Your explanation demonstrates a solid understanding of this concept, which will serve you well in your assessment.

### 2. What does this print and why? What concept is this?

```python
print("Hello\nWorld")
```

**Answer**:

This code prints:
`Hello`
`world`

The reason is that we are including `\n` a return character the prints the two words in separate lines.

The concept demonstrated here is escaping characters.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 90/100**
> 
> Your answer is largely accurate. The output is correct, and you've identified that `\n` creates a line break. However, there's a minor capitalization issue in your output - it should be `World` (with a capital W) to match the code.
> 
> **Completeness: 80/100**
> 
> You've covered the basic concept but could elaborate more on what escape sequences are and why they're needed in Python strings.
> 
> **Precision: 85/100**
> 
> Your terminology is generally correct, though `\n` is specifically a newline character rather than a "return character" (which would be `\r` in escape sequence notation).
> 
> **Improved Answer**
> 
> This code prints:
> 
> ```python
> Hello  
> World
> ```
> 
> The reason is that `\n` is an escape sequence that represents a newline character in Python strings. When the string is processed, the `\n` is not displayed literally but is interpreted as an instruction to start a new line.
> 
> The concept demonstrated here is escape sequences in strings. 
> 
> Escape sequences allow us to include special characters in strings that would otherwise be difficult or impossible to type directly. They start with a backslash (`\`) followed by a character that gives it special meaning. Besides `\n` for newline, other common escape sequences include `\t` for tab, `\\` for backslash, `\'` for single quote, and `\"` for double quote.

### 3. What does this print and why? What concept is this?

```python
name = 'Alexander Graham Bell'
print(name[0])
```

**Answer**:

This code prints the character `A`.

The reason is that on line 2, we are accessing the character at index 0 of the string referenced by global variable `name`, returning a new string object with value `A`, which is then passed in as an argument to the `print()` function.

The concept demonstrated here is strings indexing.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**
> 
> Your answer is highly accurate. You've correctly identified that the code will print `A` and that we're accessing the character at index 0 of the string.
> 
> **Completeness: 90/100**
> 
> Your answer covers the core concept well. You explain that we're accessing a specific character in the string by its index and printing the result.
> 
> **Precision: 95/100**
> 
> Your terminology is precise. You correctly use terms like "index," "string object," and "global variable." You've also accurately described that string indexing returns a new string object rather than modifying the original.Your answer demonstrates a strong understanding of string indexing in Python. 
> 
> **To enhance it slightly:**
> 
> This code prints the character `A`. 
> 
> On line 1, we initialize a global variable `name` that references a string object with the value `'Alexander Graham Bell'`. 
> 
> On line 2, we use string indexing to access the character at position 0 (the first character) of the string referenced by `name`. In Python, indexing is zero-based, meaning the first character is at index 0. The indexing operation returns a new string object containing just the character `A`, which is then passed as an argument to the `print()` function.
> 
> The concept demonstrated here is string indexing, which allows us to access individual characters within a string by their position. This is possible because strings in Python are sequence types, meaning they represent an ordered collection of elements (in this case, characters) that can be accessed by their position.
> 
> Remember that while strings in Python share many characteristics with other sequence types like lists, they are immutable - meaning you can access individual characters but cannot modify them in place.

## f-strings

### Basic Questions:

- What are f-strings?
A: These are formatted-strings, which allows the interpolation of expressions into strings, by surrounding them with curly braces, making them more readable.

> [!NOTE]
> @LSBot Feedback
> 
> F-strings (formatted string literals) are a string formatting mechanism introduced in Python 3.6 that provides a concise and readable way to embed expressions inside string literals. They are created by prefixing a string literal with the letter 'f' or 'F' and placing expressions inside curly braces `{}` within the string. These expressions are evaluated at runtime and their values are converted to strings and inserted into the final string.

### 1. What does this print and why, what is the concept?

```python
name = 'Abraham Lincoln'
print(f"{name} was a President of the US")
```

**Answer**:

This code prints: `Abraham Lincoln was a President of the US`.

On line 1, we initialized a global variable `name` and references a string object with value `Abraham Lincoln`.

On line 2, the string object referenced by `name` is interpolated into the string object and passed in as an argument to the `print()` function, outputting `Abraham Lincoln was a President of the US` to the console.

The concept demonstrated here is string interpolation.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 95/100**
> 
> Your answer is highly accurate. You correctly identify the output and explain that the value of the `name` variable is interpolated into the string.
> 
> **Completeness: 90/100**
> 
> Your answer covers the essential aspects of what's happening in the code. You correctly describe the initialization of the variable and how it's used in the f-string.
> 
> **Precision: 92/100**
> 
> Your terminology is precise. You appropriately use terms like "global variable," "references," "string object," and "interpolated" which demonstrates a solid understanding of the underlying concepts.Your answer demonstrates a strong understanding of string interpolation using f-strings. 
> 
> **To enhance it slightly**:
> 
> This code prints: `Abraham Lincoln was a President of the US`.
> 
> On line 1, we initialize a global variable `name` that references a string object with the value `'Abraham Lincoln'`.
> 
> On line 2, we use an f-string (formatted string literal) which is denoted by the `f` prefix before the string. The expression `{name}` within the curly braces is evaluated at runtime, and the value of the `name` variable (`'Abraham Lincoln'`) is converted to a string and inserted into that position. This complete string is then passed as an argument to the `print()` function, which outputs `Abraham Lincoln was a President of the US` to the console.
> 
> The concept demonstrated here is string interpolation using f-strings, which were introduced in Python 3.6 as a concise and readable way to embed expressions inside string literals. As noted in the [String Formatting exercise](https://launchschool.com/exercises/52c9c771), f-strings "offer a concise way to embed expressions inside string literals" and are often preferred over older methods like `str.format()` because they're more intuitive.

## string methods

### Basic Questions:

- How do you identify a method versus a function?
A: Methods are invoked in an object and identified by the dot notation after the object name, while functions are invoked without reference to an object, by using the parenthesis after the function name and have the possibility to pass in arguments if there are parameters defined in the function definition.

> [!NOTE]
> @LSBot Feedback:
> 
> **Improved Answer:**
> 
> Methods are functions that belong to objects. They're identified by dot notation (`object.method()`) and are called on a specific object. The first parameter of a method is typically `self`, which represents the instance the method is called on. For example, `my_string.upper()` calls the `upper` method on the `my_string` object. 
> 
> Functions exist independently of objects. They're called by using the function name followed by parentheses (`function()`). Functions don't have an implicit first parameter like methods do. For example, `len(my_string)` calls the `len` function with `my_string` as an argument.
> 
> Both methods and functions can accept arguments if they have defined parameters.

### 1. What does this print and why?

```python
mashup = "thIs is How we type careLEssly"
cleaned = mashup.capitalize()
print(cleaned)
```

**Answer:**

This code prints `This is how we type carelessly`.

On line 1 we initialize a global variable `mashup` that references a string object with value `thIs is How we type careLEssly`.

On line 2, we initialize a global variable `cleaned` to the return value of invoking the `capitalize()` method on the value referenced by `mashup`. The `capitalize()` method, returns a new string with its first character capitalized and the rest lowercased.

On line 3, we invoke the `print()` function with the value referenced by `cleaned` as an argument, printing the value `This is how we type carelessly` to the console.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation is completely correct. The code will indeed print "This is how we type carelessly" and your description of how the `capitalize()` method works is accurate.
> 
> **Completeness: 100/100**
> 
> You've covered all the relevant points:
> •   What happens on each line of code  
> •   How the `capitalize()` method specifically works (capitalizes first character, makes the rest lowercase)  
> •   The fact that we're dealing with global variables  
> •   The fact that strings are objects with methods
> 
> **Precision: 100/100**  
> Your language is very precise and demonstrates a solid understanding of:
> 
> •   Variable assignment and references  
> •   Method invocation terminology (using "invoking" correctly)  
> •   Return value concepts  
> •   The specific behavior of the `capitalize()` method
> 
> One additional concept your answer correctly implies (but doesn't need to explicitly state) is that strings are immutable in Python. The `capitalize()` method doesn't modify the original string; it returns a new string with the transformation applied, which we're storing in the `cleaned` variable. This is consistent with the debugging example from PY101 where we saw that string methods like `capitalize()` return new strings rather than modifying the original.
> 
> Great job with this explanation! This level of precision and completeness is exactly what you should aim for in your assessment.

### 2. What do these print and why?

```python
stuff = 'tHIS iS bACKWARDS'
str1 = stuff.swapcase()
str2 = stuff.upper()
str3 = stuff.lower()
print(stuff)
print(str1)
print(str2)
print(str3)
```

**Answer**:

The output of this code is:

`tHIS iS bACKWARDS`
`This Is Backwards`
`THIS IS BACKWARDS`
`this is backwards`

On line 1, we initialize a global variable `stuff` that references a string object with value `tHIS iS bACKWARDS`.

On line 2, we initialize a global variable `str1` to the return value of invoking the `swapcase()` method on the object referenced by `stuff`. The `swapcase()` method returns a new string with the cases changed, if uppercase into lowercase and vice versa, resulting in the value `This Is Backwards`.

On line 3, we initialize a global variable `str2` to the return value of invoking the `upper()` method on the object referenced by `stuff`. The `upper()` method returns a new string with all characters uppercased, resulting in the value `THIS IS BACKWARDS`.

On line 4, we initialize a global variable `str3` to the return value of invoking the `lower()` method on the object referenced by `stuff`. The `lower()` method returns a new string with all characters lowercased, resulting in the value `this is backwards`.

On line 5, the `print()` function is invoked with the object referenced by `stuff` as an argument, outputting `tHIS iS bACKWARDS` into the console.

On line 6, the `print()` function is invoked with the object referenced by `str1` as an argument, outputting `This Is Backwards` into the console.

On line 7, the `print()` function is invoked with the object referenced by `str2` as an argument, outputting `THIS IS BACKWARDS` into the console.

On line 8, the `print()` function is invoked with the object referenced by `str3` as an argument, outputting `this is backwards` into the console.

The concept demonstrated is string immutability and string methods.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation of the output and the string methods' behavior is completely correct. All the string methods you described work exactly as you've explained them.
> 
> **Completeness: 100/100**
> 
> You've covered all the important aspects:
> •   Explained what happens on each line of code  
> •   Accurately described how each string method functions  
> •   Correctly identified the final outputs  
> •   Identified the key concept being demonstrated (string immutability and string methods)
> 
> **Precision: 100/100**
> 
> Your answer uses precise language throughout:
> •   Correctly used terms like "initialize," "global variable," "references," "invoking," and "return value"  
> •   Accurately described the string methods' behavior  
> •   Properly explained the relationship between variables and the objects they reference
> 
> You've also correctly identified the fundamental concept demonstrated: string immutability. This is a crucial concept in Python - string methods never modify the original string but instead return new string objects. This is why `stuff` remains unchanged throughout the program while the other variables hold the transformed strings.For exam preparation, it's worth noting that Launch School places emphasis on this kind of precision in explaining code behavior. 
> 
> According to the PY109 Study Guide, being able to "describe why something happens using precise vocabulary" is critical for success on the assessment. Your answer demonstrates this skill very well.
> 
> The study guide also mentions that "a clearly written paragraph is easier to understand and grade than a laundry list" ([Study Guide for PY109 Exam](https://launchschool.com/lessons/1318de4f/assignments/ff1c7aa8)), and your line-by-line explanation achieves this clarity.
> 
> Great job! This level of detail and precision is exactly what you should aim for in your assessment.

### 3. What do these print and why?

```python
s1 = "Hello"
print(s1.isalpha()) # True
s2 = "Hello World"
print(s2.isalpha()) # False
s3 = "Hello!"
print(s3.isalpha()) # False
s4 = "Hello123"
print(s4.isalpha()) # False
s5 = ""
print(s5.isalpha()) # False
s6 = "こんにちは"
print(s6.isalpha()) # True
s7 = "HelloWorld"
print(s7.isalpha()) # True
words = ["apple", "banana", "cherry"]
print(all(word.isalpha() for word in words)) # True
```

**Answer**:

On line 2, the output is `True`. On line 1, we initialize a global variable `s1` that references a string object with value `Hello`. On line 2, the method `isalpha()` is invoked on the object referenced by `s1`. This method returns `True` if all string characters are alphabetic, which is the case here.

On line 4, the output is `False`. On line 3, we initialize a global variable `s2` that references a string object with value `Hello World`. On line 4, we invoke the method `isalpha()` on `s2`, returning `False` as there is a space character between the string `Hello` and `World`.

On line 6, the output is `False`. On line 5, we initialize a global variable `s3` that references the value `Hello!`. When invoking the `isalpha()` method on the object referenced by `s3`, the return value is `False` because of the character `!`, which is not alphabetic.

On line 8, the output is `False`. On line 7, we initialize a global variable `s4` that references the value `Hello123`. When invoking the `isalpha()` method on the object referenced by `s4`, the return value is `False` because of the characters `123`, which are not alphabetic.

On line 10, the output is `False`. On line 9, we initialize a global variable `s5` to an empty string. When invoking the `isalpha()` method on the object referenced by `s5`, the return value is `False`, as there are no characters in the string.

On line 12, the output is `True`. On line 11, we initialize a global variable `s6` to the string `こんにちは`. As all these characters are alphabetic, the method `isalpha()` returns `True`.

On line 14, the output is `True`. On line 13, we initialize a global variable `s7` to the string `HelloWorld`. As all these characters are alphabetic, the `isalpha()` method returns `True`.

On line 16, the output is `True`. On line 15, we initialize a global variable `s8` to a list object with 3 elements `["apple", "banana", "cherry"]`. On line 16, we have a ternary expression that returns `True` for each element of the list, as all are alphabetic characters. These return values are then passed in as an argument to the `all` function that returns `True`, as all elements of the iterable are `True`.

The concept demonstrated here is string methods and ternary expressions

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 98/100**
> 
> Almost completely accurate with one minor terminology correction: on line 16, you're using a generator expression, not a ternary expression. A ternary expression in Python would be something like `x if condition else y`.
> 
> **Completeness: 100/100**
> 
> Your explanation covers everything about the code:
> •   Correct explanation of each line's output and why  
> •   Clear description of the `isalpha()` method's behavior with different input types  
> •   Proper explanation of the `all()` function's purpose  
> •   Acknowledgment of how `isalpha()` works with non-ASCII characters like Japanese
> 
> **Precision: 95/100**
> 
> Your language is very precise, using correct terminology like "initialize," "reference," "invoke," and explaining the relationship between variables and the objects they reference. The only imprecision was the "ternary expression" point mentioned above.
> 
> **Key Concepts Demonstrated:**
> 
> The code primarily demonstrates:
> 1.  The `isalpha()` string method, which tests whether all characters in a string are alphabetic  
> 2.  The `all()` function which returns True only if all elements in an iterable are truthy  
> 3.  Generator expressions used with functions like `all()`
> 
> Additionally, this example shows Python's Unicode support, as `isalpha()` correctly identifies alphabetic characters from different writing systems.
> 
> For students preparing for assessments, it's important to understand that string methods like `isalpha()` check specific properties of strings without modifying the original string, demonstrating string immutability as seen in the [Is Empty?](https://launchschool.com/exercises/b2e01fe5) and [Is Empty or Blank?](https://launchschool.com/exercises/50933a5a) exercises.
> 
> Excellent work demonstrating your understanding of these concepts!

### 4. What does this print and why?

```python
string1 = "HelloWorld"
string2 = "12345"
string3 = "Hello World"

result1 = string1.isalpha()
result2 = string2.isalpha()
result3 = string3.isalpha()

print("Is '{}' alphabetic?".format(string1), result1)
print("Is '{}' alphabetic?".format(string2), result2)
print("Is '{}' alphabetic?".format(string3), result3)
```

**Answer**:

The output of this code is:

`Is 'HelloWorld' alphabetic? True`
`Is '12345' alphabetic? False`
`Is 'Hello World alphabetic? False`

On line 1, we initialize a global variable `string1` that references a string object with the value `HelloWorld`.

On line 2, we initialize a global variable `string2` that references the string `12345`.

On line 3, we initialize `string3` to the string `Hello World`.

On lines 5 to 7, we invoke the `isalpha()` method on the objects referenced by variables `string1`, `string2` and `string3` and the returned values (`True`, `False`, `False`) are then assigned to the variables `result1`, `result2` and `result3`, respectively. The method `isalpha()` returns `True` if all the characters of the string are alphabetic, `False` otherwise.

On lines 9 to 10, the `print` function is invoked 3 times and gets passed 2 arguments, a string object `Is '{} alphabetic?`, in which the method `format()` is called on and gets passed in the value referenced by variables `string1`, `string2` and `string3`, respectively and the values referenced by variables `result1`, `result2` and `result3`, outputting the values mentioned at the beginning of my answer to the console.

The concept demonstrated is how strings are immutable objects and the use of the `.format` method to output values to the console.

> [!NOTE]
> @LSBot Feedback
> 
> **Overall Assessment:**
> 
> Your explanation is thorough and demonstrates a strong understanding of Python's string methods and formatting. You've correctly analyzed the code line by line and identified how the `isalpha()` method evaluates each string.
> 
> **Strengths:**
> 1.  ​**Line-by-Line Analysis**​: Excellent job walking through each line of code and explaining exactly what happens  
> 2.  ​**Method Behavior**​: Accurate explanation of the `isalpha()` method's behavior and return values  
> 3.  ​**Output Prediction**​: Correctly identified the program's output with proper formatting**Areas for Improvement:**
> 
> **1. String Format Explanation**
> 
> Your explanation of the string formatting could be more precise:
> 
> ```python
> # Instead of:  
> a string object `Is '{} alphabetic?`  
>   
> # More accurately:  
> a formatted string "Is '{}' alphabetic?" where {} is a placeholder  
> ```
> 
> The `format()` method replaces each `{}` placeholder with the corresponding argument. This creates a clearer mental model of what's happening.
> 
> **2. Concepts Demonstrated**
> 
> The primary concept being demonstrated is string methods (specifically `isalpha()`), not string immutability:
> 
> ```python
> # The key concept is how isalpha() evaluates strings:  
> # - Returns True only when ALL characters are alphabetic  
> # - Returns False if ANY character is non-alphabetic (including spaces and numbers)  
> # - An empty string also returns False 
> ```
>  
> 
> String immutability isn't directly demonstrated in this code since none of the methods attempt to modify the original strings.
> 
> **Summary:**
> 
> Your answer is strong and shows excellent understanding of Python's string methods. The `isalpha()` method is important for validation tasks and string processing - knowing exactly when it returns True vs False is crucial for the PY109 assessment. Your line-by-line explanation approach aligns well with Launch School's recommendation to "describe why something happens using precise vocabulary" as mentioned in the Study Guide.
> 

### 5. What do these print and why?

```python
s1 = "123abc"
print(s1.isdigit())
s2 = "123$%^"
print(s2.isdigit())
s3 = ""
print(s3.isdigit())
s4 = "12345"
print(s4.isdigit())
```

**Answer**:

On line 1, we initialize a global variable `s1` that references a string object with value `123abc`.

On line 2, we invoke the `isdigit()` method on the value referenced by `s1`, returning `False`, which is then passed in as an argument to the `print` function, outputting it to the console.

On line 3, we initialize a global variable `s2` that references a string object with value `123$%`.

On line 4, we invoke the `isdigit()` method on the value referenced by `s2`, returning `False`, which is then passed in as an argument to the `print` function, outputting it to the console.

On line 5, we initialize the global variable `s3` to an empty string.

On line 6, we invoke the `isdigit()` method on the value referenced by `s3`, returning `False`, which is then passed in as an argument to the `print` function, outputting it to the console.

On line 7, we initialize a global variable `s4` that references a string object with value `12345`.

On line 8, we invoke the `isdigit()` method on the value referenced by `s4`, returning `True`, which is then passed in as an argument to the `print` function, outputting it to the terminal.

The `isdigit()` method returns `True`, when all characters of the string are digits, `False` otherwise.

> [!NOTE]
> @LSBot Feedback
> 
> Your explanation is excellent! I'd rate it 98/100 for accuracy, completeness, and precision. You've done a thorough job explaining what happens line by line and captured the essential behavior of the `isdigit()` method.

### 6. What do these print and why?

```python
print("Hello World".isalnum())
print("Hello@World".isalnum())
print("".isalnum())
print("Hello123".isalnum())
```

**Answer**:

The string method `isalnum` returns `True` when all string characters are alphanumeric, `False` otherwise.

On line 1, we invoke the `isalnum()` method on the string `Hello World`, returning `False`, which is then passed in as an argument to the `print` function, outputting it to the console.

On line 2, we invoke the `isalnum()` method on the string `Hello@World`, returning `False`, which is then passed in as an argument to the `print` function, outputting it to the console.

On line 3, we invoke the `isalnum()` method on an empty string, returning `False`, which is then passed in as an argument to the `print` function, outputting it to the console.

On line 4, we invoke the `isalnum()` method on the string `Hello123`, returning `True`, which is then passed in as an argument to the `print` function, outputting it to the console.

> [!NOTE]
> @LSBot Feedback
> 
> Your explanation is excellent! I'd rate it 95/100 for accuracy, completeness, and precision.

### 7. What do these print and why?

```python
name = 'HELLO'

if name.isupper():
    print("WORLD")
else:
    print("world")
    ```

**Answer**:

The output of this code is `WORLD`.

On line 1, we initialize a global variable `name` that references a string object with value `HELLO`.

On line 3, we have a conditional statement that checks for truthiness on the return value of invoking the `isupper()` method to the value referenced by `name`. As the return value is `True`, which is a truthy value, the code block on line 4 is executed.

On line 4, we passed is as an argument to the `print` function the string object `WORLD`, which is outputted to the console.

The concept demonstrated here is Truthiness and the string method `isupper()` that returns `True` if all characters of the string are uppercased, `False` otherwise.

> [!NOTE]
> @LSBot Feedback
> 
> Your explanation is very good! Let me provide some detailed feedback:
> 
> **Strengths:**
> 
> 1.  You correctly identified the output as "WORLD".  
> 2.  Your line-by-line explanation is clear and follows the program's execution order.  
> 3.  You accurately explained how the `isupper()` method works and its return value.  
> 4.  You mentioned the concept of truthiness, which is relevant to the conditional statement.
> 
> **Suggestions for improvement:**
> 
> 1.  Be a bit more precise about the conditional statement. While you described it as "checking for truthiness," it's more direct to say that the conditional is evaluating whether `name.isupper()` returns `True`.
> 2.  For the print statement, there's a small grammatical error when you wrote "passed is as an argument" - it should be "passed as an argument."
> 3.  You could enhance your explanation by mentioning that the `else` clause (line 6) is skipped entirely since the condition was true.
> 4.  Consider adding that string methods like `isupper()` don't modify the original string but return a new value.
> 
> **Revised explanation:**
> 
> The output of this code is `WORLD`.  
>   
> On line 1, we initialize a global variable `name` that references a string object with value `HELLO`.  
>   
> On line 3, we have a conditional statement that evaluates the return value of the `isupper()` method called on the value referenced by `name`. Since all characters in "HELLO" are uppercase, `isupper()` returns `True`.  
>   
> When the condition evaluates to `True`, the code block on line 4 is executed, and the `else` block is skipped. On line 4, we pass the string "WORLD" as an argument to the `print` function, which outputs it to the console.  
>   
> The code demonstrates string methods (specifically `isupper()`) and conditional execution based on the returned boolean value.

###  8. What do these print and why?
```python
def punctuation_type(str):
    if str == str.upper():
        print('This is all caps')
    elif str == str.lower():
        print('This is all lowercase')
    else:
        print('Neither')

str1 = 'HELLO'
str2 = 'yolo'
str3 = 'My Name Is: '

punctuation_type(str1)
punctuation_type(str2)
punctuation_type(str3)
```

**Answer**:

The output of this code is:

`This is all caps`
`This is all lowercase`
`Neither`

On line 9, we initialize a global variable `str1` that references a string object with value `HELLO`.

On line 10, we initialize a global variable `str2` to `yolo`.

On line 11, we initialize a global variable `str3` to `My Name Is: `.

On line 13, we call the function `punctuation_type` with the value referenced by `str1` as an argument.

From lines 1-7, we have the definition of the function `punctuation_type` with a single parameter `str`

The value referenced by `str1` is assigned to the function local variable `str`. Within the function, on line 2, there is a conditional statement that checks if the value referenced by `str` is equal to the returned value of invoking the `upper()` method on the same value. As both values are the same, the conditional statement evaluates as true and the code block on line 3 is executed, skipping the `elif` and `else` statements.

On line 3, the string object with value `This is all caps` is passed as an argument to the `print` function, which outputs it to the console.

On line 14, we call the function `punctuation_type` with the value referenced by `str2` as an argument.

The value referenced by `str2` is assigned to the function local variable `str`. Within the function, on line 2, the first conditional statement evaluates as falsy, so the code block is skipped. Then on line 4, the `elif` conditional statement is evaluated, by comparing the returned value of invoking the `islower()` method on the value referenced by `str` with `str`. This comparison evaluates as true, and the code block on line 5 is executed. The `else` statement is not evaluated.

On line 5, the string object with value `This is all lowercase` is passed as an argument to the `print` function, which outputs it to the console.

On line 15, we call the function `punctuation_type` with the value referenced by `str3` as an argument.

The value referenced by `str3` is assigned to the function local variable `str`. Within the function, on line 2, the first conditional statement evaluates as falsy, so the code block is skipped, as well as the `elif` statement. In this case, the `else` statement is evaluated and the code block on line 7 is exceuted.

On line 7, the string object with value `Neither` is passed as an argument to the `print` function, which outputs it to the console.

The concept demonstrated here are string methods, specifically `upper()` that returns a new string object with all characters uppercased and `lower()` that returns a new string object with all characters lowercased. Also the concept of truthiness is demonstrated by using the conditional statements to evaluate return values as true or false.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 92/100**
> 
> Your explanation correctly identifies the output and most aspects of the code's behavior. However, there's one notable error: in the explanation for `str2`, you mention "comparing the returned value of invoking the `islower()` method" but the code actually uses `str.lower()`, not `islower()`. These are different - `lower()` returns a new lowercase string while `islower()` would check if all characters are lowercase.
> 
> **Completeness: 90/100**
> 
> You provided a thorough line-by-line explanation covering:
> •   Variable initialization  
> •   Function calls and parameter assignment  
> •   Conditional logic flow  
> •   Output generation
> 
> **Areas for improvement:**
> 
> •   You could note that using `str` as a parameter name shadows the built-in `str` type, which is not recommended  
> •   You could explain why `str3` evaluates as "Neither" (because it contains both uppercase and lowercase letters plus special characters)  
> •   Mentioning that string methods like `upper()` and `lower()` return new strings without modifying the original would strengthen your explanation
> 
> **Precision: 88/100**
> 
> Your terminology is generally precise, showing understanding of:
> •   Function definitions and parameters  
> •   String methods and their behavior  
> •   Conditional flow control
> 
> **For greater precision:**
> •   Rather than saying a conditional "evaluates as truthy/falsy," it's better to say it "evaluates to True/False" since these comparisons (`==`) produce actual boolean values  
> •   The explanation about truthiness isn't fully accurate here - the code is using equality comparisons (`==`), not directly leveraging Python's truthiness rules
> 
> **Overall Assessment**
> 
> Your explanation demonstrates a solid understanding of Python fundamentals. The few inaccuracies are minor and don't detract from showing your grasp of how string methods work and how conditional execution flows. For further study, I recommend reviewing the difference between methods like `lower()` and `islower()` as covered in the [ALL CAPS](https://launchschool.com/exercises/e5d5729c) and [Ignoring Case](https://launchschool.com/exercises/ff3d30d2) exercises from the Python Basics materials.


### 9. What do these print and why?

```python
str1 = "    "
str2 = "  Hello   "
str3 = "Hello World"

print(str1.isspace())
print(str2.isspace())
print(str3.isspace())

sentence = "Hello     World!   How are you?   "
word_count = sum(1 for word in sentence.split() if not word.isspace())
print("Number of words in the sentence:", word_count)
```


### 10. What do these print and why?

```python
s = "   Hello, World!   "
print(s.strip())
print(s.strip(" !"))
```

### 11. What do these print and why?

```python
s = "www.example.com"
print(s.lstrip('wcmo.'))
```

### 12. What do these print and why?

```python
s = 'impatient'
print(s.rstrip('tp'))
print(s.rstrip('p'))
```

### 13. What do these print and why?

```python
s = "Hello, World!"
print(s.replace("Hello", "Hi"))
print(s.replace("o", "0"))
```

### 14. What do these print and why?

```python
sentence = "This is a sample sentence."
words = sentence.split()
print(words)

csv_data = "John,Doe,30,New York"
fields = csv_data.split(",")
print(fields)

sentence = "This is a sample sentence."
words = sentence.split(maxsplit=2)
print(words)
```

### 15. What does this print and why?

```python
str1 = "hello world"
str2 = str1.capitalize()
print("Original string:", str1)
print("Capitalized string:", str2)
```

## boolean vs. truthiness

### Basic Question:

- In Python, what values are considered Falsy and what are considered Truthy?

### 1. What do these print and why?

```python
truthy_values = [1, 2, 3, "hello", [1, 2, 3], {"a": 1}, True, 0, "", [], {}, None, False]

print(“Values:”)
for value in truthy_values:
    if value:
        print(f"{value} is truthy")
    else:
        print(f"{value} is falsy")
```

### 2. What do these print and why?

```python
x = 5
y = 10
z = 15

print(x > 0 and y < 20)
print(not x == y)
print(x < y and y < z)
print(x > y or y > z)
print(not (x > y))
```

### 3. What do these print and why?

```python
a = 10
b = 20

print(a < b < 30)
print(a > b or b == 20)
```

**Answer**:

The output is:

`True`
`True`

On line 1, the global variable `a` is initialize and references the integer object `10`.

On line 2, the global variable `b` is initialized and references the integer object `20`.

On line 4, we invoke the `print` function and passed in as an argument the expression `a < b < 30` that evaluates to `True` as `10` is less than `20` and `20` is less than `30`, outputting `True` to the console.

On line 5, we invoke the `print` function and passed in as an argument the logical expression `a > b or b == 20`. The left operand is evaluated first and it evaluates to `False`, as `10` is less than `20` and then the right operand is evaluated and it evaluates to `True` as `20 == 20`. The value is then output to the console.

The concept demonstrated is logical operations and truthiness.

> [!NOTE]
> @LSBot Feedback
> 
> **Overall Assessment:**
> 
> Your answer is well-structured and correctly identifies both outputs as `True`. Your explanation demonstrates good understanding of how Python evaluates chained comparisons and logical operators.
> **Strengths:**
> 1.  ​**Correct Output Identification**​: You correctly identified that both expressions evaluate to `True`
> 2.  ​**Variable Initialization**​: You properly explained how the variables are initialized and what values they reference  
> 3.  ​**Concept Identification**​: You correctly identified that this question demonstrates "logical operations and truthiness"
> 
> **Areas for Improvement:**
> 
> **1. Chained Comparison Explanation**
> Your explanation of the chained comparison could be more precise about how Python processes it:
> 
> ```python
> # For the expression a < b < 30  
> # Python evaluates this as (a < b) and (b < 30)  
> # This is syntactic sugar for combining two comparisons with the and operator  
> print((10 < 20) and (20 < 30))  # Both are True, so result is True  
> ```  
>  
> **2. Short-Circuit Evaluation**
> 
> Your explanation of the logical OR could mention short-circuit evaluation:
> 
> ```python
> # For the expression a > b or b == 20  
> # The left operand (a > b) evaluates to False  
> # Since this is an OR operation and the left side is False, Python must evaluate  
> # the right side (b == 20), which is True  
> # Due to short-circuit evaluation, if the left side had been True,   
> # Python wouldn't have needed to evaluate the right side at all  
> ```
> 
> **3. Operator Precedence**
> 
> You could mention operator precedence to demonstrate deeper understanding:
> 
> ```python
> # Python's operator precedence ensures that comparison operators like < and ==  
> # are evaluated before logical operators like 'or'  
> # So a > b or b == 20 is evaluated as (a > b) or (b == 20)  
> ```
>   
> **Summary:**
> 
> Your answer is technically correct and shows good understanding of Python's logical operations. The suggested improvements focus on providing more technical depth by explaining how Python specifically handles chained comparisons and short-circuit evaluation of logical operators. 
> 
> These concepts are important for understanding Python's behavior in more complex logical expressions.
> 
> **Scores:**
> •   Accuracy: 95/100 (Your answer correctly explains the outputs)  
> •   Completeness: 85/100 (Good coverage but missing some technical details about chain comparison and short-circuit evaluation)  
> •   Precision: 90/100 (Good use of terminology but could be more specific about Python's evaluation process)

### 4. What do these print and why?

```python
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)
print(6 not in my_list)
```

### 5. What do these print and why?

```python
temperature = 25
time_of_day = "morning"

if temperature < 30 and (time_of_day == "morning" or time_of_day == "afternoon"):
    print("It's a pleasant day!")
else:
    print("It's either too hot or not the right time of day.")
```

### 6. What does this print and why?

```python
num = 12

if num / 3 < 3 and num > 10:
    print("Hello")
elif num >= 8 and num < 6 or num > 4 and num < 16:
    print("Hello 2")
elif num % 4 == 0 or num < 7 and num < 10:
    print("Hello 3")
else:
    print("Buy")
```

## ranges

### Basic questions:

- Is a range primitive or non-primitive?
- Is a range mutable or immutable?
- Does range have a literal form or a type constructor?
- Is a range a sequence or a collection?
- What is the most common use of the range datatype?
- Are ranges homogenous or heterogeneous?
- Why are ranges considered lazy?

### 1. What do these print and why? What concept does this demonstrate?

```python
print(range(0,10))
print(len(range(5, 15)))
print(my_range[1])
print(str(range(3, 7)))
print(list(range(12, 8, -1)))
print(list(range(5, 5, 1)))
print(5 in range(5))
print(5 not in range(5, 10))
```

### 2. What does this code print and why? What concept does this demonstrate?

```python
example = range(0)
if example:
    print(list(example))
else:
    print(example)
```

### 3. What does this code print and why? What concept does this demonstrate?

```python
def number_range(number):
    match number:
        case n if n < 0:
            print(f'{number} is less than 0')
        case n if n <= 50:
            print(f'{number} is between 0 and 50')
        case n if 50 < n <= 100:
            print(f'{number} is between 51 and 100')
        case _:
            print(f'{number} is greater than 100')
number_range(0)
number_range(25)
```

## list and dictionary syntax

### Basic Questions

- What categories are lists and dictionaries?
- Are they mutable or immutable?
- Are they primitive or non-primitve?
- Are they literals, or do they require type constructors?
- Are they sequences?
- Does the order of the elements in both matter?


## List methods: len(list), list.append(), list.pop(), list.reverse()

### 1. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
length_of_list = len(my_list)
print("Length of the list:", length_of_list)
```

### 2. What does this print and why?

```python
lst_one = [0, 1, 2, 3]
lst_two = lst_one.append(4)
if lst_two:
    print(lst_two)
else:
    print(lst_one)
```

### 3. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
ele = my_list.pop()
print("Popped element:", ele)
print("List after popping:", my_list)
ele1 = my_list.pop(1)
print("Popped element at index 1:", ele1)
print("Modified list after popping at index 1:", my_list)
```

### 4. What does this print and why?

```python
elements = [0, 1 , 2, "Dima"]
print(elements.reverse())
print(elements)
```

### 5. What does this print and why?

```python
ages = {
    "dimo": 31,
    "olena": 32,
    "tetiana": 28
}

def get_val_of_dimo(info):
    try:
        info['dimo']
        return info['dimo']
    except KeyError:
        return "Typo"

print(get_val_of_dimo(ages))
```

### 6. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
keys = my_dict.keys()
print(keys)
for key in keys:
    print(key)
```

### 7. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
values = my_dict.values()
print(values)
for value in values:
    print(value)
```

### 8. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
items = my_dict.items()
print(items)
for key, value in items:
    print(key, value)
```

## variable scope, global keyword, variables as pointers, variable shadowing

### 1. What does this print and why?

```python
name = 'John'

def greet():
    print(f"Hello, {name}!")

greet()
```

**Answer**:

The output is `Hello, John!`

On line 1, we initialize a global variable `name` that references a string object with the value `John`.

On line 6, we invoke the `greet()` function without any arguments.

Within the function, we invoke the `print()` function and passed in as an argument an f-string that interpolates the object referenced by `name` into the string, outputting `Hello, John!`.

This code demonstrates variable scope, as global variables are accessible within functions.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**  
> **Completeness: 100/100**  
> **Precision: 95/100**
> 
> Your explanation thoroughly covers what happens in the code and demonstrates a solid understanding of variable scope in Python. 
> 
> You correctly identified that:
> 1.  `name` is a global variable initialized with the string value 'John'  
> 2.  The function `greet()` is called without arguments  
> 3.  Inside the function, the global variable `name` is accessible  
> 4.  The print statement uses an f-string to interpolate the value of `name`
> 
> The explanation is precise in how you describe variable initialization and function invocation. The only small improvement I might suggest is to be more specific about why global variables are accessible in functions:
> 
> According to the "Variable Scope" lesson, this illustrates ​**Rule 3**​ of Python's variable scope: "Variables that are defined in an outer scope are visible to inner scopes (such as functions)" ([Variable Scope](https://launchschool.com/lessons/a29e9831/assignments/ece75c22)). This is a fundamental aspect of Python's lexical scoping.
> 
> This is a well-constructed answer that would serve you well on your assessment. Keep up the good work!

### 2. What does this print and why?

```python
def assign():
    var = 20
    print(var)

assign()
```

**Answer**:

The output is `20`

On line 5, we invoke que `assign()` function.

From lines 1-3, the `assign()` function is defined. Within the function, on line 2, a local variable `var` is initialized and references an integer object with value `20`. On line 3, we invoke the `print` function and passed in the value referenced by `var` as an argument, outputting it to the console.

The concept demonstrated here is variable scope and how variables initialized inside a function are scoped locally to the function and cannot be access in an outer scope.

> [!NOTE]
> @LSBot feedback
> 
> Your answer is excellent! Let me provide detailed feedback:
> 
> **Accuracy: 100/100**  
> **Completeness: 100/100**  
> **Precision: 95/100**
> 
> Your explanation accurately describes what happens in the code:
> 1.  You correctly identified that the output is `20`.  
> 2.  You properly explained the function invocation on line 5.  
> 3.  You clearly described the local variable initialization inside the function.  
> 4.  You accurately explained how the `print` function displays the value.  
> 5.  You identified the key concept of variable scope.
> 
> Your answer demonstrates a strong understanding of local variable scope in Python. As shown in the "Variable Scope" exercises, variables defined within a function are indeed local to that function and can't be accessed from outside it, as seen in exercises like [What's my value? (Part 6)](https://launchschool.com/exercises/bf82f0d4).
> 
> **A small suggestion for precision: **
> 
> You could mention that this is an example of a local variable that is initialized within the function's local scope, making it accessible only within that function. This is a fundamental aspect of Python's scoping rules that will be important for your assessment.
> 
> Overall, your answer is well-structured and demonstrates a solid understanding of Python's variable scope rules. Keep up the excellent work!

### 3. What does this print and why?

```python
try:
    print(var)
except NameError as e:
    print("Error occurred")
```

**Answer**:

The output is `Error occurred`.

The reason is that when invoking the `print` function inside the `try` block, the variable `var` cannot be found in any scope, raising the `NameError` exception, which is caught in the `except` block, in which the `print` function is invoked and gets passed in the string object with value `Error occurred` as an argument.

The concept demonstrated is Exception Handling.

> [!NOTE]
> @LSBot Feedback
> 
> **Overall Assessment:**
> 
> Your answer correctly identifies the output and describes the basic mechanism of the exception handling process. Your explanation shows understanding of the try-except flow and the specific exception being caught.
> 
> **Strengths:**
> 1.  ​**Output Identification**​: Correctly identifies "Error occurred" as the output  
> 2.  ​**Exception Recognition**​: Correctly identifies that a NameError occurs due to the undefined variable  
> 3.  ​**Concept Identification**​: Appropriately names "Exception Handling" as the concept being demonstrated
> 
> **Areas for Improvement:**
> **1. Technical Precision**
> 
> Your explanation could use more precise terminology about exception handling:
> 
> The code demonstrates Python's exception handling mechanism. The try block attempts to execute code that might raise an exception. When accessing the undefined variable `var`, Python raises a NameError exception. The except clause specifically catches this NameError (indicated by "except NameError as e"), and executes its block instead of allowing the program to crash. The exception object is captured in the variable `e`, though it's not used in this example.  
> 
> **2. Flow Description**
> 
> Your explanation could better articulate the control flow that happens:
> 
> When Python executes this code, it first attempts to run the code in the try block. Since `var` is not defined in any accessible scope, Python immediately stops executing the try block, jumps to the except handler that matches the exception type (NameError), and executes that handler's code. The program continues running after the try-except construct rather than terminating with an error.  
> 
> **3. Exception Object Mention**
> 
> Your answer doesn't mention the role of the named exception object:
> 
> Note that "as e" captures the exception object, allowing access to details of the exception, though this capability isn't utilized in the print statement. This pattern is useful when more information about the exception is needed.  
> 
> **Summary:**
> 
> Your answer is fundamentally correct but could be more detailed in explaining the exact mechanics of exception handling in Python. The areas for improvement focus on using more precise technical language and providing a more complete explanation of what happens during the try-except process. These details would demonstrate deeper knowledge of Python's exception handling system.
> 
> **Scores:**
> •   Accuracy: 90/100 (Your answer is correct but could provide more details)  
> •   Completeness: 75/100 (Missing explanation of exception object and flow control)  
> •   Precision: 85/100 (Uses mostly correct terminology but could be more technical)

### 4. What does this print and why?

```python
var = 10

def function1():
    var = 20
    print(var)

function1()

try:
    print(var)
except NameError:
    print("Error occurred")

def function2():
    var += 5
    print(var)

try:
    function2()
except UnboundLocalError:
    print("Error occurred")

def function3():
    global var
    var += 5
    print(var)

function3()
print(var)
```


### 5. What does this print and why?

```python
var = 10

def function1():
    print(var)

function1()

def function2():
    var = 20
    print(var)

function2()
print(var)
```

### 6. What does this print and why?

```python
def function1():
    x = 10

    def function2():
        y = 20
        print(x)

    function2()
    print(x)

function1()
print(x)
print(y)
```

### 7. What does this print and why?

```python
var = 10

def access():
    print(var)
```