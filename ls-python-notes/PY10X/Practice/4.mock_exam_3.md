# Mock Exam #3

### 1: What coercion is happening here? Is it implicit or explicit?

```python
month = "December"
day = int(input("What day is it? "))
print(f"Today is the {day} of {month}")
```

#### Answer

In this code snippet we can see both explicit and implicit coercion.

On line 1, a global variable `month` is initialized and references a string object with value `December`.

On line 2, the `input` function is invoked and gets passed in the string object with value `What day is it? ` as an argument. The `input` function allow us to request for input values from the console. Once the use inputs a value, this will be pass as an argument to the built-in function `int`, which we are using to coerce explicitly the return value from the `input` function, which is of type `string` to an integer value. If the coercion is successful, the returned value of type integer is assigned to the global variable `day`.

On line 3, we have a formatted-string, denoted by the presence of the prefix `f` before the string object with value `Today is the {day} of {month}`. At runtime, the values referenced by the variables `day` and `month` are coerced implicitly into a string object, and interpolated into the string, which is then pass as an argument to the `print` function invocation, which outputs the value into the console.

> [!NOTE]
> **Review of Your Answer**
> 
> **Score for Task 1**
> •   ​**Accuracy**​: 85/100  
> •   ​**Completeness**​: 90/100  
> •   ​**Precision**​: 85/100
> 
> **Feedback on Your Answer:**
> 
> Your explanation correctly identifies both explicit and implicit coercion in the code snippet, which is the main focus of the question. Here's a detailed breakdown of your answer:
> 
> **Strengths:**
> •   You correctly identified that `int(input(...))` is an explicit coercion from string to integer  
> •   You accurately noted that string interpolation in the f-string implicitly coerces values to strings  
> •   Your explanation provides good line-by-line analysis of the code
> 
> **Areas for Improvement:**
> 1.  ​**About the implicit coercion in f-strings**​:  
>    According to the [Type Conversions assignment](https://launchschool.com/lessons/a29e9831/assignments/ed956456), when you use string interpolation, "Python automatically coerces the values to strings using the `str()` function." This is a bit more specific than just saying values are "coerced implicitly into a string object."
>    2.  ​**About the `print()` function**​:  
>    The assignment specifically notes: "`print()` isn't considered to be coercion. While it does coerce its arguments to strings, that is done behind the scenes. It doesn't return the resulting strings; it just prints them." Your explanation implies that the string is passed to `print()` which then outputs it, but doesn't clarify this specific distinction.
>    3.  ​**Minor technical details**​:  
>    •   There's a typo where you say "Once the use inputs a value" instead of "user"  
>    •   The explanation could be more precise about variable initialization (e.g., mentioning that variables are binding names to objects)
>    
>    For a more complete answer, you could have also mentioned that if the user inputs a non-numeric value, the explicit coercion using `int()` would raise a `ValueError` as noted in the assignment.
>    
>    Overall, your answer demonstrates a solid understanding of the concept of type coercion in Python, both explicit and implicit, but could benefit from more precision in the technical language used and addressing the specific handling of coercion in the `print()` function.

### 2: What does this print and why, what concept does this demonstrate?

```python
def addition(number1, number2):
    number1 += number2

x = 1
y = 2

addition(x, y)
print(f"x is {x}, y is {y}")
```

#### Answer

This code outputs `x is 1, y is 2`.

On line 4, a global variable `x` is initialized and references an integer object with value `1`.

On line 5, a global variable `y` is initialized and references an integer object with value `2`.

On line 7, we invoke the function `addition` and pass in the values referenced by `x` and `y` as an argument.

On lines 1-2, the `addition` function is defined with 2 parameters, `number1` and `number2`.

Within the function, on line 2, there is an augmented assignment, in which the local variable `number1` is reassigned to the return value of adding the value referenced by `number2` and `number1`, which is `3`. As there is no explicit return keyword, `None` is returned implicitly from the function, having no impact on the global variables `x` and `y`.

On line 8, we have a formatted-string or f-string, denoted by the prefix `f` before the string. The values referenced by `x` and `y` are interpolated into the string at runtime, and implicitly coerced into a string by using the `str` built-in function. The return value is then passed in as an argument to the `print` function, which outputs it into the console. The `print` function coerces the values into strings, but this is technically not a coercion as it happens behind the scenes and have no impact on the return values.

The main concept demonstrated here is pass-by-object-reference, in which the values passed in into the function are not mutated because the values referenced by the local variables `number1` and `number2` are immutable (integers), having no effect on the values referenced by the global variables `x` and `y`. Also the fact that the function has no return keyword, demonstrates the concept of implicit return values, in this case `None`.

> [!NOTE]
> **Review of Your Answer f**
> 
> **Score for Task 2**
> •   ​**Accuracy**​: 90/100  
> •   ​**Completeness**​: 92/100  
> •   ​**Precision**​: 88/100
> 
> **Feedback on Your Answer:**
> 
> Your explanation correctly identifies the output and provides a thorough analysis of the code. You've demonstrated a good understanding of several important Python concepts.
> 
> **Strengths:**
> •   You correctly identified the output as `x is 1, y is 2`  
> •   Your line-by-line explanation is detailed and follows the code execution flow  
> •   You correctly explained the concept of variable scoping (local vs global variables)  
> •   You properly identified that integers are immutable in Python  
> •   You explained the pass-by-object-reference concept, which is central to this example
> 
> **Areas for Improvement:**
> 1.  ​**Variable Assignment vs. Object Mutation**​: Your explanation is good, but could be more explicit about why `number1 += number2` doesn't affect the global variable. This is because assignment creates a new local variable rather than mutating the object. This is the key distinction demonstrated in Example 2 from the [Variables and Functions assignment](https://launchschool.com/lessons/a29e9831/assignments/77228399), which shows how assignment inside a function creates a local variable.
> 2.  ​**Parameter Passing**​: You could clarify that when `x` and `y` are passed to the function, their values (1 and 2) are passed, not the variables themselves. The parameters `number1` and `number2` are local variables that initially reference the same objects as `x` and `y`.
> 3.  ​**Variable Scope**​: You could more explicitly connect this example to Python's variable scope rules, specifically how variables assigned within a function are local to that function unless declared global.
> 4.  ​**Function Return Value**​: Your mention of the implicit `None` return value is correct but could be more concise since it's not central to the main concept being demonstrated.
> 
> For a more focused answer, you might structure it to emphasize that this code primarily demonstrates variable scope and the fact that assignment within a function creates local variables rather than modifying variables in the outer scope.
> 
> Overall, your answer is strong and demonstrates a good understanding of Python's variable scope and parameter passing mechanisms. A bit more precision in explaining the specific principle being demonstrated would make it even better.

### 3. What does this print and why? What concept does this cover? How would you refactor this to remove the space?

```python
print(2 + 3 * 4, 4 * (3 + 2))
```

### 4. What does this print and why? What concept is this?

```python
name = 'Alexander Graham Bell'
print(name[0])
```

### 5. What does this print and why?

```python
string1 = "HelloWorld"
string2 = "12345"
string3 = "Hello World"

result1 = string1.isalpha()
result2 = string2.isalpha()
result3 = string3.isalpha()

print("Is '{}' alphabetic?".format(string1), result1)
print("Is '{}' alphabetic?".format(string2), result2)
print("Is '{}' alphabetic?".format(string3), result3)
```

### 6. What do these print and why?

```python
s1 = "123abc"
print(s1.isdigit())
s2 = "123$%^"
print(s2.isdigit())
s3 = ""
print(s3.isdigit())
s4 = "12345"
print(s4.isdigit())
```

### 7. What do these print and why?

```python
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)
print(6 not in my_list)
```

### 8. What do these print and why?

```python
temperature = 25
time_of_day = "morning"

if temperature < 30 and (time_of_day == "morning" or time_of_day == "afternoon"):
    print("It's a pleasant day!")
else:
    print("It's either too hot or not the right time of day.")
```

### 9. What does this code print and why? What concept does this demonstrate?

```python
def number_range(number):
    match number:
        case n if n < 0:
            print(f'{number} is less than 0')
        case n if n <= 50:
            print(f'{number} is between 0 and 50')
        case n if 50 < n <= 100:
            print(f'{number} is between 51 and 100')
        case _:
            print(f'{number} is greater than 100')
number_range(0)
number_range(25)
```

### 10. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
ele = my_list.pop()
print("Popped element:", ele)
print("List after popping:", my_list)
ele1 = my_list.pop(1)
print("Popped element at index 1:", ele1)
print("Modified list after popping at index 1:", my_list)
```
