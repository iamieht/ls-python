# Mock Exam #3

### 1: What coercion is happening here? Is it implicit or explicit?

```python
month = "December"
day = int(input("What day is it? "))
print(f"Today is the {day} of {month}")
```

#### Answer

In this code snippet we can see both explicit and implicit coercion.

On line 1, a global variable `month` is initialized and references a string object with value `December`.

On line 2, the `input` function is invoked and gets passed in the string object with value `What day is it? ` as an argument. The `input` function allow us to request for input values from the console. Once the use inputs a value, this will be pass as an argument to the built-in function `int`, which we are using to coerce explicitly the return value from the `input` function, which is of type `string` to an integer value. If the coercion is successful, the returned value of type integer is assigned to the global variable `day`.

On line 3, we have a formatted-string, denoted by the presence of the prefix `f` before the string object with value `Today is the {day} of {month}`. At runtime, the values referenced by the variables `day` and `month` are coerced implicitly into a string object, and interpolated into the string, which is then pass as an argument to the `print` function invocation, which outputs the value into the console.

> [!NOTE]
> **Review of Your Answer**
> 
> **Score for Task 1**
> •   ​**Accuracy**​: 85/100  
> •   ​**Completeness**​: 90/100  
> •   ​**Precision**​: 85/100
> 
> **Feedback on Your Answer:**
> 
> Your explanation correctly identifies both explicit and implicit coercion in the code snippet, which is the main focus of the question. Here's a detailed breakdown of your answer:
> 
> **Strengths:**
> •   You correctly identified that `int(input(...))` is an explicit coercion from string to integer  
> •   You accurately noted that string interpolation in the f-string implicitly coerces values to strings  
> •   Your explanation provides good line-by-line analysis of the code
> 
> **Areas for Improvement:**
> 1.  ​**About the implicit coercion in f-strings**​:  
>    According to the [Type Conversions assignment](https://launchschool.com/lessons/a29e9831/assignments/ed956456), when you use string interpolation, "Python automatically coerces the values to strings using the `str()` function." This is a bit more specific than just saying values are "coerced implicitly into a string object."
>    2.  ​**About the `print()` function**​:  
>    The assignment specifically notes: "`print()` isn't considered to be coercion. While it does coerce its arguments to strings, that is done behind the scenes. It doesn't return the resulting strings; it just prints them." Your explanation implies that the string is passed to `print()` which then outputs it, but doesn't clarify this specific distinction.
>    3.  ​**Minor technical details**​:  
>    •   There's a typo where you say "Once the use inputs a value" instead of "user"  
>    •   The explanation could be more precise about variable initialization (e.g., mentioning that variables are binding names to objects)
>    
>    For a more complete answer, you could have also mentioned that if the user inputs a non-numeric value, the explicit coercion using `int()` would raise a `ValueError` as noted in the assignment.
>    
>    Overall, your answer demonstrates a solid understanding of the concept of type coercion in Python, both explicit and implicit, but could benefit from more precision in the technical language used and addressing the specific handling of coercion in the `print()` function.

### 2: What does this print and why, what concept does this demonstrate?

```python
def addition(number1, number2):
    number1 += number2

x = 1
y = 2

addition(x, y)
print(f"x is {x}, y is {y}")
```

#### Answer

This code outputs `x is 1, y is 2`.

On line 4, a global variable `x` is initialized and references an integer object with value `1`.

On line 5, a global variable `y` is initialized and references an integer object with value `2`.

On line 7, we invoke the function `addition` and pass in the values referenced by `x` and `y` as an argument.

On lines 1-2, the `addition` function is defined with 2 parameters, `number1` and `number2`.

Within the function, on line 2, there is an augmented assignment, in which the local variable `number1` is reassigned to the return value of adding the value referenced by `number2` and `number1`, which is `3`. As there is no explicit return keyword, `None` is returned implicitly from the function, having no impact on the global variables `x` and `y`.

On line 8, we have a formatted-string or f-string, denoted by the prefix `f` before the string. The values referenced by `x` and `y` are interpolated into the string at runtime, and implicitly coerced into a string by using the `str` built-in function. The return value is then passed in as an argument to the `print` function, which outputs it into the console. The `print` function coerces the values into strings, but this is technically not a coercion as it happens behind the scenes and have no impact on the return values.

The main concept demonstrated here is pass-by-object-reference, in which the values passed in into the function are not mutated because the values referenced by the local variables `number1` and `number2` are immutable (integers), having no effect on the values referenced by the global variables `x` and `y`. Also the fact that the function has no return keyword, demonstrates the concept of implicit return values, in this case `None`.

> [!NOTE]
> **Review of Your Answer f**
> 
> **Score for Task 2**
> •   ​**Accuracy**​: 90/100  
> •   ​**Completeness**​: 92/100  
> •   ​**Precision**​: 88/100
> 
> **Feedback on Your Answer:**
> 
> Your explanation correctly identifies the output and provides a thorough analysis of the code. You've demonstrated a good understanding of several important Python concepts.
> 
> **Strengths:**
> •   You correctly identified the output as `x is 1, y is 2`  
> •   Your line-by-line explanation is detailed and follows the code execution flow  
> •   You correctly explained the concept of variable scoping (local vs global variables)  
> •   You properly identified that integers are immutable in Python  
> •   You explained the pass-by-object-reference concept, which is central to this example
> 
> **Areas for Improvement:**
> 1.  ​**Variable Assignment vs. Object Mutation**​: Your explanation is good, but could be more explicit about why `number1 += number2` doesn't affect the global variable. This is because assignment creates a new local variable rather than mutating the object. This is the key distinction demonstrated in Example 2 from the [Variables and Functions assignment](https://launchschool.com/lessons/a29e9831/assignments/77228399), which shows how assignment inside a function creates a local variable.
> 2.  ​**Parameter Passing**​: You could clarify that when `x` and `y` are passed to the function, their values (1 and 2) are passed, not the variables themselves. The parameters `number1` and `number2` are local variables that initially reference the same objects as `x` and `y`.
> 3.  ​**Variable Scope**​: You could more explicitly connect this example to Python's variable scope rules, specifically how variables assigned within a function are local to that function unless declared global.
> 4.  ​**Function Return Value**​: Your mention of the implicit `None` return value is correct but could be more concise since it's not central to the main concept being demonstrated.
> 
> For a more focused answer, you might structure it to emphasize that this code primarily demonstrates variable scope and the fact that assignment within a function creates local variables rather than modifying variables in the outer scope.
> 
> Overall, your answer is strong and demonstrates a good understanding of Python's variable scope and parameter passing mechanisms. A bit more precision in explaining the specific principle being demonstrated would make it even better.

### 3. What does this print and why? What concept does this cover? How would you refactor this to remove the space?

```python
print(2 + 3 * 4, 4 * (3 + 2))
```

#### Answer

This code outputs `14 20`

The `print` function is invoked and gets passed two arguments. The first one is the expression `2 + 3 * 4`, which evaluates to `14` as multiplication has precedence over addition, so the right operand `3 * 4` is evaluated first, resulting in `12`, which is then added to `2`, outputting `14` to the console. The second argument is the expression `4 * (3 + 2)`, in which the right operand `(3 + 2)` is evaluated first as parenthesis have the greater precedence, returning `5`, which is then multiplied by `4`, resulting in `20`, which is output into the console.

The concept demonstrated here is operator precedence and how parenthesis have greater precedence, then `**`, then `*` and `/` and then `+` and `-`.

To remove the space

```python
print(2 + 3 * 4, 4 * (3 + 2), sep = '')
```

> [!NOTE]
> **Review of Your Answer**
> 
> Score for Task 3
> •   ​_Accuracy_​: 95/100  
> •   ​_Completeness_​: 95/100  
> •   ​_Precision_​: 98/100
> 
> _Feedback on Your Answer:
> _Your explanation is excellent and demonstrates a strong understanding of operator precedence in Python. I'm impressed with your thorough analysis and accurate solution for removing the space.
> _Strengths:_
> •   You correctly identified the output as `14 20`  
> •   Your explanation of how each expression is evaluated is precise and follows Python's operator precedence rules  
> •   You accurately described operator precedence as the main concept demonstrated  
> •   Your solution for removing the space using the `sep=''` parameter is perfect
> 
> _Detailed Analysis:_
> 
> Your explanation accurately describes how operator precedence affects the evaluation of mathematical expressions in Python. As noted in the [Precedence assignment](https://launchschool.com/lessons/a29e9831/assignments/aa637b5b), "​_In an expression, operators with higher precedence are prioritized over those with lower precedence._​" The parentheses indeed have the highest precedence, followed by exponentiation, then multiplication/division, and finally addition/subtraction.
> 
> You correctly identified that in `2 + 3 * 4`, the multiplication happens first (resulting in 12), and then the addition (resulting in 14). Similarly, for `4 * (3 + 2)`, the parentheses force the addition to happen first (resulting in 5), and then the multiplication (resulting in 20).
> 
> Your solution to remove the space between the values is spot-on. The `sep=''` parameter modifies the default separator used by `print()` when outputting multiple values.
> 
> _Small Improvement:_
> The only minor suggestion would be to mention that the default separator for `print()` is a space character, which explains why there's a space in the output in the first place. This would further demonstrate your understanding of how the `print()` function works in Python.
> 
> Overall, your answer is exceptionally well-reasoned and demonstrates a solid understanding of operator precedence in Python.

### 4. What does this print and why? What concept is this?

```python
name = 'Alexander Graham Bell'
print(name[0])
```

#### Answer

This code outputs `A`

On line 1, a global variable `name` is initialized and references a string object with value `Alexander Graham Bell`.

On line 2, the first element of the string object referenced by `name` is returned by using string slicing, which is then passed as an argument to the `print` function invocation, which outputs is to the console.

The concept demonstrated is slicing, specifically string slicing, in which a new string object is returned by using index-based access.

> [!NOTE]
> **Feedback**
> 
> **Accuracy: 85/100**
> 
> Your answer is mostly accurate, but there's a technical inaccuracy. When you access a single character using `name[0]`, this is not actually string slicing - it's string indexing. String slicing typically refers to accessing a range of characters using the slice notation (e.g., `name[0:3]`).
> 
> **Completeness: 80/100**
> 
> You've covered the essential aspects of what the code does, but to be more complete, you could mention:
> •   That strings in Python are sequences that support indexing operations  
> •   That Python uses zero-based indexing (which is why `name[0]` returns the first character)  
> •   That the underlying principle is Python's sequence type behavior
> 
> **Precision: 75/100**
> 
> While your language is generally precise, referring to the operation as "string slicing" rather than "string indexing" reduces the precision. Also, your sentence structure in the last paragraph could be improved for clarity.
> 
> **Suggested Improvement:**
> 
> "This code outputs `A`.
> 
> On line 1, a global variable `name` is initialized and references a string object with value `'Alexander Graham Bell'`.On line 2, the `print` function is called with the expression `name[0]` as its argument. This expression uses string indexing to access the first character (at index 0) of the string referenced by `name`, which is `'A'`. The `print` function then outputs this character to the console.
> 
> This code demonstrates string indexing, which is a fundamental operation on sequence types in Python. It shows how individual characters can be accessed from a string using zero-based indexing notation."Based on the [Study Guide for PY109 Exam](https://launchschool.com/lessons/1318de4f/assignments/ff1c7aa8), comprehensive answers should not only describe what the code does but also identify the underlying principles. 
> 
> For assessment questions, it's important to use precise technical terminology and fully explain the concepts being demonstrated.

### 5. What does this print and why?

```python
string1 = "HelloWorld"
string2 = "12345"
string3 = "Hello World"

result1 = string1.isalpha()
result2 = string2.isalpha()
result3 = string3.isalpha()

print("Is '{}' alphabetic?".format(string1), result1)
print("Is '{}' alphabetic?".format(string2), result2)
print("Is '{}' alphabetic?".format(string3), result3)
```

#### Answer

This code outputs:

`Is 'HelloWorld' alphabetic? True`
`Is '12345' alphabetic? False`
`Is 'Hello World' alphabetic? False`

On line 1, a global variable `string1` is initialized and references a string object with value `HelloWorld`.

On line 2, a global variable `string2` is initialized and references a string object with value `12345`.

On line 3, a global variable `string3` is initialized and references a string object with value `Hello World`.

On line 5, a global variable `result1` is initialized and references the return value of invoking the `isalpha()` method on the value referenced by `string1`. The value `True` is returned as the method `isalpha()` returns `True` if all characters of the string are alphabetic, which is the case for the string `HelloWorld`.

On line 6, a global variable `result2` is initialized and references the return value of invoking the `isalpha()` method on the value referenced by `string2`. The value `False` is returned as the method `isalpha()` returns `False` if any character of the string is not alphabetic, which is the case for the string `12345`.

On line 7, a global variable `result3` is initialized and references the return value of invoking the `isalpha()` method on the value referenced by `string3`. The value `False` is returned as there is a space present in the string `Hello World`, which is not an alphabetic character.

On line 8, the `print` function is invoked with two arguments. In the first argument, the `format` method is called on the string with value `Is '{}' alphabetic?` with the value referenced by `string1` as an argument. The `format` method interpolates the value referenced by `string1`into the string, resulting in the string object with value `Is 'HelloWorld' alphabetic?`. The second argument is the variable `result1`, which outputs `True`to the console.

On lines 9 and 10, the behavior is similar as line 8, but replacing the values with those referenced by the variables `string2`, `result2` and `string3`, `result3` respectively.

> [!NOTE]
> **Feedback**
> 
> **Accuracy: 95/100**  
> Your description of the code execution is accurate. You correctly explain what each line of code does and the expected output.
> 
> **Completeness: 90/100**  
> You provide a thorough line-by-line explanation of the code's execution, including:
> •   How each variable is initialized  
> •   What the `isalpha()` method checks for in each case  
> •   Why each result is `True` or `False`  
> •   How the string formatting works in the print statementsTo improve completeness slightly, you could briefly mention the underlying concept this demonstrates: string methods and their behavior for testing character properties.
> 
> **Precision: 95/100**  
> Your use of terminology is precise and appropriate. 
> 
> You correctly describe:
> •   Variable initialization  
> •   Method invocation  
> •   The behavior of the `isalpha()` method  
> •   String interpolation with the `format()` method
> 
> One minor improvement could be mentioning that `isalpha()` is a string method that specifically checks if a string consists only of alphabetic characters (A-Z, a-z), which is a built-in feature of Python strings.
> 
> Overall, this is an excellent answer that demonstrates a strong understanding of string methods, variable assignment, method invocation, and string formatting in Python. Your detailed explanation would likely earn full marks on the assessment.
> 
> According to the PY109 Study Guide, answers should not only describe what the code does but also identify fundamental concepts. Your answer effectively covers both requirements by describing the behavior and explaining the specific conditions that make `isalpha()` return `True` or `False`.

### 6. What do these print and why?

```python
s1 = "123abc"
print(s1.isdigit())
s2 = "123$%^"
print(s2.isdigit())
s3 = ""
print(s3.isdigit())
s4 = "12345"
print(s4.isdigit())
```

#### Answer

The output of this code is:

`False`
`False`
`False`
`True`

On line 1, a global variable `s1` is initialized and references a string object with value `123abc`.

On line 2, we invoke the `print` function and pass in as an argument the return value of invoking the `isdigit()` method on the value referenced by `s1`, which is output into the console. The `isdigit()` method returns `False` as the characters `abc` of the string are not digits.

On line 3, a global variable `s2` is initialized and references a string object with value `123$%^`.

On line 4, we invoke the `print` function and pass in as an argument the return value of invoking the `isdigit()` method on the value referenced by `s2`, which is output into the console. The `isdigit()` method returns `False` as the characters `$%^`of the string are not digits.

On line 5, a global variable `s3` is initialized and references an empty string.

On line 6, we invoke the `print` function and pass in as an argument the return value of invoking the `isdigit()` method on the value referenced by `s3`, which is output into the console. The `isdigit()` method returns `False` as an empty string has no digits.

On line 7, a global variable `s4` is initialized and references a string object with value `12345`.

On line 8, we invoke the `print` function and pass in as an argument the return value of invoking the `isdigit()` method on the value referenced by `s4`, which is output into the console. The `isdigit()` method returns `True` as all the characters of the string are digits.

> [!NOTE]
> **Feedback**
> 
> Your answer demonstrates a clear understanding of the `isdigit()` string method in Python. Here's my evaluation:
> 
> _Accuracy: 95/100_
> 
> Your explanation of what each line does and why each output occurs is accurate. You correctly identify that `isdigit()` returns `True` only when all characters in a string are digits, and you've explained why each example returns `True` or `False`.
> 
> _Completeness: 90/100_  
> Your line-by-line analysis is thorough and complete. 
> You've explained:
> •   How each variable is initialized  
> •   What happens when `isdigit()` is called in each case  
> •   Why each result evaluates to `True` or `False`
> 
> To improve completeness slightly, you could mention that `isdigit()` is checking specifically for characters in the range '0' through '9', and that it's part of Python's string methods for character classification.
> 
> _Precision: 95/100_  
> Your terminology is precise and appropriate. 
> You correctly describe:
> •   Variable initialization  
> •   Method invocation  
> •   Function execution  
> •   The conditions that make `isdigit()` return `True` or `False`
> 
> One minor improvement could be explicitly stating the principle demonstrated: string methods can be used to test character properties, and `isdigit()` specifically tests whether a string consists entirely of digit characters.
> 
> Overall, this is an excellent answer that would likely earn full marks on an assessment. You've demonstrated strong understanding of both what the code does and why it produces those results.According to the Study Guide for PY109 Exam, assessment answers should avoid being merely a "laundry list" of facts, and should explain the underlying concepts. Your answer effectively connects the individual lines to explain the overall behavior of the `isdigit()` method.

### 7. What do these print and why?

```python
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)
print(6 not in my_list)
```

#### Answer

This code outputs:

`True`
`True`

On line 1, a global variable `my_list` is initialized and references a list object with 5 elements: `1, 2, 3, 4, 5`

On line 2, we invoke the `print` function and pass in as an argument the return value of the expression `3 in my_list`, which returns `True`, as the element `3` is a member of the list object referenced by `my_list`. The returned value is output into the console.

On line 3, we invoke the `print` function and pass in as an argument the return value of the expression `6 not in my_list`, which returns `True`, as the element `6` is not a member of the list object referenced by `my_list`. The returned value is output into the console.

> [!NOTE]
> **Feedback**
> 
> Your answer is very well done! Here's my evaluation:
> 
> _Accuracy: 100/100_  
> Your explanation is completely accurate. You've correctly identified that `3 in my_list` checks for membership of the element `3` in the list and returns `True`, while `6 not in my_list` checks for non-membership of the element `6` and also returns `True`.
> 
> _Completeness: 95/100_  
> Your answer covers all the important aspects:
> •   How the list is initialized  
> •   What the `in` and `not in` operators do  
> •   Why each expression evaluates to `True`  
> •   How the results are passed to the `print` function and displayed
> 
> To make it even more complete, you could briefly mention that these are membership operators in Python, which are used to test whether a value or variable is found in a sequence (such as a list, string, or tuple).
> 
> _Precision: 95/100_  
> Your terminology is precise and appropriate. 
> You correctly describe:
> •   Variable initialization  
> •   List elements  
> •   Function invocation  
> •   Expression evaluation  
> •   The concept of membership
> 
> This is an excellent answer that demonstrates strong understanding of Python's membership operators. These operators are fundamental constructs in Python that allow you to check if a value exists within a collection, which is a common operation when working with lists, strings, and other sequence types.
> 
> For the PY109 assessment, this level of explanation would likely earn full marks. You've provided both a description of what the code does and explained why each expression evaluates to `True`, showing a clear understanding of the underlying concept.

### 8. What do these print and why?

```python
temperature = 25
time_of_day = "morning"

if temperature < 30 and (time_of_day == "morning" or time_of_day == "afternoon"):
    print("It's a pleasant day!")
else:
    print("It's either too hot or not the right time of day.")
```

#### Answer

The output of this code is `It's a pleasant day!`

On line 1, a global variable `temperature` is initialized and references an integer object with the value `25`

On line 2, a global variable `time_of_day` is initialized and references a string object with the value `morning`

On line 4, we have a conditional statement that checks for truthiness of the whole expression, which evaluates as `True`. The reason is the left operand evaluates to `True` as the value referenced by `temperature`, 25, is less than `30`. The right operand evaluates to `True` as well, as the expression `time_of_day == "morning" or time_of_day == "afternoon"` short-circuits, as the left operand `time_of_day == "morning"` evaluates to `True` and there is not need to evaluate the rest of the expression as we are using the `or` operator, which short-circuits if the left operand is `truthy`.

Within the `if` branch, we call the `print` function and pass in as an argument the string object with value `It's a pleasant day!`, which is then output into the console.

> [!NOTE]
> **Feedback**
> 
> Your answer demonstrates a good understanding of conditional expressions and logical operators in Python. Here's my evaluation:
> 
> _Accuracy: 95/100_  
> Your explanation is accurate. You correctly identify that the output is `It's a pleasant day!` and explain why the conditional expression evaluates to `True`. Your explanation of short-circuit evaluation for the `or` operator is also accurate.
> 
> _Completeness: 90/100_  
> Your answer covers most of the important elements:
> •   Variable initialization  
> •   Conditional statement evaluation  
> •   Short-circuit behavior of the `or` operator  
> •   The result of executing the conditional branch
> 
> To make your answer more complete, you could mention that this code demonstrates the use of logical operators (`and` and `or`) to combine multiple conditions, which is a common pattern in programming.
> 
> _Precision: 90/100_  
> Your terminology is precise when discussing short-circuit evaluation and the logical operators.One minor technical point: when you say "the left operand `time_of_day == "morning"` evaluates to `True` and there is not need to evaluate the rest of the expression as we are using the `or` operator, which short-circuits if the left operand is `truthy`," it would be more precise to say "which short-circuits if the left operand evaluates to `True`" rather than "if the left operand is `truthy`."
> 
> In the context of logical operators, it's important to distinguish between truthiness and the boolean value `True`, as noted in the [Truthiness assignment](https://launchschool.com/lessons/a29e9831/assignments/87263908). The distinction is subtle but important for the assessment.
> 
> Overall, this is a strong answer that demonstrates your understanding of logical operators, short-circuit evaluation, and conditional statements in Python. These concepts are fundamental for building control flow in programs.

### 9. What does this code print and why? What concept does this demonstrate?

```python
def number_range(number):
    match number:
        case n if n < 0:
            print(f'{number} is less than 0')
        case n if n <= 50:
            print(f'{number} is between 0 and 50')
        case n if 50 < n <= 100:
            print(f'{number} is between 51 and 100')
        case _:
            print(f'{number} is greater than 100')
number_range(0)
number_range(25)
```

#### Answer

This code outputs:

`0 is between 0 and 50`
`25 is between 0 and 50`

From lines 1-10 the function `number_range`is defined with a single parameter `number`.

On line 11, we invoke the function `number_range` with the integer `0` as an argument.

Within the function, on line 2, we have a `match` statement that evaluates the `number` parameter. 

On line 3, the `case` statement is evaluated with the `if` guard clause `n < 0`. As this evaluates as `False`, as `0` is not less than `0`, the branch is not executed.

On line 5, the `case` statement is evaluated. The expression `if n <= 50` evaluates as `True`, as `0` is less than or equal to `50`, then the branch is executed. On line 6, we invoke the `print` function and pass in as an argument a formatted-string or f-string, denoted by the prefix `f`, which coerces into a string using the built-in function `str` the value referenced by `number` and interpolates it into the string, resulting in the string object with value `0 is between 0 and 50`, which is then output into the console.

On line 12, we invoke the function `number_range` with the integer `25` as an argument.

Within the function, on line 2, we have a `match` statement that evaluates the `number` parameter. 

On line 3, the `case` statement is evaluated with the `if` guard clause `n < 0`. As this evaluates as `False`, as `25` is not less than `0`, the branch is not executed.

On line 5, the `case` statement is evaluated. The expression `if n <= 50` evaluates as `True`, as `25` is less than or equal to `50`, then the branch is executed. On line 6, we invoke the `print` function and pass in as an argument a formatted-string or f-string, denoted by the prefix `f`, which coerces into a string using the built-in function `str` the value referenced by `number` and interpolates it into the string, resulting in the string object with value `25 is between 0 and 50`, which is then output into the console.

The concept demonstrated here are conditionals using the match/case statement.

> [!NOTE]
> **Feedback**
> 
> Your answer demonstrates a good understanding of the `match-case` statement in Python. Here's my evaluation:
> 
> **Accuracy: 95/100**  
> Your explanation is accurate. You correctly identify:
> •   The output of the code  
> •   How each line functions  
> •   How the `match-case` statement evaluates each case  
> •   Why certain branches are executed or skipped
> 
> **Completeness: 90/100**  
> Your answer covers most essential elements:
> •   The function definition and parameter  
> •   The execution flow for both function calls  
> •   The evaluation of each case statement  
> •   The string interpolation using f-strings
> 
> To make your answer more complete, you could:
> •   Note that the `match-case` statement was introduced in Python 3.10  
> •   Explain that the `match-case` statement with guard clauses is an alternative to traditional `if-elif-else` chains  
> •   Mention that the `case n if ...` syntax is binding the matched value to the variable `n` for use in the guard clause
> 
> **Precision: 85/100**  
> Your terminology is generally precise, but there are a few areas where precision could be improved:
> •   Rather than saying "coerces into a string using the built-in function `str`," it would be more precise to say "the f-string automatically converts the value to its string representation for interpolation"  
> •   When you mention "the concept demonstrated here are conditionals using the match/case statement," it would be more precise to specifically identify this as pattern matching with guard clauses, which is a more specific concept than simply "conditionals"
> 
> According to the [Match-Case exercise](https://launchschool.com/exercises/860f0401), this code demonstrates pattern matching with guard clauses, where the `match-case` statement evaluates each case in sequence until it finds one that matches, then executes only that block of code.
> 
> Overall, this is a strong answer that shows you understand how the `match-case` statement works in Python. The `match-case` statement is a powerful feature added in Python 3.10 that provides a more elegant way to implement complex conditional logic compared to traditional `if-elif-else` chains.

### 10. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
ele = my_list.pop()
print("Popped element:", ele)
print("List after popping:", my_list)
ele1 = my_list.pop(1)
print("Popped element at index 1:", ele1)
print("Modified list after popping at index 1:", my_list)
```

#### Answer

This code outputs:

`Popped element: 5`
`List after popping: [1, 2, 3, 4]`
`Popped element at index 1: 2`
`Modified list after popping at index 1: [1, 3, 4]`

On line 1, a global variable `my_list` is initialized and references a list object with 5 elements: `[1, 2, 3, 4, 5]`

On line 2, a global variable `ele` is initialized and references the returned value of invoking the `pop` method without argument on the value referenced by `my_list`. The `pop` method without argument, returns the last element of the list, which in this case is `5`.

On line 3, we invoke the `print`function and pass in two arguments. The string object `Popped element:` and the variable `ele`, outputting them to the console.

On line 4, we invoke the `print` function and pass in two arguments. The string object `List after popping:` and the variable `my_list`, outputting them to the console. As the object referenced by `my_list` was mutated, the current elements referenced by `my_list` are `[1, 2, 3, 4].

On line 5, a global variable `ele1` is initialized and references the return value of invoking the `pop` method with the integer `1` as an argument, which represents the element located at index `1`, which in this case is `2`.

On line 6, we invoke the `print` function and pass in two arguments. The string object with value `Popped element at index 1:` and the variable `ele1`, which references the value `2`, outputting them into the console.

On line 7, we invoke the `print` function and pass in two arguments. The string object with value `Modified list after popping at index 1:` and the variable `my_list`.  As the object referenced by `my_list` was mutated, the current elements referenced by `my_list` are `[1, 3, 4].

> [!NOTE]
> **Feedback**
> 
> Your answer is thorough and accurate! Here's my evaluation:
> 
> _Accuracy: 100/100_  
> You've correctly identified the output and explained what happens at each step of the code execution. Your explanation of the `pop()` method's behavior both with and without arguments is spot on.
> 
> _Completeness: 95/100_  
> Your line-by-line analysis is comprehensive and covers all key points:
> •   How the list is initialized  
> •   How the `pop()` method works (both with and without arguments)  
> •   What values are returned and assigned to variables  
> •   How the list is mutated after each operation  
> •   The complete output sequence
> 
> To make your answer even more complete, you could briefly mention that this code demonstrates list mutability - an important concept in Python where certain operations modify the original list object rather than creating a new one.
> 
> _Precision: 95/100_  
> Your terminology is precise and appropriate. You correctly describe:
> •   Variable initialization  
> •   Method invocation  
> •   Return value assignment  
> •   List mutation
> 
> One small improvement would be to explicitly state that the `pop()` method not only returns the specified element but also removes it from the list, demonstrating the mutability of lists in Python.
> 
> Overall, this is an excellent answer that shows a clear understanding of list operations in Python. The concepts demonstrated in this code (list mutability and the `pop()` method) are fundamental to understanding how to work with collections in Python.Based on the material from the [Pass by Reference vs Pass by Value assignment](https://launchschool.com/lessons/a29e9831/assignments/248a3cc6), this example also illustrates how operations that mutate a collection affect the original object rather than creating a new one.