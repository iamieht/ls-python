# List of Practice Problems #1

## Type coercions: explicit (e.g., using int(), str()) and implicit)

### 1: Which variable is coerced? Is it implicit or explicit coercion?

```python
x = 3.5
y = 5
z = x + y
```

**Answer:**
Variable `y` is implicitly coerced into a `float`, so the return value of adding `x + y` is `8.5`. The Python interpreter does an implicit coercion as we haven't intentionally changed any data type by using any built-in Python function, like `float()`.

> [!NOTE]
> @LSBot feedback:
> 
> **Accuracy: 100/100**
> Your answer correctly identifies that variable `y` (the integer) is the one being implicitly coerced to a float in the expression `x + y`. This is exactly what happens when Python performs arithmetic operations between integers and floats.
> 
> **Completeness: 100/100**  
> Your answer covers all key aspects:•   You identified which variable is coerced (y)  
> •   You specified that it's implicit coercion  
> •   You provided the correct result (8.5)  
> •   You explained why it's implicit (no explicit type conversion function was used)
> 
> **Precision: 100/100**  
> Your explanation is precise and uses the correct terminology. You've accurately described how Python handles mixed-type arithmetic operations.


### 2: What coercion is happening here? Is it implicit or explicit?

```python
a = 1
b = 2
print(a + b)
```

**Answer:**

There is no coercion happening here, as both variables `a` and `b` are of type `int`. The resulting value of the addition is `3`, which is also of type `int`. The `print()` function converts the value into a `string` by invoking behind the scenes the `str()` function, reason why this is not considered coercion.

@LSBot Feedback:

> [!NOTE]
> **Accuracy: 100/100**  
> Your answer correctly identifies that no coercion happens in the addition operation itself. Both `a` and `b` are integers, so the addition produces an integer result without any type conversion.
> 
> **Completeness: 100/100**  
> Your answer covers all the important points:
> •   You correctly stated there's no coercion in the actual operation  
> •   You identified that `a` and `b` are both integers  
> •   You specified the correct result of the addition (3)  
> •   You explained the behavior of the `print()` function accurately
> 
> **Precision: 100/100**  
> Your explanation is precise and uses the correct terminology. You've accurately described why the `print()` function's behavior isn't considered coercion, even though it does convert values to strings behind the scenes.

### 3: What coercion is happening here? Is it implicit or explicit?

```python
month = "December"
day = int(input("What day is it? "))
print(f"Today is the {day} of {month}")
```

**Answer:**

Both explicit and implicit coercions are happening here.

On line 2, we initialize a global variable `day` to the return value of invoking the `input` function with a string object with value `What day is it?` as an argument, which is then explicitly coerced into an integer value by invoking the `int()` constructor.

On line 3, the value referenced by variables `day` and `month` are interpolated into a string, as an f-string is involved, which are implicitly coerced into `str` and then output by the `print()` function, printing the string `Today is the {day} of {month}`.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 90/100** 
> You correctly identified that both explicit and implicit coercions are happening. The explicit coercion using `int()` is accurately described. The implicit coercion in the f-string is correct, but there's a slight misstatement about what gets printed.
> 
> **Completeness: 95/100**  
> Your answer covers the key points about both types of coercion that occur. You've explained the explicit coercion with `int()` and the implicit coercion in the f-string.
> 
> **Precision: 85/100**  
> There's a minor issue with the precision of your last statement. 
> The f-string doesn't output "Today is the {day} of {month}" literally - it outputs the string with the values substituted._
> 
> **Corrected answer:**
> Both explicit and implicit coercions are happening here.
> On line 2, we initialize a variable `day` to the return value of invoking the `input` function with a string argument "What day is it?". Since `input()` always returns a string, we then explicitly coerce this string value into an integer by using the `int()` constructor.
> On line 3, when using an f-string, Python automatically performs implicit string coercion on the values inside the curly braces. The integer value of `day` is implicitly coerced to a string when interpolated in the f-string. The variable `month` is already a string, so no coercion is needed for it. The f-string produces a string with the interpolated values, which is then passed to the `print()` function.

## Numbers, including handling exceptions (ValueError, ZeroDivisionError)

### Basic questions:

- Are integers and floats mutable or immutable?
A: They are immutable
- Are integers and floats primitive or non-primitive? 
A: They are primitive
- Are integers and floats literals?
A: Yes
- What is a literal?
A: It's any syntactic notation that lets you represent an object in source code

### 1: What does this return and why? What concept does this cover?

```python
def convert_to_int(string):
    try:
        converted_integer = int(string)
        return converted_integer
    except ValueError:
        return "That string cannot be converted to an integer"

print(convert_to_int("hello"))

print(convert_to_int("5"))
```

**Answer**:

On line 8, the string object with value `That string cannot be converted to an integer` is output. 

On line 8, we invoke the function `convert_to_int` with the string value `hello` as an argument. Within the function, we have a `try` `except` construction that tries to coerce the value `hello` to a integer by invoking the `int()` constructor and passing the string value as an argument. This explicit coercion raises a `ValueError` exception that is caught and returns the value `That string cannot be converted to an integer`, as attempting to convert a non-numeric string to an integer using `int()` will raise a `ValueError`.

On line 10, the value `5` is output.

On line 10, we invoke the function `convert_to_int` with the string value `5` as an argument. On line 3, within the function, we explicitly coerce the string object with value `3` to an integer by using the `int()` constructor. This coercion is successful and the return value of the function is the integer `5`, which is then passed in as an argument to the `print()` function, outputting it to the console.

The concepts covered here are Type Coercion and Exception Handling.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**  
> Your explanation of the function's behavior is almost entirely correct. The only error is on line 10's explanation, where you wrote "we explicitly coerce the string object with value `3` to an integer" but the string value is actually `5`, not `3`.
> 
> **Completeness: 100/100**  
> Your answer covers all important aspects:
> •   You correctly explained both function calls and their respective outputs  
> •   You identified that the first call results in an exception that's caught  
> •   You properly explained how the try/except block works  
> •   You correctly identified both key concepts being demonstrated
> 
> **Precision: 95/100**  
> Your language is precise and technically correct, with the one small error noted above about the string value.
> 
> **Corrected explanation for line 10**  
> On line 10, we invoke the function `convert_to_int` with the string value `5` as an argument. On line 3, within the function, we explicitly coerce the string object with value `5` to an integer by using the `int()` constructor. This coercion is successful, and the return value of the function is the integer `5`, which is then passed in as an argument to the `print()` function, outputting it to the console.

### 2: What does this return and why? What concept does this cover?

```python
def division(number1, number2):
    numerator = number1
    denominator = number2

    try:
        result = numerator / denominator
        return result
    except ZeroDivisionError:
        return "The denominator cannot be zero"

print(division(5, 0))
```

**Answer**:

This code returns the string `The denominator cannot be zero`.

The reason is that we are passing the integer values `5` and `0` as arguments to the `division` function invocation. Within the function, the value `5` is assigned to the `numerator` variable and the value `0` is assigned to the  `denominator` variable. On line 6, when trying to divide `5` and `0` a `ZeroDivisionError` exception is raised and caught by `try/except` construction, returning the string object with value `The denominator cannot be zero`.

This string object is then passed in as an argument to the `print()` function, outputting it to the console.

The concept covered here in Exception Handling

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation accurately describes what happens in the code. You correctly identified that a `ZeroDivisionError` is raised when trying to divide by zero, and that this exception is caught by the except block.
> 
> **Completeness: 100/100**  
> 
> Your answer covers all the key points:
> •   You identified the correct return value  
> •   You explained the function parameter assignment correctly  
> •   You described the exception that occurs and how it's handled  
> •   You explained the final output process
> 
> **Precision: 100/100**
> 
> Your explanation is precise and uses the correct terminology. You've accurately described the exception handling process and the function's behavior.
> 
> The concept this code covers is ​**Exception Handling**​, specifically handling the `ZeroDivisionError` exception. This is a fundamental concept in Python that allows programs to gracefully manage errors that might occur during execution instead of crashing. As explained in the [PY101 - Errors](https://launchschool.com/lessons/a29e9831/assignments/378f8121) assignment, a `ZeroDivisionError` occurs when attempting to divide by zero, and Python provides a structured way to handle such exceptions using the `try`, `except`, `else`, and `finally` statements.
> 
> Your answer demonstrates a clear understanding of how exception handling works in Python - the program attempts an operation that might fail (division), and if it does fail in the expected way (division by zero), it provides an alternative response rather than crashing.

### 3: What does this print and why, what concept does this demonstrate?

```python
def addition(number1, number2):
    number1 += number2

x = 1
y = 2

addition(x, y)
print(f"x is {x}, y is {y}")
```

**Answer**:

This code prints `x is 1, y is 2`.

The reason is that on line 8, we invoke the `print()` function with a f-string as an argument and the values interpolated into the string, are those referred by the global variable `x`, which is the integer `1` and the global variable `y`, which is the integer `2`.

As there is no explicit return statement in the function `addition`, `None` is implicitly returned and it has no effect on the global variables `x` or `y`.

The concept demonstrated is **String Interpolation** and **Variable Scope** 

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 90/100**
> 
> Your final answer is correct - the code prints `x is 1, y is 2`. However, your explanation doesn't fully address why the values of `x` and `y` remain unchanged despite the function attempting to modify `number1`.
> 
> **Completeness: 85/100**
> 
> Your answer covers string interpolation and variable scope, which are relevant, but the primary concept being demonstrated is Python's handling of immutable objects, which you haven't mentioned.
> 
> **Precision: 80/100**
> 
> While technically correct about what happens, the explanation doesn't precisely describe why the function doesn't modify the value of `x`.
> 
> Improved explanation:
> 
> This code prints `x is 1, y is 2`.
> 
> The key concept being demonstrated is ​**immutability of integers**​ in Python. When `addition(x, y)` is called, the values of `x` and `y` (which are 1 and 2) are passed to the function's parameters `number1` and `number2`. Inside the function, `number1 += number2` attempts to modify `number1`. However, integers in Python are immutable, which means their values cannot be changed.
> 
> What actually happens is that `number1 += number2` creates a new integer object (with value 3) and assigns it to the local variable `number1`. This operation has no effect on the original variable `x` in the global scope.
> 
> When the function ends, there's indeed no explicit return value, so `None` is implicitly returned. The global variables `x` and `y` retain their original values of 1 and 2, which are then displayed in the f-string.
> 
> This example demonstrates the concepts of ​**variable scope**​ and ​**object immutability**​ in Python.

### 4. What does this print and why? What concept does this cover? How would you refactor this to remove the space?

```python
print(2 + 3 * 4, 4 * (3 + 2))
```

### 5. What can be used in place of commas to make this more readable?

```python
print(123112940)
```

## Strings

### Basic questions:

- Are strings mutable or immutable?
- Are strings primitive or non-primitive?
- Are strings literals? 
- What is a text sequence?
- What kind of characters are used in a string?
- Are text sequences the same as ordinary sequences?

### 1. What is the output of this code, and why? What is the concept covered here?

```python
str1 = "Hello, world!"
sub1 = str1[8:12]
print(sub1)
sub2 = str1[::-1]
print(sub2)
sub3 = str1[::2]
print(sub3)
```

### 2. What does this print and why? What concept is this?

```python
print("Hello\nWorld")
```

### 3. What does this print and why? What concept is this?

```python
name = 'Alexander Graham Bell'
print(name[0])
```

## f-strings

### Basic Questions:

- What are f-strings?

### 1. What does this print and why, what is the concept?

```python
name = 'Abraham Lincoln'
print(f"{name} was a President of the US")
```

## string methods

### Basic Questions:

- How do you identify a method versus a function?

### 1. What does this print and why?

```python
mashup = "thIs is How we type careLEssly"
cleaned = mashup.capitalize()
print(cleaned)
```

### 2. What do these print and why?

```python
stuff = 'tHIS iS bACKWARDS'
str1 = stuff.swapcase()
str2 = stuff.upper()
str3 = stuff.lower()
print(stuff)
print(str1)
print(str2)
print(str3)
```

### 3. What do these print and why?

```python
s1 = "Hello"
print(s1.isalpha())
s2 = "Hello World"
print(s2.isalpha())
s3 = "Hello!"
print(s3.isalpha())
s4 = "Hello123"
print(s4.isalpha())
s5 = ""
print(s5.isalpha())
s6 = "こんにちは"
print(s6.isalpha())
s7 = "HelloWorld"
print(s7.isalpha())
words = ["apple", "banana", "cherry"]
print(all(word.isalpha() for word in words))
```

### 4. What does this print and why?

```python
string1 = "HelloWorld"
string2 = "12345"
string3 = "Hello World"

result1 = string1.isalpha()
result2 = string2.isalpha()
result3 = string3.isalpha()

print("Is '{}' alphabetic?".format(string1), result1)
print("Is '{}' alphabetic?".format(string2), result2)
print("Is '{}' alphabetic?".format(string3), result3)
```

### 5. What do these print and why?

```python
s1 = "123abc"
print(s1.isdigit())
s2 = "123$%^"
print(s2.isdigit())
s3 = ""
print(s3.isdigit())
s4 = "12345"
print(s4.isdigit())
```

### 6. What do these print and why?

```python
print("Hello World".isalnum())
print("Hello@World".isalnum())
print("".isalnum())
print("Hello123".isalnum())
```

### 7. What do these print and why?

```python
name = 'HELLO'

if name.isupper():
    print("WORLD")
else:
    print("world")
    ```

###  8. What do these print and why?
```python
def punctuation_type(str):
    if str == str.upper():
        print('This is all caps')
    elif str == str.lower():
        print('This is all lowercase')
    else:
        print('Neither')

str1 = 'HELLO'
str2 = 'yolo'
str3 = 'My Name Is: '

punctuation_type(str1)
punctuation_type(str2)
punctuation_type(str3)
```

### 9. What do these print and why?

```python
str1 = "    "
str2 = "  Hello   "
str3 = "Hello World"

print(str1.isspace())
print(str2.isspace())
print(str3.isspace())

sentence = "Hello     World!   How are you?   "
word_count = sum(1 for word in sentence.split() if not word.isspace())
print("Number of words in the sentence:", word_count)
```

### 10. What do these print and why?

```python
s = "   Hello, World!   "
print(s.strip())
print(s.strip(" !"))
```

### 11. What do these print and why?

```python
s = "www.example.com"
print(s.lstrip('wcmo.'))
```

### 12. What do these print and why?

```python
s = 'impatient'
print(s.rstrip('tp'))
print(s.rstrip('p'))
```

### 13. What do these print and why?

```python
s = "Hello, World!"
print(s.replace("Hello", "Hi"))
print(s.replace("o", "0"))
```

### 14. What do these print and why?

```python
sentence = "This is a sample sentence."
words = sentence.split()
print(words)

csv_data = "John,Doe,30,New York"
fields = csv_data.split(",")
print(fields)

sentence = "This is a sample sentence."
words = sentence.split(maxsplit=2)
print(words)
```

### 15. What does this print and why?

```python
str1 = "hello world"
str2 = str1.capitalize()
print("Original string:", str1)
print("Capitalized string:", str2)
```

## boolean vs. truthiness

### Basic Question:

- In Python, what values are considered Falsy and what are considered Truthy?

### 1. What do these print and why?

```python
truthy_values = [1, 2, 3, "hello", [1, 2, 3], {"a": 1}, True, 0, "", [], {}, None, False]

print(“Values:”)
for value in truthy_values:
    if value:
        print(f"{value} is truthy")
    else:
        print(f"{value} is falsy")
```

### 2. What do these print and why?

```python
x = 5
y = 10
z = 15

print(x > 0 and y < 20)
print(not x == y)
print(x < y and y < z)
print(x > y or y > z)
print(not (x > y))
```

### 3. What do these print and why?

```python
a = 10
b = 20

print(a < b < 30)
print(a > b or b == 20)
```

### 4. What do these print and why?

```python
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)
print(6 not in my_list)
```

### 5. What do these print and why?

```python
temperature = 25
time_of_day = "morning"

if temperature < 30 and (time_of_day == "morning" or time_of_day == "afternoon"):
    print("It's a pleasant day!")
else:
    print("It's either too hot or not the right time of day.")
```

### 6. What does this print and why?

```python
num = 12

if num / 3 < 3 and num > 10:
    print("Hello")
elif num >= 8 and num < 6 or num > 4 and num < 16:
    print("Hello 2")
elif num % 4 == 0 or num < 7 and num < 10:
    print("Hello 3")
else:
    print("Buy")
```

## ranges

### Basic questions:

- Is a range primitive or non-primitive?
- Is a range mutable or immutable?
- Does range have a literal form or a type constructor?
- Is a range a sequence or a collection?
- What is the most common use of the range datatype?
- Are ranges homogenous or heterogeneous?
- Why are ranges considered lazy?

### 1. What do these print and why? What concept does this demonstrate?

```python
print(range(0,10))
print(len(range(5, 15)))
print(my_range[1])
print(str(range(3, 7)))
print(list(range(12, 8, -1)))
print(list(range(5, 5, 1)))
print(5 in range(5))
print(5 not in range(5, 10))
```

### 2. What does this code print and why? What concept does this demonstrate?

```python
example = range(0)
if example:
    print(list(example))
else:
    print(example)
```

### 3. What does this code print and why? What concept does this demonstrate?

```python
def number_range(number):
    match number:
        case n if n < 0:
            print(f'{number} is less than 0')
        case n if n <= 50:
            print(f'{number} is between 0 and 50')
        case n if 50 < n <= 100:
            print(f'{number} is between 51 and 100')
        case _:
            print(f'{number} is greater than 100')
number_range(0)
number_range(25)
```

## list and dictionary syntax

### Basic Questions

- What categories are lists and dictionaries?
- Are they mutable or immutable?
- Are they primitive or non-primitve?
- Are they literals, or do they require type constructors?
- Are they sequences?
- Does the order of the elements in both matter?


## List methods: len(list), list.append(), list.pop(), list.reverse()

### 1. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
length_of_list = len(my_list)
print("Length of the list:", length_of_list)
```

### 2. What does this print and why?

```python
lst_one = [0, 1, 2, 3]
lst_two = lst_one.append(4)
if lst_two:
    print(lst_two)
else:
    print(lst_one)
```

### 3. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
ele = my_list.pop()
print("Popped element:", ele)
print("List after popping:", my_list)
ele1 = my_list.pop(1)
print("Popped element at index 1:", ele1)
print("Modified list after popping at index 1:", my_list)
```

### 4. What does this print and why?

```python
elements = [0, 1 , 2, "Dima"]
print(elements.reverse())
print(elements)
```

### 5. What does this print and why?

```python
ages = {
    "dimo": 31,
    "olena": 32,
    "tetiana": 28
}

def get_val_of_dimo(info):
    try:
        info['dimo']
        return info['dimo']
    except KeyError:
        return "Typo"

print(get_val_of_dimo(ages))
```

### 6. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
keys = my_dict.keys()
print(keys)
for key in keys:
    print(key)
```

### 7. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
values = my_dict.values()
print(values)
for value in values:
    print(value)
```

### 8. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
items = my_dict.items()
print(items)
for key, value in items:
    print(key, value)
```

## variable scope, global keyword, variables as pointers, variable shadowing

### 1. What does this print and why?

```python
name = 'John'

def greet():
    print(f"Hello, {name}!")

greet()
```

### 2. What does this print and why?

```python
def assign():
    var = 20
    print(var)

assign()
```

### 3. What does this print and why?

```python
try:
    print(var)
except NameError as e:
    print("Error occurred")
```

### 4. What does this print and why?

```python
var = 10

def function1():
    var = 20
    print(var)

function1()

try:
    print(var)
except NameError:
    print("Error occurred")

def function2():
    var += 5
    print(var)

try:
    function2()
except UnboundLocalError:
    print("Error occurred")

def function3():
    global var
    var += 5
    print(var)

function3()
print(var)
```

### 5. What does this print and why?

```python
var = 10

def function1():
    print(var)

function1()

def function2():
    var = 20
    print(var)

function2()
print(var)
```

### 6. What does this print and why?

```python
def function1():
    x = 10

    def function2():
        y = 20
        print(x)

    function2()
    print(x)

function1()
print(x)
print(y)
```

### 7. What does this print and why?

```python
var = 10

def access():
    print(var)
```