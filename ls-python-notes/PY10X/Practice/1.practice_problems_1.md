# List of Practice Problems #1

## Type coercions: explicit (e.g., using int(), str()) and implicit)

### 1: Which variable is coerced? Is it implicit or explicit coercion?

```python
x = 3.5
y = 5
z = x + y
```

**Answer:**
Variable `y` is implicitly coerced into a `float`, so the return value of adding `x + y` is `8.5`. The Python interpreter does an implicit coercion as we haven't intentionally changed any data type by using any built-in Python function, like `float()`.

> [!NOTE]
> @LSBot feedback:
> 
> **Accuracy: 100/100**
> Your answer correctly identifies that variable `y` (the integer) is the one being implicitly coerced to a float in the expression `x + y`. This is exactly what happens when Python performs arithmetic operations between integers and floats.
> 
> **Completeness: 100/100**  
> Your answer covers all key aspects:•   You identified which variable is coerced (y)  
> •   You specified that it's implicit coercion  
> •   You provided the correct result (8.5)  
> •   You explained why it's implicit (no explicit type conversion function was used)
> 
> **Precision: 100/100**  
> Your explanation is precise and uses the correct terminology. You've accurately described how Python handles mixed-type arithmetic operations.


### 2: What coercion is happening here? Is it implicit or explicit?

```python
a = 1
b = 2
print(a + b)
```

**Answer:**

There is no coercion happening here, as both variables `a` and `b` are of type `int`. The resulting value of the addition is `3`, which is also of type `int`. The `print()` function converts the value into a `string` by invoking behind the scenes the `str()` function, reason why this is not considered coercion.

@LSBot Feedback:

> [!NOTE]
> **Accuracy: 100/100**  
> Your answer correctly identifies that no coercion happens in the addition operation itself. Both `a` and `b` are integers, so the addition produces an integer result without any type conversion.
> 
> **Completeness: 100/100**  
> Your answer covers all the important points:
> •   You correctly stated there's no coercion in the actual operation  
> •   You identified that `a` and `b` are both integers  
> •   You specified the correct result of the addition (3)  
> •   You explained the behavior of the `print()` function accurately
> 
> **Precision: 100/100**  
> Your explanation is precise and uses the correct terminology. You've accurately described why the `print()` function's behavior isn't considered coercion, even though it does convert values to strings behind the scenes.

### 3: What coercion is happening here? Is it implicit or explicit?

```python
month = "December"
day = int(input("What day is it? "))
print(f"Today is the {day} of {month}")
```

**Answer:**

Both explicit and implicit coercions are happening here.

On line 2, we initialize a global variable `day` to the return value of invoking the `input` function with a string object with value `What day is it?` as an argument, which is then explicitly coerced into an integer value by invoking the `int()` constructor.

On line 3, the value referenced by variables `day` and `month` are interpolated into a string, as an f-string is involved, which are implicitly coerced into `str` and then output by the `print()` function, printing the string `Today is the {day} of {month}`.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 90/100** 
> You correctly identified that both explicit and implicit coercions are happening. The explicit coercion using `int()` is accurately described. The implicit coercion in the f-string is correct, but there's a slight misstatement about what gets printed.
> 
> **Completeness: 95/100**  
> Your answer covers the key points about both types of coercion that occur. You've explained the explicit coercion with `int()` and the implicit coercion in the f-string.
> 
> **Precision: 85/100**  
> There's a minor issue with the precision of your last statement. 
> The f-string doesn't output "Today is the {day} of {month}" literally - it outputs the string with the values substituted._
> 
> **Corrected answer:**
> Both explicit and implicit coercions are happening here.
> On line 2, we initialize a variable `day` to the return value of invoking the `input` function with a string argument "What day is it?". Since `input()` always returns a string, we then explicitly coerce this string value into an integer by using the `int()` constructor.
> On line 3, when using an f-string, Python automatically performs implicit string coercion on the values inside the curly braces. The integer value of `day` is implicitly coerced to a string when interpolated in the f-string. The variable `month` is already a string, so no coercion is needed for it. The f-string produces a string with the interpolated values, which is then passed to the `print()` function.

## Numbers, including handling exceptions (ValueError, ZeroDivisionError)

### Basic questions:

- Are integers and floats mutable or immutable?
A: They are immutable
- Are integers and floats primitive or non-primitive? 
A: They are primitive
- Are integers and floats literals?
A: Yes
- What is a literal?
A: It's any syntactic notation that lets you represent an object in source code

### 1: What does this return and why? What concept does this cover?

```python
def convert_to_int(string):
    try:
        converted_integer = int(string)
        return converted_integer
    except ValueError:
        return "That string cannot be converted to an integer"

print(convert_to_int("hello"))

print(convert_to_int("5"))
```

**Answer**:

On line 8, the string object with value `That string cannot be converted to an integer` is output. 

On line 8, we invoke the function `convert_to_int` with the string value `hello` as an argument. Within the function, we have a `try` `except` construction that tries to coerce the value `hello` to a integer by invoking the `int()` constructor and passing the string value as an argument. This explicit coercion raises a `ValueError` exception that is caught and returns the value `That string cannot be converted to an integer`, as attempting to convert a non-numeric string to an integer using `int()` will raise a `ValueError`.

On line 10, the value `5` is output.

On line 10, we invoke the function `convert_to_int` with the string value `5` as an argument. On line 3, within the function, we explicitly coerce the string object with value `3` to an integer by using the `int()` constructor. This coercion is successful and the return value of the function is the integer `5`, which is then passed in as an argument to the `print()` function, outputting it to the console.

The concepts covered here are Type Coercion and Exception Handling.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**  
> Your explanation of the function's behavior is almost entirely correct. The only error is on line 10's explanation, where you wrote "we explicitly coerce the string object with value `3` to an integer" but the string value is actually `5`, not `3`.
> 
> **Completeness: 100/100**  
> Your answer covers all important aspects:
> •   You correctly explained both function calls and their respective outputs  
> •   You identified that the first call results in an exception that's caught  
> •   You properly explained how the try/except block works  
> •   You correctly identified both key concepts being demonstrated
> 
> **Precision: 95/100**  
> Your language is precise and technically correct, with the one small error noted above about the string value.
> 
> **Corrected explanation for line 10**  
> On line 10, we invoke the function `convert_to_int` with the string value `5` as an argument. On line 3, within the function, we explicitly coerce the string object with value `5` to an integer by using the `int()` constructor. This coercion is successful, and the return value of the function is the integer `5`, which is then passed in as an argument to the `print()` function, outputting it to the console.

### 2: What does this return and why? What concept does this cover?

```python
def division(number1, number2):
    numerator = number1
    denominator = number2

    try:
        result = numerator / denominator
        return result
    except ZeroDivisionError:
        return "The denominator cannot be zero"

print(division(5, 0))
```

**Answer**:

This code returns the string `The denominator cannot be zero`.

The reason is that we are passing the integer values `5` and `0` as arguments to the `division` function invocation. Within the function, the value `5` is assigned to the `numerator` variable and the value `0` is assigned to the  `denominator` variable. On line 6, when trying to divide `5` and `0` a `ZeroDivisionError` exception is raised and caught by `try/except` construction, returning the string object with value `The denominator cannot be zero`.

This string object is then passed in as an argument to the `print()` function, outputting it to the console.

The concept covered here in Exception Handling

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation accurately describes what happens in the code. You correctly identified that a `ZeroDivisionError` is raised when trying to divide by zero, and that this exception is caught by the except block.
> 
> **Completeness: 100/100**  
> 
> Your answer covers all the key points:
> •   You identified the correct return value  
> •   You explained the function parameter assignment correctly  
> •   You described the exception that occurs and how it's handled  
> •   You explained the final output process
> 
> **Precision: 100/100**
> 
> Your explanation is precise and uses the correct terminology. You've accurately described the exception handling process and the function's behavior.
> 
> The concept this code covers is ​**Exception Handling**​, specifically handling the `ZeroDivisionError` exception. This is a fundamental concept in Python that allows programs to gracefully manage errors that might occur during execution instead of crashing. As explained in the [PY101 - Errors](https://launchschool.com/lessons/a29e9831/assignments/378f8121) assignment, a `ZeroDivisionError` occurs when attempting to divide by zero, and Python provides a structured way to handle such exceptions using the `try`, `except`, `else`, and `finally` statements.
> 
> Your answer demonstrates a clear understanding of how exception handling works in Python - the program attempts an operation that might fail (division), and if it does fail in the expected way (division by zero), it provides an alternative response rather than crashing.

### 3: What does this print and why, what concept does this demonstrate?

```python
def addition(number1, number2):
    number1 += number2

x = 1
y = 2

addition(x, y)
print(f"x is {x}, y is {y}")
```

**Answer**:

This code prints `x is 1, y is 2`.

The reason is that on line 8, we invoke the `print()` function with a f-string as an argument and the values interpolated into the string, are those referred by the global variable `x`, which is the integer `1` and the global variable `y`, which is the integer `2`.

As there is no explicit return statement in the function `addition`, `None` is implicitly returned and it has no effect on the global variables `x` or `y`.

The concept demonstrated is **String Interpolation** and **Variable Scope** 

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 90/100**
> 
> Your final answer is correct - the code prints `x is 1, y is 2`. However, your explanation doesn't fully address why the values of `x` and `y` remain unchanged despite the function attempting to modify `number1`.
> 
> **Completeness: 85/100**
> 
> Your answer covers string interpolation and variable scope, which are relevant, but the primary concept being demonstrated is Python's handling of immutable objects, which you haven't mentioned.
> 
> **Precision: 80/100**
> 
> While technically correct about what happens, the explanation doesn't precisely describe why the function doesn't modify the value of `x`.
> 
> Improved explanation:
> 
> This code prints `x is 1, y is 2`.
> 
> The key concept being demonstrated is ​**immutability of integers**​ in Python. When `addition(x, y)` is called, the values of `x` and `y` (which are 1 and 2) are passed to the function's parameters `number1` and `number2`. Inside the function, `number1 += number2` attempts to modify `number1`. However, integers in Python are immutable, which means their values cannot be changed.
> 
> What actually happens is that `number1 += number2` creates a new integer object (with value 3) and assigns it to the local variable `number1`. This operation has no effect on the original variable `x` in the global scope.
> 
> When the function ends, there's indeed no explicit return value, so `None` is implicitly returned. The global variables `x` and `y` retain their original values of 1 and 2, which are then displayed in the f-string.
> 
> This example demonstrates the concepts of ​**variable scope**​ and ​**object immutability**​ in Python.

### 4. What does this print and why? What concept does this cover? How would you refactor this to remove the space?

```python
print(2 + 3 * 4, 4 * (3 + 2))
```

**Answer**:

This code prints `14 20`. 

The `print()` function takes two arguments. The first one is the expression `2 + 3 * 4`, which evaluates to `14`, as the multiplication operator has precedence over addition. The second one is the expression `4 * (3 + 2)`, in which the addition operation inside the parenthesis has precedence over the multiplication operation. 

The concept demonstrated here is operator precedence.

**Code Refactor**

```python
print(2 + 3 * 4)
print(4 * (3 + 2))
```

> [!NOTE]
> @LSBot feedback
> 
> **Accuracy: 100/100**
> 
> Your explanation of what the code prints and why is completely accurate. You correctly identified that the code prints `14 20` and explained the operator precedence rules that lead to these values.
> 
> **Completeness: 100/100**
> 
> Your answer covers all important aspects:
> •   You identified the correct output  
> •   You explained how operator precedence affects each expression  
> •   You recognized that the `print()` function is taking two arguments  
> •   You correctly identified operator precedence as the key concept
> 
> **Precision: 90/100**
> 
> Your explanation is precise, but your refactoring suggestion doesn't address the question about removing the space between the values.
> 
> **Improved refactoring suggestion:**
> 
> To remove the space that appears between the two values in the output, you can use the `sep` parameter of the `print()` function:
> 
> ```python
> print(2 + 3 * 4, 4 * (3 + 2), sep='')  
> ``` 
> 
> 
> This would print `1420` without the space between the values. The `sep` parameter specifies what character to use between multiple arguments (the default is a space).
> 
> Alternatively, you could concatenate the values as strings:
> 
> ```python
> print(str(2 + 3 * 4) + str(4 * (3 + 2)))  
> ```  
> 
> The concept of operator precedence is fundamental in Python and programming in general. As explained in the [Precedence assignment](https://launchschool.com/lessons/a29e9831/assignments/aa637b5b), "In an expression, operators with higher precedence are prioritized over those with lower precedence." This is why `*` is evaluated before `+` in the first expression, and why the parentheses are needed in the second expression to change the order of operations.

### 5. What can be used in place of commas to make this more readable?

```python
print(123112940)
```

**Answer**:

We can use `_` underscores to make it more readable.

```python
print(123_112_940)
```

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> You've correctly identified that underscores can be used to make large integers more readable in Python.
> 
> **Completeness: 100/100**
>   
> Your answer provides both the solution and a correct code example showing how to implement it.
> 
> **Precision: 100/100**
> 
> Your syntax is correct - underscores can be placed between digits to improve readability without changing the value of the number.
> 
> This is indeed the correct approach for making large integers more readable in Python. As shown in the "Large Integers" exercise documentation, "You can write large integers by using underscores to separate groups of digits" [https://launchschool.com/exercises/fe9fa066](https://launchschool.com/exercises/fe9fa066).
> 
> The Python documentation classifies this under "Integer literals" where you can place underscores between digits to improve readability. For example:
> 
> ```python
> # These all represent the same number  
> 123112940  
> 123_112_940  
> 1_2_3_1_1_2_9_4_0  # While valid, this isn't conventional  
> ```  
> 
> The placement of underscores is flexible, though conventionally they're used like commas would be in written numbers (every three digits from the right) or to group digits in a meaningful way (like separating bytes in hexadecimal notation).
> 
> This feature was introduced in Python 3.6 and is particularly useful when working with large numbers in scientific computing, financial applications, or when representing values like phone numbers, social security numbers, etc.

## Strings

### Basic questions:

- Are strings mutable or immutable?
A: Immutable
- Are strings primitive or non-primitive?
A: Primitive
- Are strings literals? 
A: Yes
- What is a text sequence?
A: is a string object that represents an ordered collection of Unicode characters.
- What kind of characters are used in a string?
A: Unicode characters
- Are text sequences the same as ordinary sequences?
A: No. Text sequence contain only string characters. ordinary sequences refer to any other sequence types that store multiple elements (objects) (e.g. lists, tuples, ranges))

### 1. What is the output of this code, and why? What is the concept covered here?

```python
str1 = "Hello, world!"
sub1 = str1[8:12]
print(sub1)
sub2 = str1[::-1]
print(sub2)
sub3 = str1[::2]
print(sub3)
```

**Answer**:

The output of this code is:
`orld`
`!dlrow ,olleH`
`Hlo ol!`

On line 1, we initialize a global variable `str1` and references a string object with value `Hello, world!.

On line 2, a global variable `sub1` is initialized to the return value of slicing the string object referenced by variable `str1` starting from index 8 up to but not including index 12. The returned string is `orld`.

On line 3, the value referenced by variable `sub1` is passed in as an argument to the `print()` function, outputting `orld` to the console.

On line 4, a global variable `sub2` is initialized and references the return value of slicing the string object referenced by variable `str1`, starting from index 0 until end of the string, with a step of `-1`, transversing the string in reverse mode. The returned string is `!dlrow ,olleH`.

On line 5, the value referenced by variable `sub2` is passed in as an argument to the `print()` function, outputting `!dlrow ,olleH` to the console.

On line 6, the global variable `sub3` is initialized and references the return value of slicing the string object referenced by variable `str1`, from index 0 until the end of the string, with a step of `2`, returning the string object with value ``Hlo ol!`.

On line 7, the value referenced by the variable `sub3` is passed in as an argument to the `print()` function, outputting `Hlo ol!` to the console.

The concept demonstrated here is string slicing.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 95/100**
> 
> Your answer is highly accurate. The predicted outputs are correct, and your explanation of each line is technically sound. The only minor improvement I would suggest is clarifying that on line 1, we're creating a string object with the value `"Hello, world!"` (you're missing the closing quote).
> 
> **Completeness: 98/100**
> 
> Your answer is very complete. You've methodically explained each line of code, what it does, and the resulting output. You've correctly identified the concept as string slicing and explained how each slicing operation works.
> 
> **Precision: 97/100**
> 
> Your language is precise and demonstrates a deep understanding of Python's mechanics. You correctly use terms like "references," "return value," "initialize," and "global variable." You also accurately describe the slice notation, including start, end, and step parameters.
> 
> For your PY109 assessment, this level of precision and detailed explanation is exactly what's expected. You've gone beyond simply stating what happens to explaining ​_why_​ it happens, which shows mastery of the concept.To complement your answer, I'll add that string slicing is a powerful feature in Python that allows you to extract substrings using the syntax `string[start:stop:step]`. 
> 
> As demonstrated in your examples:
> •   When `start` is omitted, slicing begins from index 0  
> •   When `stop` is omitted, slicing continues to the end of the string  
> •   When `step` is negative, the string is traversed in reverse order
> 
> The [Reverse exercise](https://launchschool.com/exercises/7947a9ad) in the Python Basics material mentions that while strings don't have a built-in method for reversing (unlike lists), slicing with a negative step parameter (`[::-1]`) is a common and efficient way to reverse a string in Python.Your explanation demonstrates a solid understanding of this concept, which will serve you well in your assessment.

### 2. What does this print and why? What concept is this?

```python
print("Hello\nWorld")
```

**Answer**:

This code prints:
`Hello`
`world`

The reason is that we are including `\n` a return character the prints the two words in separate lines.

The concept demonstrated here is escaping characters.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 90/100**
> 
> Your answer is largely accurate. The output is correct, and you've identified that `\n` creates a line break. However, there's a minor capitalization issue in your output - it should be `World` (with a capital W) to match the code.
> 
> **Completeness: 80/100**
> 
> You've covered the basic concept but could elaborate more on what escape sequences are and why they're needed in Python strings.
> 
> **Precision: 85/100**
> 
> Your terminology is generally correct, though `\n` is specifically a newline character rather than a "return character" (which would be `\r` in escape sequence notation).
> 
> **Improved Answer**
> 
> This code prints:
> 
> ```python
> Hello  
> World
> ```
> 
> The reason is that `\n` is an escape sequence that represents a newline character in Python strings. When the string is processed, the `\n` is not displayed literally but is interpreted as an instruction to start a new line.
> 
> The concept demonstrated here is escape sequences in strings. 
> 
> Escape sequences allow us to include special characters in strings that would otherwise be difficult or impossible to type directly. They start with a backslash (`\`) followed by a character that gives it special meaning. Besides `\n` for newline, other common escape sequences include `\t` for tab, `\\` for backslash, `\'` for single quote, and `\"` for double quote.

### 3. What does this print and why? What concept is this?

```python
name = 'Alexander Graham Bell'
print(name[0])
```

**Answer**:

This code prints the character `A`.

The reason is that on line 2, we are accessing the character at index 0 of the string referenced by global variable `name`, returning a new string object with value `A`, which is then passed in as an argument to the `print()` function.

The concept demonstrated here is strings indexing.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**
> 
> Your answer is highly accurate. You've correctly identified that the code will print `A` and that we're accessing the character at index 0 of the string.
> 
> **Completeness: 90/100**
> 
> Your answer covers the core concept well. You explain that we're accessing a specific character in the string by its index and printing the result.
> 
> **Precision: 95/100**
> 
> Your terminology is precise. You correctly use terms like "index," "string object," and "global variable." You've also accurately described that string indexing returns a new string object rather than modifying the original.Your answer demonstrates a strong understanding of string indexing in Python. 
> 
> **To enhance it slightly:**
> 
> This code prints the character `A`. 
> 
> On line 1, we initialize a global variable `name` that references a string object with the value `'Alexander Graham Bell'`. 
> 
> On line 2, we use string indexing to access the character at position 0 (the first character) of the string referenced by `name`. In Python, indexing is zero-based, meaning the first character is at index 0. The indexing operation returns a new string object containing just the character `A`, which is then passed as an argument to the `print()` function.
> 
> The concept demonstrated here is string indexing, which allows us to access individual characters within a string by their position. This is possible because strings in Python are sequence types, meaning they represent an ordered collection of elements (in this case, characters) that can be accessed by their position.
> 
> Remember that while strings in Python share many characteristics with other sequence types like lists, they are immutable - meaning you can access individual characters but cannot modify them in place.

## f-strings

### Basic Questions:

- What are f-strings?
A: These are formatted-strings, which allows the interpolation of expressions into strings, by surrounding them with curly braces, making them more readable.

> [!NOTE]
> @LSBot Feedback
> 
> F-strings (formatted string literals) are a string formatting mechanism introduced in Python 3.6 that provides a concise and readable way to embed expressions inside string literals. They are created by prefixing a string literal with the letter 'f' or 'F' and placing expressions inside curly braces `{}` within the string. These expressions are evaluated at runtime and their values are converted to strings and inserted into the final string.

### 1. What does this print and why, what is the concept?

```python
name = 'Abraham Lincoln'
print(f"{name} was a President of the US")
```

**Answer**:

This code prints: `Abraham Lincoln was a President of the US`.

On line 1, we initialized a global variable `name` and references a string object with value `Abraham Lincoln`.

On line 2, the string object referenced by `name` is interpolated into the string object and passed in as an argument to the `print()` function, outputting `Abraham Lincoln was a President of the US` to the console.

The concept demonstrated here is string interpolation.

> [!NOTE]
> @LSBot Feedback:
> 
> **Accuracy: 95/100**
> 
> Your answer is highly accurate. You correctly identify the output and explain that the value of the `name` variable is interpolated into the string.
> 
> **Completeness: 90/100**
> 
> Your answer covers the essential aspects of what's happening in the code. You correctly describe the initialization of the variable and how it's used in the f-string.
> 
> **Precision: 92/100**
> 
> Your terminology is precise. You appropriately use terms like "global variable," "references," "string object," and "interpolated" which demonstrates a solid understanding of the underlying concepts.Your answer demonstrates a strong understanding of string interpolation using f-strings. 
> 
> **To enhance it slightly**:
> 
> This code prints: `Abraham Lincoln was a President of the US`.
> 
> On line 1, we initialize a global variable `name` that references a string object with the value `'Abraham Lincoln'`.
> 
> On line 2, we use an f-string (formatted string literal) which is denoted by the `f` prefix before the string. The expression `{name}` within the curly braces is evaluated at runtime, and the value of the `name` variable (`'Abraham Lincoln'`) is converted to a string and inserted into that position. This complete string is then passed as an argument to the `print()` function, which outputs `Abraham Lincoln was a President of the US` to the console.
> 
> The concept demonstrated here is string interpolation using f-strings, which were introduced in Python 3.6 as a concise and readable way to embed expressions inside string literals. As noted in the [String Formatting exercise](https://launchschool.com/exercises/52c9c771), f-strings "offer a concise way to embed expressions inside string literals" and are often preferred over older methods like `str.format()` because they're more intuitive.

## string methods

### Basic Questions:

- How do you identify a method versus a function?

### 1. What does this print and why?

```python
mashup = "thIs is How we type careLEssly"
cleaned = mashup.capitalize()
print(cleaned)
```

### 2. What do these print and why?

```python
stuff = 'tHIS iS bACKWARDS'
str1 = stuff.swapcase()
str2 = stuff.upper()
str3 = stuff.lower()
print(stuff)
print(str1)
print(str2)
print(str3)
```

### 3. What do these print and why?

```python
s1 = "Hello"
print(s1.isalpha())
s2 = "Hello World"
print(s2.isalpha())
s3 = "Hello!"
print(s3.isalpha())
s4 = "Hello123"
print(s4.isalpha())
s5 = ""
print(s5.isalpha())
s6 = "こんにちは"
print(s6.isalpha())
s7 = "HelloWorld"
print(s7.isalpha())
words = ["apple", "banana", "cherry"]
print(all(word.isalpha() for word in words))
```

### 4. What does this print and why?

```python
string1 = "HelloWorld"
string2 = "12345"
string3 = "Hello World"

result1 = string1.isalpha()
result2 = string2.isalpha()
result3 = string3.isalpha()

print("Is '{}' alphabetic?".format(string1), result1)
print("Is '{}' alphabetic?".format(string2), result2)
print("Is '{}' alphabetic?".format(string3), result3)
```

### 5. What do these print and why?

```python
s1 = "123abc"
print(s1.isdigit())
s2 = "123$%^"
print(s2.isdigit())
s3 = ""
print(s3.isdigit())
s4 = "12345"
print(s4.isdigit())
```

### 6. What do these print and why?

```python
print("Hello World".isalnum())
print("Hello@World".isalnum())
print("".isalnum())
print("Hello123".isalnum())
```

### 7. What do these print and why?

```python
name = 'HELLO'

if name.isupper():
    print("WORLD")
else:
    print("world")
    ```

###  8. What do these print and why?
```python
def punctuation_type(str):
    if str == str.upper():
        print('This is all caps')
    elif str == str.lower():
        print('This is all lowercase')
    else:
        print('Neither')

str1 = 'HELLO'
str2 = 'yolo'
str3 = 'My Name Is: '

punctuation_type(str1)
punctuation_type(str2)
punctuation_type(str3)
```

### 9. What do these print and why?

```python
str1 = "    "
str2 = "  Hello   "
str3 = "Hello World"

print(str1.isspace())
print(str2.isspace())
print(str3.isspace())

sentence = "Hello     World!   How are you?   "
word_count = sum(1 for word in sentence.split() if not word.isspace())
print("Number of words in the sentence:", word_count)
```

### 10. What do these print and why?

```python
s = "   Hello, World!   "
print(s.strip())
print(s.strip(" !"))
```

### 11. What do these print and why?

```python
s = "www.example.com"
print(s.lstrip('wcmo.'))
```

### 12. What do these print and why?

```python
s = 'impatient'
print(s.rstrip('tp'))
print(s.rstrip('p'))
```

### 13. What do these print and why?

```python
s = "Hello, World!"
print(s.replace("Hello", "Hi"))
print(s.replace("o", "0"))
```

### 14. What do these print and why?

```python
sentence = "This is a sample sentence."
words = sentence.split()
print(words)

csv_data = "John,Doe,30,New York"
fields = csv_data.split(",")
print(fields)

sentence = "This is a sample sentence."
words = sentence.split(maxsplit=2)
print(words)
```

### 15. What does this print and why?

```python
str1 = "hello world"
str2 = str1.capitalize()
print("Original string:", str1)
print("Capitalized string:", str2)
```

## boolean vs. truthiness

### Basic Question:

- In Python, what values are considered Falsy and what are considered Truthy?

### 1. What do these print and why?

```python
truthy_values = [1, 2, 3, "hello", [1, 2, 3], {"a": 1}, True, 0, "", [], {}, None, False]

print(“Values:”)
for value in truthy_values:
    if value:
        print(f"{value} is truthy")
    else:
        print(f"{value} is falsy")
```

### 2. What do these print and why?

```python
x = 5
y = 10
z = 15

print(x > 0 and y < 20)
print(not x == y)
print(x < y and y < z)
print(x > y or y > z)
print(not (x > y))
```

### 3. What do these print and why?

```python
a = 10
b = 20

print(a < b < 30)
print(a > b or b == 20)
```

### 4. What do these print and why?

```python
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)
print(6 not in my_list)
```

### 5. What do these print and why?

```python
temperature = 25
time_of_day = "morning"

if temperature < 30 and (time_of_day == "morning" or time_of_day == "afternoon"):
    print("It's a pleasant day!")
else:
    print("It's either too hot or not the right time of day.")
```

### 6. What does this print and why?

```python
num = 12

if num / 3 < 3 and num > 10:
    print("Hello")
elif num >= 8 and num < 6 or num > 4 and num < 16:
    print("Hello 2")
elif num % 4 == 0 or num < 7 and num < 10:
    print("Hello 3")
else:
    print("Buy")
```

## ranges

### Basic questions:

- Is a range primitive or non-primitive?
- Is a range mutable or immutable?
- Does range have a literal form or a type constructor?
- Is a range a sequence or a collection?
- What is the most common use of the range datatype?
- Are ranges homogenous or heterogeneous?
- Why are ranges considered lazy?

### 1. What do these print and why? What concept does this demonstrate?

```python
print(range(0,10))
print(len(range(5, 15)))
print(my_range[1])
print(str(range(3, 7)))
print(list(range(12, 8, -1)))
print(list(range(5, 5, 1)))
print(5 in range(5))
print(5 not in range(5, 10))
```

### 2. What does this code print and why? What concept does this demonstrate?

```python
example = range(0)
if example:
    print(list(example))
else:
    print(example)
```

### 3. What does this code print and why? What concept does this demonstrate?

```python
def number_range(number):
    match number:
        case n if n < 0:
            print(f'{number} is less than 0')
        case n if n <= 50:
            print(f'{number} is between 0 and 50')
        case n if 50 < n <= 100:
            print(f'{number} is between 51 and 100')
        case _:
            print(f'{number} is greater than 100')
number_range(0)
number_range(25)
```

## list and dictionary syntax

### Basic Questions

- What categories are lists and dictionaries?
- Are they mutable or immutable?
- Are they primitive or non-primitve?
- Are they literals, or do they require type constructors?
- Are they sequences?
- Does the order of the elements in both matter?


## List methods: len(list), list.append(), list.pop(), list.reverse()

### 1. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
length_of_list = len(my_list)
print("Length of the list:", length_of_list)
```

### 2. What does this print and why?

```python
lst_one = [0, 1, 2, 3]
lst_two = lst_one.append(4)
if lst_two:
    print(lst_two)
else:
    print(lst_one)
```

### 3. What does this print and why?

```python
my_list = [1, 2, 3, 4, 5]
ele = my_list.pop()
print("Popped element:", ele)
print("List after popping:", my_list)
ele1 = my_list.pop(1)
print("Popped element at index 1:", ele1)
print("Modified list after popping at index 1:", my_list)
```

### 4. What does this print and why?

```python
elements = [0, 1 , 2, "Dima"]
print(elements.reverse())
print(elements)
```

### 5. What does this print and why?

```python
ages = {
    "dimo": 31,
    "olena": 32,
    "tetiana": 28
}

def get_val_of_dimo(info):
    try:
        info['dimo']
        return info['dimo']
    except KeyError:
        return "Typo"

print(get_val_of_dimo(ages))
```

### 6. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
keys = my_dict.keys()
print(keys)
for key in keys:
    print(key)
```

### 7. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
values = my_dict.values()
print(values)
for value in values:
    print(value)
```

### 8. What does this print and why?

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
items = my_dict.items()
print(items)
for key, value in items:
    print(key, value)
```

## variable scope, global keyword, variables as pointers, variable shadowing

### 1. What does this print and why?

```python
name = 'John'

def greet():
    print(f"Hello, {name}!")

greet()
```

### 2. What does this print and why?

```python
def assign():
    var = 20
    print(var)

assign()
```

### 3. What does this print and why?

```python
try:
    print(var)
except NameError as e:
    print("Error occurred")
```

### 4. What does this print and why?

```python
var = 10

def function1():
    var = 20
    print(var)

function1()

try:
    print(var)
except NameError:
    print("Error occurred")

def function2():
    var += 5
    print(var)

try:
    function2()
except UnboundLocalError:
    print("Error occurred")

def function3():
    global var
    var += 5
    print(var)

function3()
print(var)
```

### 5. What does this print and why?

```python
var = 10

def function1():
    print(var)

function1()

def function2():
    var = 20
    print(var)

function2()
print(var)
```

### 6. What does this print and why?

```python
def function1():
    x = 10

    def function2():
        y = 20
        print(x)

    function2()
    print(x)

function1()
print(x)
print(y)
```

### 7. What does this print and why?

```python
var = 10

def access():
    print(var)
```