# Mock Exam 1

### 1: Which variable is coerced? Is it implicit or explicit coercion?

```python
x = 3.5
y = 5
z = x + y
```

**Answer**:

The variable `y` is coerced into a float number and the value of `z` is `8.5`

The Python interpreter does an implicit coercion of the variable `y`.

There are two types of coercion in Python, implicit and explicit. Implicit is when the Python interpreter does it behind the scenes and explicit is when we intentionally use a built-in function to change the data type from one type to another. For example via the constructors `int()`, `float()`, `str()`.


> [!NOTE]
> @LSBot Feedback
> 
> **Review of Your Answer**
> 
> Your answer is quite strong overall, with good explanation of the concepts. Let me break down the evaluation by criteria:
> 
> **Accuracy: 90/100**
> 
> Your answer correctly identifies that `y` is implicitly coerced to a float, and that `z` equals 8.5. You've also correctly explained the difference between implicit and explicit coercion.
> 
> One small accuracy issue: It would be more precise to say that the value of `y` (which is 5) is coerced, rather than the variable itself. Variables don't have types in Python; values do.
> 
> **Completeness: 95/100**
> 
> You've covered all the essential points:
> 
> •   Identified which value is coerced  
> •   Explained implicit vs explicit coercion  
> •   Provided examples of explicit coercion functions  
> •   Noted the final value of `z`
> 
> **Precision: 85/100**
> 
> Your explanation is generally precise, but could be improved:
> 
> •   As mentioned, it's the value of `y` that's coerced, not the variable itself  
> •   You could clarify that this specific coercion happens because operations between integers and floats in Python always result in a float.
> 
> From the [Type Conversions](https://launchschool.com/lessons/a29e9831/assignments/ed956456) material: "when you conduct a calculation involving both an integer and a float, the system will automatically adjust the integer to a float, ensuring the outcome is a float as well."
> 
> This is a good answer that demonstrates your understanding of type coercion in Python. The distinction between values and variables is important to maintain in your explanations, as this precision of language will be important for your assessment.

**Reviewed Answer:**

The value of the variable y is implicitly coerced into a float number.

On line 1, we initialize the global variable x that references a float object with the value 3.5

On line 2, we initialize a global variable y that references an integer object with the value 5.

On line 3, we initialize a global variable z that references the return value of adding x + y, which results in 8.5.

In this code snippet, the coercion of the value referenced by y happens because there is a calculation (addition) that involves both an integer value and a float value. Python implicitly coerces the integer value to a float, returning a float value.

> [!NOTE]
> **Feedback on reviewed answer**
> 
> **Accuracy: 98/100**
> 
> Your answer is now highly accurate. You've correctly identified that:
> 
> •   The value referenced by variable `y` is implicitly coerced to a float  
> •   The value of `x` is 3.5 (though there's a minor typo with a backtick in "3`.5`")  
> •   The result of adding `x + y` is 8.5  
> •   The implicit coercion happens because of a mixed-type operation
> 
> **Completeness: 97/100**
> 
> You've covered all the key elements of the problem:
> 
> •   Correctly identified what is being coerced  
> •   Explained the initialization of each variable  
> •   Described the operation that triggers coercion  
> •   Explained the result and why it's a float
> 
> **Precision: 98/100**
> 
> Your language is very precise and demonstrates a clear understanding of Python's type system:
> 
> •   You correctly distinguish between variables and the values they reference  
> •   You properly use terminology like "implicit coercion"  
> •   You accurately describe the behavior of arithmetic operations with mixed types
> 
> This explanation aligns well with the material from the [Type Conversions](https://launchschool.com/lessons/a29e9831/assignments/ed956456) assignment, which explains how Python automatically converts integers to floats when performing calculations involving both types.
> 
> The only improvement would be fixing the small formatting issue with the backtick in "3`.5`" - it should just be "3.5". Otherwise, this is an excellent answer that demonstrates a solid understanding of type coercion in Python.

### 2: What does this return and why? What concept does this cover?

```python
def convert_to_int(string):
    try:
        converted_integer = int(string)
        return converted_integer
    except ValueError:
        return "That string cannot be converted to an integer"

print(convert_to_int("hello"))

print(convert_to_int("5"))
```

**Answer**:

This code snippet returns on line 8, the string object with the value `That string cannot be converted to an integer`. And on line 10, the integer object with value `5`.

On line 8, we invoke the function `convert_to_int` with the string object with value `hello` as an argument.

From lines 1-6, we have the definition of the function `convert_to_int` with a single parameter `string`.

Within the function, the value `hello` is assigned to the local variable `string`. We have a `try` statement and within the block we invoke the `int` constructor and pass in the value referenced by `string` as an argument. This explicit coercion raises a `ValueError` exception, as the string `hello` cannot be transformed into an integer object. This exception is caught in the `except` statement, executing the respective code block, returning the string `That string cannot be converted to an integer`. The returned value is then passed in as an argument to the `print` function, which outputs it to the console.

On line 10, we invoke the function `convert_to_int` with the string object with value `5` as an argument.

Within the function, the value `5` is assigned to the local variable `string`. We have a `try` statement and within the block we invoke the `int` constructor and pass in the value referenced by `string` as an argument. The explicit coercion to an integer object is successful and the returned value is assigned to the variable `converted_integer`, which is then returned on line 4 and passed in as an argument to the `print` function, which outputs it to the console.

This code snippet demonstrates the concept of Explicit Type Coercion, which is when we intentionally transform the value of a data type into another with the use of built-in functions, in this case the built-in function `int()`, to transform a value with data type string to integer.

Additionally, the concept of Exception Handling is demonstrated by the use of try/except statements to catch runtime exceptions to avoid breaking the program flow.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**
> 
> Your answer correctly identifies:
> 
> •   The function returns a string when given "hello" and an integer when given "5"  
> •   The reason for the different return values (ValueError exception handling)  
> •   The key concepts of explicit type coercion and exception handling
> 
> One small inaccuracy is referring to `int()` as a "constructor." While this terminology is sometimes used, in Python the built-in functions like `int()`, `str()`, and `float()` are more precisely called type conversion functions rather than constructors.
> 
> **Completeness: 98/100**
> 
> You've covered nearly all important aspects:
> 
> •   Detailed step-by-step explanation of what happens in each function call  
> •   Clear explanation of the exception handling flow  
> •   Identified both main concepts (explicit type coercion and exception handling)  
> •   Explained how the values are processed and returned
> 
> **Precision: 97/100**
> 
> Your answer shows excellent precision in language:
> 
> •   You distinguish between variables and the values they reference  
> •   You properly trace through the code execution line by line  
> •   You accurately describe how the exception is raised and handled
> 
> This aligns with the material from the [Type Conversions](https://launchschool.com/lessons/a29e9831/assignments/ed956456) assignment, which explains how attempting to convert a non-numeric string to an integer using `int()` will raise a `ValueError`. Your explanation of the exception handling also matches what was covered in the [Refactoring Calculator](https://launchschool.com/lessons/a29e9831/assignments/f62fbd69) walkthrough.
> 
> Overall, this is an excellent answer that demonstrates thorough understanding of both explicit type coercion and exception handling in Python. Your reasoning is clear and your tracing through the code execution is methodical and precise.

**Reviewed Answer**:

This code snippet returns on line 8, the string object with the value `That string cannot be converted to an integer`. And on line 10, the integer object with value `5`.

On line 8, we invoke the function `convert_to_int` with the string object with value `hello` as an argument.

From lines 1-6, we have the definition of the function `convert_to_int` with a single parameter `string`.

Within the function, the value `hello` is assigned to the local variable `string`. We have a `try` statement and within the block we invoke the built-in type conversion function `int` and pass in the value referenced by `string` as an argument. This explicit coercion raises a `ValueError` exception, as the string `hello` cannot be transformed into an integer object. This exception is caught in the `except` statement, executing the respective code block, returning the string `That string cannot be converted to an integer`. The returned value is then passed in as an argument to the `print` function, which outputs it to the console.

On line 10, we invoke the function `convert_to_int` with the string object with value `5` as an argument.

Within the function, the value `5` is assigned to the local variable `string`. We have a `try` statement and within the block we invoke the built-in type conversion function `int` and pass in the value referenced by `string` as an argument. The explicit coercion to an integer object is successful and the returned value is assigned to the variable `converted_integer`, which is then returned on line 4 and passed in as an argument to the `print` function, which outputs it to the console.

This code snippet demonstrates the concept of Explicit Type Coercion, which is when we intentionally transform the value of a data type into another with the use of built-in functions, in this case the built-in function `int()`, to transform a value with data type string to integer.

Additionally, the concept of Exception Handling is demonstrated by the use of try/except statements to catch runtime exceptions to avoid breaking the program flow.

> [!NOTE]
> @LSBot Feedback on reviewed answer:
> 
> **Accuracy: 98/100**
> 
> Your answer is highly accurate. You've correctly:
> 
> •   Identified what the code returns in both cases  
> •   Described how the `ValueError` exception is raised and handled  
> •   Explained that this demonstrates explicit type coercion  
> •   Noted that exception handling is used to manage potential errors
> 
> **Completeness: 98/100**
> 
> Your explanation is thorough and covers all important aspects:
> 
> •   You've detailed the execution flow line by line  
> •   You've explained both successful and unsuccessful type conversion cases  
> •   You've correctly identified and explained both key concepts (explicit type coercion and exception handling)  
> •   You've described how the return values are processed
> 
> **Precision: 97/100**
> 
> Your language is precise and demonstrates strong technical understanding:
> 
> •   You correctly refer to `int()` as a "built-in type conversion function"  
> •   You clearly distinguish between variables and the values they reference  
> •   You accurately describe the exception handling mechanism  
> •   You're precise about what happens in each step of execution
> 
> This answer aligns perfectly with the material from the [Type Conversions](https://launchschool.com/lessons/a29e9831/assignments/ed956456) assignment, which explains that "attempting to convert a non-numeric string to an integer using `int()` will raise a `ValueError`."Your explanation of exception handling is also consistent with what's covered in the [Refactoring Calculator](https://launchschool.com/lessons/a29e9831/assignments/f62fbd69) walkthrough, where `try/except` is used to catch `ValueError` exceptions when converting strings to numbers.
> 
> Overall, this is an excellent answer that demonstrates mastery of both explicit type conversion and exception handling concepts in Python. The thoroughness of your line-by-line explanation and your precise technical language would serve you well on the assessment.

### 3. What is the output of this code, and why? What is the concept covered here?

```python
str1 = "Hello, world!"
sub1 = str1[8:12]
print(sub1)
sub2 = str1[::-1]
print(sub2)
sub3 = str1[::2]
print(sub3)
```

**Answer**:

The output of this code is:

`orld`
`!dlrow ,olleH`
`Hlo ol!`

On line 1, we initialize a global variable `str1` that references a string object with the value `Hello, world!`.

On line 2, we initialize a global variable `sub1` that references the return value of slicing the value reference by `str1` from the element located at index 8 up to but not including the element at index 12. The return value is a new string object with value `orld`.

On line 3, we pass in the value referenced by `sub1` to the `print` function, which outputs it to the console.

On line 4, we initialize a global variable `sub2` that references the return value of slicing the string object referenced by `str1`, in reverse mode, returning a new string object with value  `!dlrow ,olleH`.

On line 5, we invoke the `print` function with the value referenced by `sub2` as an argument, outputting it to the console.

On line 6, we initialize a global variable `sub3` that references the return value of slicing the string object referenced by `str1`, with a step of 2, returning a new string object with value `Hlo ol!`, which is then passed in as an argument to the `print` function, which outputs it to the console.

The concept demonstrated is string slicing and string immutability, as when slicing a string, a new string object is returned.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your answer is completely accurate. You've correctly:
> 
> •   Identified the exact output for each print statement  
> •   Explained the slicing operations properly  
> •   Noted how each slice creates a new string object  
> •   Recognized that strings are immutable in Python
> 
> **Completeness: 98/100**
> 
> Your explanation is comprehensive and covers all the key points:
> 
> •   You've detailed what happens in each line of code  
> •   You've explained the three different slicing syntaxes: start:end, ::-1 (reverse), and ::2 (step)  
> •   You've identified both major concepts (string slicing and string immutability)  
> •   You've described how the values are processed and outputted
> 
> **Precision: 97/100**
> 
> Your language is very precise and demonstrates excellent technical understanding:
> 
> •   You correctly use terminology like "references" to describe variable assignment  
> •   You accurately describe the inclusive/exclusive nature of slicing (up to but not including)  
> •   You properly explain the step parameter in slicing  
> •   You correctly identify that each slice operation returns a new string object
> 
> This answer aligns with the string documentation referenced in the [Reverse exercise](https://launchschool.com/exercises/7947a9ad), which demonstrates how to use slicing to reverse a string.
> 
> Your understanding of string slicing is solid, and your explanation of how slicing creates new string objects (due to string immutability) shows a deep understanding of how Python handles string operations. This is an excellent assessment-ready answer that demonstrates mastery of the concepts.

### 4. What does this print and why, what is the concept?

```python
name = 'Abraham Lincoln'
print(f"{name} was a President of the US")
```

**Answer**:

The output of this code is the string `Abraham Lincoln was a President of the US`.

On line 1, we initialize a global variable `name` that references the string object with the value `Abraham Lincoln`.

On line 2, the value referenced by `name` is interpolated into the f-string, resulting in the string object with value `Abraham Lincoln was a President of the US`, which is passed in as an argument to the `print` function, which outputs it to the console.

The concept demonstrated here is f-strings and how expressions can be embedded into string literals.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 95/100**
> 
> Your answer is accurate in identifying:
> 
> •   The exact output of the code  
> •   The initialization of the `name` variable  
> •   That f-strings are being used for string interpolation  
> •   That this allows expressions to be embedded in string literals
> 
> **Completeness: 90/100**
> 
> Your answer covers the basic elements of what's happening in the code, but could include:
> 
> •   More detail about f-strings (introduced in Python 3.6)  
> •   Mention that this is a form of string formatting/string interpolation  
> •   Comparison to alternative string formatting methods  
> •   That variables inside the curly braces are automatically converted to strings
> 
> **Precision: 93/100**
> 
> Your language is generally precise, correctly distinguishing between:
> 
> •   Variables and the values they reference  
> •   The process of string interpolation and the resulting output
> 
> **To enhance your answer**, you could add that f-strings (formatted string literals) were introduced in Python 3.6 as a concise way to embed expressions inside string literals. This is an example of string formatting or string interpolation. As noted in the [String Formatting exercise](https://launchschool.com/exercises/52c9c771), Python offers multiple ways to format strings, with f-strings being one of the more modern and readable approaches compared to older methods like `str.format()`.
> 
> When Python processes an f-string, it evaluates the expressions inside the curly braces and converts the results to strings, implicitly coercing non-string values as necessary. This automatic conversion to strings relates to the concept of type coercion we've seen previously.Your explanation demonstrates a good understanding of how f-strings work in Python, which is an important concept for string manipulation and formatting.

**Reviewed Answer**:

The output of this code is the string `Abraham Lincoln was a President of the US`.

On line 1, we initialize a global variable `name` that references a string object with the value `'Abraham Lincoln'`.

On line 2, we use an f-string (formatted string literal) which is denoted by the `f` prefix before the string. The expression `{name}` within the curly braces is evaluated at runtime, and the value of the `name` variable (`'Abraham Lincoln'`) is converted to a string and inserted into that position. This complete string is then passed as an argument to the `print()` function, which outputs `Abraham Lincoln was a President of the US` to the console.

The concept demonstrated here is string interpolation using f-strings, which were introduced in Python 3.6 as a concise and readable way to embed expressions inside string literals. f-strings automatically handle the conversion of non-string values to strings.

> [!NOTE]
> @LSBot feedback
> 
> Your answer is excellent and assessment-ready! You've accurately explained:
> 
> 1.  The output of the code  
> 2.  How the variable `name` is initialized and referenced  
> 3.  How f-strings work with the prefix `f` and expressions in curly braces  
> 4.  The runtime evaluation of expressions in f-strings  
> 5.  The automatic conversion to strings (which is especially important for non-string values)  
> 6.  The historical context (introduced in Python 3.6)
> 
> Your explanation demonstrates a thorough understanding of string interpolation in Python, which is an important concept covered in the PY101 curriculum that will be tested in your PY109 assessment.
> 
> The precision of your language and attention to detail in explaining exactly how the code executes would serve you well on the assessment. Your answer shows mastery of both the concept and the technical terminology.

### 5. What does this print and why?

```python
mashup = "thIs is How we type careLEssly"
cleaned = mashup.capitalize()
print(cleaned)
```

**Answer**:

This code prints: `This is how we type carelessly`

On line 1, we initialize a global variable `mashup` that references a string object with the value `thIs is How we type careLEssly`.

On line 2, we initialize a global variable `cleaned` to the return value of invoking the `capitalize()` method on the value referenced by `mashup`. The `capitalize()` method returns a new string object with the first character of the string uppercased and the rest of the characters lowercased, resulting in the value `This is how we type carelessly`.

On line 3, we invoke the `print` function and pass in as an argument the value referenced by `cleaned`, outputting it to the console.

> [!NOTE]
> @LSBot Feedback
> 
> **Accuracy: 100/100**
> 
> Your answer is completely accurate. You've correctly:
> 
> •   Identified the exact output of the code  
> •   Explained the initialization of the `mashup` variable  
> •   Described precisely how the `capitalize()` method transforms the string  
> •   Noted that a new string object is returned (important for understanding string immutability)  
> •   Explained how the value is passed to the `print()` function
> 
> **Completeness: 98/100**
> 
> Your explanation is thorough and covers all key aspects:
> 
> •   You've detailed what happens in each line of code  
> •   You've explained exactly what the `capitalize()` method does (first character uppercase, rest lowercase)  
> •   You've traced the flow of execution from beginning to end
> 
> **Precision: 100/100**
> 
> Your language is very precise and demonstrates excellent technical understanding:
> 
> •   You correctly distinguish between variables and the values they reference  
> •   You accurately describe method behavior and return values  
> •   You properly explain the execution flow
> 
> This answer demonstrates a strong understanding of string methods in Python. As shown in the [PY101 - Debugging Techniques](https://launchschool.com/lessons/a29e9831/assignments/266a9e03) lesson, understanding how string methods work and that they return new string objects rather than modifying the original is crucial for avoiding common bugs.
> 
> This is an excellent, assessment-ready answer that shows mastery of the concepts involved.

### 6. What do these print and why?

```python
stuff = 'tHIS iS bACKWARDS'
str1 = stuff.swapcase()
str2 = stuff.upper()
str3 = stuff.lower()
print(stuff)
print(str1)
print(str2)
print(str3)
```

**Answer**:

This code prints:

`tHIS iS bACKWARDS`
`This Is Backwards`
`THIS IS BACKWARDS`
`this is backwards`

On line 1, we initialize a global variable `stuff` that references a string object with the value `tHIS iS bACKWARDS`

On line 2, we initialize a global variable `str1` that references the return value of invoking the `swapcase()` method on the object referenced by `stuff`. The method returns a new string object with the characters cased swap, if uppercased, then returns it lowercased and vice versa. The return value is `This Is Backwards`.

On line 3, we initialize a global variable `str2` that references the return value of invoking the method `upper()` on the value referenced by `stuff`, resulting in a new string object with the value `THIS IS BACKWARDS`. The `upper()` method returns a new string object with all the characters uppercased.

On line 4, we initialize a global variable `str3` that references the return value of invoking the method `lower()` on the the object referenced by `stuff`, resulting in a new string object with the value `this is backwards`. The `lower()` method returns a new string object with all the characters lowercased.

On line 5, we invoke the `print` function and pass in as an argument the value referenced by `stuff`, which outputs it to the console.

On line 6, we invoke the `print` function and pass in as an argument the value referenced by `str1`, which outputs it to the console.

On line 7, we invoke the `print` function and pass in as an argument the value referenced by `str2`, which outputs it to the console.

On line 8, we invoke the `print` function and pass in as an argument the value referenced by `str3`, which outputs it to the console.

The concept demonstrated is string methods, specifically `swapcase()`, `upper()` and `lower()` and how these methods return a new string object as strings are immutable.
``

> [!NOTE]
> LSBot Feedback
> 
> Your original answer was excellent and accurately addressed what was asked.

### 7. What do these print and why?

```python
a = 10
b = 20

print(a < b < 30)
print(a > b or b == 20)
```

**Answer**:

This code prints:

`True`
`True`

On line 1, we initialize a global variable `a` that references an integer object with value `10`

On line 2, we initialize a global variable `b` that references an integer object with value `20`

On line 4, the expression `a < b < 30` is evaluated as follows: the left operand `(a < b)` and the right operand `(b < 30)`. As the value referenced by `a` is less than the value referenced by `b`, this evaluates to `True` and as the value referenced by `b` is less that `30`, this evaluates to `True` as well, resulting in `True`the whole expression evaluation. This value is then passed in as an argument to the `print` function, which outputs it to the console.

On line 5, the expression `a > b or b == 20` is evaluated as follows: the left operand evaluates to `False` as `10` is less than `20` and the right operand evaluates to `True` as `20` is equal to `20`. The whole expression evaluates to `True`. This value is passed in an an argument to the `print` function, which outputs it to the console.

There is no short-circuit evaluation happening in either expressions as the whole expression have to be evaluated to determined the resulting value.

Also, the comparison operator `<` and `==` have precedence over the logical operators `or` and `and`.

The concept demonstrated here is Truthiness and logical operators.

> [!NOTE]
> @LSBot Feedback
> 
> **Review of Your Answer**
> 
> Looking at your answer again with a focus on your explanation of short-circuit evaluation, I need to revise my previous critique:
> 
> **Revised Scores**​:
> 
> •   **Accuracy**​: 95/100  
> •   ​**Completeness**​: 90/100  
> •   ​**Precision**​: 95/100
> 
> **Analysis**​:
> 
> **Strengths**​:
> 1.  Your output predictions are correct for both expressions.  
> 2.  Your explanation of variable initialization is clear and accurate.  
> 3.  You correctly identified the concept being demonstrated as truthiness and logical operators.  
> 4.  Your observation about operator precedence is accurate and relevant.
> 
> **Area for Improvement**​:
> 1.  **Chained Comparisons**​: 
> Your explanation of `a < b < 30` would be more precise if you mentioned that Python evaluates this as `a < b and b < 30`. This is a chained comparison which is a special syntax in Python that evaluates `b` only once.
> 
> You were correct about the lack of short-circuit evaluation in both expressions:
> •   In the first expression, both comparisons need to be evaluated for the chain to be True.  
> •   In the second expression (`a > b or b == 20`), since the first operand `a > b` evaluates to `False`, Python must evaluate the second operand to determine the result of the expression. So there is indeed no short-circuit evaluation happening in this specific case.
> 
> The PY109 study guide emphasizes understanding concepts like truthiness, logical operators, and operator precedence, which your answer demonstrates well. Understanding how Python evaluates expressions is important for the assessment, as mentioned in the [Part 1: Study Guide for PY109 Exam](https://launchschool.com/lessons/1318de4f/assignments/ff1c7aa8).
> 
> Overall, your answer shows a solid understanding of how Python evaluates expressions with logical operators and comparison operators.

### 8. What does this print and why?

```python
name = 'John'

def greet():
    print(f"Hello, {name}!")

greet()
```

### 9. What does this print and why?

```python
def assign():
    var = 20
    print(var)

assign()
```

### 10. What does this print and why?

```python
try:
    print(var)
except NameError as e:
    print("Error occurred")
```