# Concepts with Examples

- [[#1.) Data Types]]
- [[#2.) Type Coercions]]
- [[#3.) Numbers]]
- [[#Variables Naming Conventions]]
- [[#Constants Naming Conventions]]
- [[#Variable Scope]]
- [[#Assignment vs. Reassignment]]
- [[#Variables as Pointers]]
- [[#Variable Shadowing]]
- [[#Global keyword]]
- [[#Expressions vs. Statements]]
- [[#Mutability vs. Immutability]]
- [[#Operators]]
- [[#Conditionals Statements and Truthiness]]
- [[#Loops]]
- [[#Type Coercions]]
- [[#F-strings]]
- [[#Escape Sequences]]
- [[#Function definition vs. Function invocation]]
- [[#Parameters vs. Arguments]]
- [[#Return Values vs. Side Effects]]
- [[#Nested Functions]]
- [[#Pass-by-Object-Reference]]
- [[#String Methods]]
- [[#List Methods]]
- [[#Dictionary Methods]]
- [[#Slicing]]
- [[#Exception Handling]]
- [[#Mutation vs Reassignment]]
- [[#Default Parameters]]
- [[#Implicit vs. Explicit return values]]
- [[#Truthiness]]


## 1.) Data Types

### Basics

- Everything with a value in Python is an **object**.
- Each **object** has a **type** and an associated **class**.
- A **primitive type** is the most fundamental type in a language.

### Data Types in Python

##### Core Data Types

###### **Primitive/Immutable Types:**

- **Integers**​: Whole numbers like `42`, `-7`, `0`
- ​**Floats**​: Decimal numbers like `3.14`, `-2.5`
- **Strings**​: Text enclosed in quotes: `'hello'`, `"Python"`
- **Booleans**​: `True` or `False` values

###### **Compound/Mutable Types:**

- **Lists**​: Ordered, mutable collections `[1, 2, 3]`
- **Dictionaries**​: Key-value pairs `{'name': 'Alice', 'age': 30}`
- **Sets**​: Unordered collections of unique elements `{1, 2, 3}`
- **Functions**

###### **Compound/Immutable Types:**

- **Tuples**​: Immutable sequences like `(1, 2, 3)`
- **Frozen Sets**: Unordered collections of unique elements `frozenset([1, 2, 3])`
- **ranges**: represent an immutable sequence of numbers `range(5)`
### Summary

Built-in data types:

| Data Type                          | Class       | Category                | Kind          | Mutable | Immutable |
| ---------------------------------- | ----------- | ----------------------- | ------------- | ------- | --------- |
| [[#Integers]]                      | `int`       | numerics                | Primitive     |         | X         |
| [[#Floats]]                        | `float`     | numerics                | Primitive     |         | X         |
| [boolean](8.boolean_vs_truthiness) | `bool`      | booleans                | Primitive     |         | X         |
| [strings](5.strings)               | `str`       | text sequences          | Primitive     |         | X         |
| [ranges](12.ranges.md)             | `range`     | sequences (collections) | Non-primitive |         | X         |
| [tuples](13.lists)                 | `tuple`     | sequences (collections) | Non-primitive |         | X         |
| [lists](13.lists)                  | `list`      | sequences (collections) | Non-primitive | X       |           |
| [dictionaries](15.dictionaries)    | `dict`      | mappings (collections)  | Non-primitive | X       |           |
| sets                               | `set`       | sets (collections)      | Non-primitive | X       |           |
| frozen sets                        | `frozenset` | sets (collections)      | Non-primitive |         | X         |
| [functions](25.functions)          | `function`  | functions               | Non-primitive | X       |           |
| [`NoneType`](9.none)               | `NoneType`  | nulls                   | _--?--_       |         | X         |

### Literals

Is any syntactic notation used to represent an object in source code. 

These are the literals in Python:

```python
'Hello, world!'   # str literal
3.141592          # float literal
True              # bool literal
{'a': 1, 'b': 2}  # dict literal
[1, 2, 3]         # list literal
(4, 5, 6)         # tuple literal
{7, 8, 9}         # set literal
```

Not all objects have literal forms, for those the **type constructor** is used to create objects of the type:

```python
range(10)         # Range of numbers: 0-9
range(1, 11)      # Range of numbers: 1-10
set()             # Empty set
frozenset([1, 2]) # Frozen set of values: 1 and 2
```

## 2.) Type Coercions

### What is it?

* Is the process of converting a value from one data type, implicitly or explicitly, to another data type.
* operations between values of the same type in Python don't require coercion.
* `print()` function implicitly converts any value to a string but this is not considered coercion.

**Implicit Coercion**

* Is one Python automatically transforms one data type into another, without any specific instruction.

**Explicit Coercion**

* Is when we intentionally transform the value of a data type into another with the use of built-in functions, such as `int()`, `float()`, `str()`.

## 3.) Numbers

### Number types

* **Integers**​: Whole numbers without decimals (`42`, `-7`)
* **Floating-Point**​: Numbers with decimals (`3.14`, `-0.5`)
* **Complex Numbers**​: Numbers with real and imaginary parts (`3+4j`)

### Integers

- Data Type: `int`
- Can't use commas or periods for grouping: `123,456,789` nor `123.456.789`.
- Can write the number without separators or break up the number with underscores: `123_456_789`. 

### Floats

- Data Type: `float`
- Can't use commas or periods for grouping: `42,348,912.346` nor `42.348.912,346`.
- Can write the number without separators or break up the number with underscores: `42_348.912_346`.

### Truthiness of Numbers

* Zero values (`0`, `0.0`) are falsy  
* All other numeric values are truthy

### Type Conversion

* ​**Explicit**​: Using `int()`, `float()`, `complex()`  
* **Implicit**​: Happens automatically in mixed operations (integers convert to floats)

### Number Functions

* `abs()`: Absolute value
* `round()`: Rounding
* `max()`, `min()`: Finding maximum/minimum

## 4.) Strings

### Basics

* **Strings** are an immutable sequence of Unicode characters
* String **literals** can be written with a single `('string')` or double `("string")` quotes
* Triple quotes `('''string''')` or `("""string""")` for multi-line strings
* Empty strings are created with `''` or `""`
* **Text sequences** are strings of characters.
* The difference between a **Text sequence** and an **ordinary sequence** is that the **ordinary sequence** contain zero or more objects, while the **text sequence** does not contain any objects: only contains the characters (which are not objects in itself) that make up the text sequence.

### String Operations

•   ​**Concatenation**​: Using the `+` operator (`"hello" + " world"`)  
•   ​**Repetition**​: Using the `*` operator (`"ha" * 3` produces `"hahaha"`)  
•   ​**Indexing**​: Access individual characters (`text[0]`)  
•   ​**Slicing**​: Extract substrings (`text[1:4]`)  
•   ​**Length**​: Using `len()` function (`len("hello")` returns `5`)

### String Methods

•   ​**Case manipulation**​: `upper()`, `lower()`, `capitalize()`, `title()`, `swapcase()`  
•   ​**Testing**​: `isalpha()`, `isdigit()`, `isalnum()`, `isspace()`, `isupper()`, `islower()`  
•   ​**Searching**​: `find()`, `rfind()`, `index()`, `rindex()`, `count()`  
•   ​**Modification**​: `replace()`, `strip()`, `lstrip()`, `rstrip()`, `split()`, `join()`

### String Formatting

•   ​**f-strings**​: `f"Hello, {name}!"` (interpolates variables and/or expressions)  
•   ​**format() method**​: `"Hello, {}!".format(name)`  
•   ​`%` **operator**​: `"Hello, %s!" % name` (older style)

### Indexing Strings

- To access the individual characters in a string, use the `[ ]` **indexing syntax**.
- The value between the brackets must be an integer between 0 and the length of the string minus 1:

```python
>>> my_str = 'abc' 
>>> my_str[0]
a 
>>> my_str[1] 
b 
>>> my_str[2]
c
```

- You can also use negative integers to access characters based on the distance from the end of the string. For instance, `my_str[-1]` returns the last character in the string, while `my_str[-2]` returns the next to last character. The index of the first character is given by `-len(my_str)`:

```python
>>> my_str = 'abc'
>>> my_str[-1]
c
>>> my_str[-2]
b 
>>> my_str[-3]
a
```

### String Representations

- `str` and `repr` return a string representation of any object.
- `str` output is intended for human readability.
- `repr` is lower-level and returns a string that can be use to create a new instance of the object.

```python
my_str = 'abc'
print(my_str)       # abc
print(str(my_str))  # abc (same as print(my_str))
print(repr(my_str)) # 'abc' (note the quotes)
```

### Important Concepts

* Strings are ​[**passed by object reference**](20.pass_by_object_reference.md)​ to functions
* String methods ​**return new strings**​ rather than modifying existing ones
* String comparisons use **lexicographical (dictionary) ordering**
* Escape sequences like `\n`, `\t`, and `\\` for special characters

### Lexicographical (dictionary) ordering

When we talk about lexicographical ordering in string comparisons, we're referring to how Python determines whether one string is "greater than," "less than," or "equal to" another string. This is similar to how words are ordered in a dictionary (hence the term "dictionary ordering").

#### How Lexicographical Comparison Works?

When Python compares two strings using operators like `<`, `>`, `==`, `!=`, `<=`, or `>=`, it does so character by character, from left to right:

1.  Python compares the first character of each string using their Unicode code points  
2.  If they differ, the comparison result is determined immediately  
3.  If they're the same, Python moves to the next character and repeats the process  
4.  If one string is a prefix of the other (meaning it runs out of characters first), the shorter string is considered "less than" the longer one

* Python compares strings character-by-character from left to right in both strings. The comparison stops as soon as Python reaches a decision.
- `'abcdef' > 'abc'`. In this example, the strings have unequal sizes. Furthermore, the longer string is identical up to the shorter string's length. Python returns `True` here; when it can no longer take characters from the shorter string, it concludes that the longer string has the greater value. Similar behaviors occur with the other ordered comparison operators.
- It's also worth noting that even numeric strings are compared character by character. Thus, `'3' > '24'` returns `True` since the character `3` is greater than the character `2`.
- In general, numeric characters in a string are less than alphabetic characters, and uppercase letter characters are less than lowercase letters.

#### Unicode Ordering

The comparison is based on the Unicode code point (numerical value) of each character. In ASCII/Unicode:

•   Uppercase letters (`A-Z`) come before lowercase letters (`a-z`)  
•   Digits (`0-9`) come before letters  
•   Special characters have their own ordering
### Examples

```python
# String operations
name = "Python is cool"
greeting = "Hello, " + name + "!"  # 'Hello, Python is cool!'
repeated = name * 3  # Repetition: "Python is coolPython is coolPython is cool"

# Indexing and slicing
first_char = name[0]  # 'P'
substring = name[1:4]  # 'yth'

# String methods (Case Manipulation)
upper_name = name.upper()  # 'PYTHON IS COOL'
lower_name = name.lower()  # 'python is cool'
capitalize_name = lower_name.capitalize() # 'Python is cool'
title_name = name.title()  # 'Python Is Cool'
swapcase_name = name.swapcase() # 'pYTHON IS COOL'

# String methods (Testing)
has_alpha = name.isalpha()  # False (there are spaces in the String)
has_digits = name.isdigit()  # False
has_alnum = name.isalnum()   # False
is_space = name.isspace()    # False
is_upper = name.isupper()    # False
is_lower = name.islower()    # False

# String methods (Searching)
position = name.find('th')  # 2 (returns -1 if not found)
rfind = name.rfind('o')     # 12 (Highest Index)
idx = name.index('th')      # 2 (like find but raises ValueError if not found)
ridx = name.rindex('o')     # 12
count = name.count('o')     # 3

# String Modification
replace_name = name.replace('Python', 'JavaScript') # JavaScript is cool
new_name = " Python is cool "
strip = name.strip() # 'Python is cool'
lstrip = name.strip() # 'Python is cool '
rstrip = name.rstrip() # ' Python is cool'
split = name.split() # ['Python', 'is', 'cool']
split_join = ' '.join(split) # 'Python is cool'

# String formatting
age = 30
message = f"{name} is {age} years old"
```



## 5.) F-Strings

## 6.) String Methods

## 7.) Boolean vs. Truthiness

## 8.) `None`

## 9.) Ranges

## 10.) List and Dictionary Syntax

## 11.) List Methods

## 12.) Dictionary Methods

## 13.) Slicing

## 14.) Operators

## 15.) Mutability and Immutability

## 16.) Pass by Object Reference

## 17.) Variables

## 18.) Conditionals and Loops

## 19.) `print()` and `input()`

## 20.) Exceptions

## 21.) Functions

## 22.) Expressions and Statements

### Variables Naming Conventions

**Concepts:**

- **idiomatic**: the Python's naming conventions are followed (Python Enhancements Proposal - PEP8)
- **non-idiomatic**: the Python's naming conventions are not followed but the name is **legal**
- **illegal**: names that are syntactically incorrect or are using a Python's reserved word: `if`, `elif`, `else`, `pass`, `def`, `while`, `for`, `class`, `return`.

**Variables Naming Conventions:**

- Use of **snake_case**
- Names can contain `a-z` and `0-9`
- Cannot begin with a digit
- Names with multiple words must be separated by `_`

**Special Cases:**

- Names with double underscores on both sides like `__var__` are not idiomatic (except when specifically defined by Python).
- Non-ASCII characters (like `π`) are non-idiomatic.
- Words without separation (like `milesperhour`) are non-idiomatic.

**Illegal Names**:

* Punctuation characters, most special characters, and whitespaces are not allowed
* Names must not begin with a digit
* Python reserved words are not allowed: `if`, `def`, `while`, `for`, `return`, `class` and `pass`

### Constants Naming Conventions

- Use of **SCREAMING_SNAKE_CASE**
- Names can contain `A-Z`and `0-9`
- Cannot begin with a digit
- Names with multiple words must be separated by `_`

### Variable Scope

Variables defined outside of any function have **global scope**, meaning they can be accessed from anywhere in your program.

Variables defined inside a function have **local scope**, meaning they can only be accessed within that function.

### Assignment vs. Reassignment

### Variables as Pointers

### Variable Shadowing

### Global keyword

### Expressions vs. Statements

### Mutability vs. Immutability

#### What is the definition of mutable/immutable?

* Mutable types are types whose objects can be changed after they are created.
* Immutable types cannot be changed after they are created.

## Operations and Control Flow
### Operators

### Conditionals Statements and Truthiness

### Loops

### F-strings

The concept demonstrated here is string interpolation using f-strings, which were introduced in Python 3.6 as a concise and readable way to embed expressions inside string literals. f-strings automatically handle the conversion of non-string values to strings.

**Example**
Within the function, on line X, we use an f-string (formatted string literal) which is denoted by the `f` prefix before the string. The expression `{XXX}` within the curly braces is evaluated at runtime, and the value of the `name` variable (`'XXX'`) is converted to a string and inerpolated into the string.

### Escape Sequences

The concept demonstrated here is escape sequences in strings, which allow us to encode special characters into strings via escape notation that would be impossible to include in another way. Examples: newlines, carriage returns, tabs, etc.

## Functions
### Function definition vs. Function invocation

### Parameters vs. Arguments

### Return Values vs. Side Effects

### Nested Functions

### Pass-by-Object-Reference


## Collections and String Operations

### String Methods

### String Check Methods

The concept demonstrated here is string check methods, specifically `XXX()` that check that the string contains only XXX characters, without modifying the original string, demonstrating string immutability.

### List Methods

### Dictionary Methods

### Slicing

### Exception Handling

Is the process to manage or handle errors that might occur during the execution of a program.

The flow of exception handling includes:
1.  The try block that contains code that might raise an exception  
2.  The except block that runs only if a matching exception occurs  
3.  The else block (if present) that runs only if no exceptions occurred  
4.  The finally block (if present) that always runs regardless of exceptions

## Other
### Mutation vs Reassignment

### Default Parameters

### Implicit vs. Explicit return values

### Truthiness

Is how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.











