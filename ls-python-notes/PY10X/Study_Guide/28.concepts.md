# Concepts with Examples

- [[#1.) Data Types]]
- [[#2.) Type Coercions]]
- [[#3.) Numbers]]
- [[#4.) Strings]]
- [[#5.) F-Strings]]
- [[#6.) String Methods]]
- [[#7.) Boolean vs. Truthiness]]
- [[#8.) `None`]]
- [[#9.) Ranges]]
- [[#10.) List and Dictionary Syntax]]
- [[#11.) List Methods]]
- [[#12.) Dictionary Methods]]
- [[#13.) Slicing]]
- [[#14.) Operators]]
- [[#15.) Mutability and Immutability]]
- [[#16.) Pass by Object Reference]]
- [[#17.) Variables]]
- [[#19.) `print()` and `input()`]]
- [[#20.) Exceptions]]
- [[#22.) Expressions and Statements]]
- [[#23.) Naming Conventions]]
- [[#Variables Naming Conventions]]
- [[#Constants Naming Conventions]]
- [[#Variable Scope]]
- [[#Assignment vs. Reassignment]]
- [[#Variables as Pointers]]
- [[#Variable Shadowing]]
- [[#Global keyword]]
- [[#Expressions vs. Statements]]
- [[#Mutability vs. Immutability]]
- [[#Operators]]
- [[#Conditionals Statements and Truthiness]]
- [[#Loops]]
- [[#F-strings]]
- [[#Escape Sequences]]
- [[#Function definition vs. Function invocation]]
- [[#Parameters vs. Arguments]]
- [[#Return Values vs. Side Effects]]
- [[#Nested Functions]]
- [[#Pass-by-Object-Reference]]
- [[#String Methods]]
- [[#List Methods]]
- [[#Dictionary Methods]]
- [[#Slicing]]
- [[#Exception Handling]]
- [[#Mutation vs Reassignment]]
- [[#Default Parameters]]
- [[#Implicit vs. Explicit return values]]
- [[#Truthiness]]


## 1.) Data Types

### Basics

- Everything with a value in Python is an **object**.
- Each **object** has a **type** and an associated **class**.
- A **primitive type** is the most fundamental type in a language.

### Data Types in Python

##### Core Data Types

###### **Primitive/Immutable Types:**

- **Integers**​: Whole numbers like `42`, `-7`, `0`
- ​**Floats**​: Decimal numbers like `3.14`, `-2.5`
- **Strings**​: Text enclosed in quotes: `'hello'`, `"Python"`
- **Booleans**​: `True` or `False` values

###### **Compound/Mutable Types:**

- **Lists**​: Ordered, mutable collections `[1, 2, 3]`
- **Dictionaries**​: Key-value pairs `{'name': 'Alice', 'age': 30}`
- **Sets**​: Unordered collections of unique elements `{1, 2, 3}`
- **Functions**

###### **Compound/Immutable Types:**

- **Tuples**​: Immutable sequences like `(1, 2, 3)`
- **Frozen Sets**: Unordered collections of unique elements `frozenset([1, 2, 3])`
- **ranges**: represent an immutable sequence of numbers `range(5)`
### Summary

Built-in data types:

| Data Type                          | Class       | Category                | Kind          | Mutable | Immutable |
| ---------------------------------- | ----------- | ----------------------- | ------------- | ------- | --------- |
| [[#Integers]]                      | `int`       | numerics                | Primitive     |         | X         |
| [[#Floats]]                        | `float`     | numerics                | Primitive     |         | X         |
| [boolean](8.boolean_vs_truthiness) | `bool`      | booleans                | Primitive     |         | X         |
| [strings](5.strings)               | `str`       | text sequences          | Primitive     |         | X         |
| [ranges](12.ranges.md)             | `range`     | sequences (collections) | Non-primitive |         | X         |
| [tuples](13.lists)                 | `tuple`     | sequences (collections) | Non-primitive |         | X         |
| [lists](13.lists)                  | `list`      | sequences (collections) | Non-primitive | X       |           |
| [dictionaries](15.dictionaries)    | `dict`      | mappings (collections)  | Non-primitive | X       |           |
| sets                               | `set`       | sets (collections)      | Non-primitive | X       |           |
| frozen sets                        | `frozenset` | sets (collections)      | Non-primitive |         | X         |
| [functions](25.functions)          | `function`  | functions               | Non-primitive | X       |           |
| [`NoneType`](9.none)               | `NoneType`  | nulls                   | _--?--_       |         | X         |

### Literals

Is any syntactic notation used to represent an object in source code. 

These are the literals in Python:

```python
'Hello, world!'   # str literal
3.141592          # float literal
True              # bool literal
{'a': 1, 'b': 2}  # dict literal
[1, 2, 3]         # list literal
(4, 5, 6)         # tuple literal
{7, 8, 9}         # set literal
```

Not all objects have literal forms, for those the **type constructor** is used to create objects of the type:

```python
range(10)         # Range of numbers: 0-9
range(1, 11)      # Range of numbers: 1-10
set()             # Empty set
frozenset([1, 2]) # Frozen set of values: 1 and 2
```

## 2.) Type Coercions

### What is it?

* Is the process of converting a value from one data type, implicitly or explicitly, to another data type.
* operations between values of the same type in Python don't require coercion.
* `print()` function implicitly converts any value to a string but this is not considered coercion.

### **Implicit Coercion**

* Is one Python automatically transforms one data type into another, without any specific instruction.
* When we use the `print()` function, Python automatically converts the value to a string using the `str()` function. `print()` isn't considered to be coercion. While it does coerce its arguments to strings, that is done behind the scenes. It doesn't return the resulting strings; it just prints them.

#### Combining Integer with Float

* Implicit coercion occurs when doing a calculation that involves an integer and a float. Python automatically coerces the integer to a float, producing a float.

```python
x = 3          # Integer
y = 2.0        # Float

result = x + y
print(result)  # Outputs: 5.0
print(type(result))  # Outputs: <class 'float'>
```

#### Combining String with Non-string

- if you try to use the `+` operator with a string and a number, Python will raise a `TypeError`.

#### Combining Booleans with Numbers

* Python implicitly coerces `True` to the integer value 1 and `False` to 0:

```python
print(True + True + True)     # 3
print(True + 1 + 1.0)         # 3.0
print(False * 5000)           # 0
```

#### Truthiness Coercion

* Python can use any value, regardless of type, in a conditional expression in an `if` or `while` statement.

```python
# These are all falsy values
bool(False)  # False
bool(0)      # False
bool("")     # False
bool([])     # False
bool({})     # False
bool(None)   # False

# Everything else is truthy
bool(42)     # True
bool("hello")  # True
bool([1, 2])   # True
```

### **Explicit Coercion**

* Is when we intentionally transform the value of a data type into another with the use of built-in functions, such as `int()`, `float()`, `str()`.

#### Coercing values to integers

* The `int()` function coerces a value to an integer.
* Trying to convert a non-numeric string or a numeric string that does not represent an integer value to an integer will raise a `ValueError`
* Passing any other data type, like a `list` for example will result in a `TypeError`.

```python
print(int('10'))            # 10
print(int(10.0))            # 10
print(int('3.1415'))      # ValueError: invalid literal for int()
```

#### Coercing values to floats

* The `float()` function is used to convert values to floating-point numbers.
* Attempting to convert a non-numeric string to a float using `float()` will raise a `ValueError`.
* If we pass any other data type, other than `string`, a real number, bytes-type object, and a boolean to it, it will raise a `TypeError`.
* Floats have a special **"Not-a-Number"** value `nan`. Not-a-Number is one of the common ways to represent the missing value in the data. It typically arises from operations that don't have a meaningful result.

```python
float_str = "3.14"
float_number = float(float_str)
print(float_number)  # Output: 3.14
```

```python
result = float('inf') - float('inf')
print(result) # nan
```

```python
nan_string = "NaN"
nan_float = float(nan_string)

print(nan_float)  # Output: nan
```

#### Coercing values to Strings

* The `str()` function coerces values to strings.
* `str()` can convert most Python values to a valid String
* String interpolation is a common technique for including values within a string. When you use interpolation, Python automatically coerces the values to strings using the `str()` function.


```python
print(str(10))         # '10'
print(str(3.1415))     # '3.1415'
```

#### Coercing values to Booleans

- The `bool()` function is used to convert values to booleans. It works with all built-in Python values and most non-built-in values.
- It returns `True` if the value is truthy (evaluates to `True` in a boolean context), and `False` if the value is falsy (evaluates to `False` in a boolean context).

```python
truthy_value = "Hello"
falsy_value = None

is_truthy = bool(truthy_value)
is_falsy = bool(falsy_value)

print(is_truthy)  # Output: True
print(is_falsy)   # Output: False
```

### `repr()` vs `str()`

- `str()`: This function is used to create a string representation of an object that is meant to be human-readable. It focuses on providing a concise and user-friendly representation of the object's value. It is often used for display purposes, such as in `print()` and string interpolation.
- `repr()`: This function is used to create an unambiguous string representation of an object that can be used to recreate the object. It is often used for debugging and development purposes. The `repr()` representation should ideally be a valid Python expression that, when evaluated, would recreate the original object.

```python
import datetime

today = datetime.datetime.now()
print(str(today)) # 2023-08-10 10:18:05.535262
print(repr(today)) # datetime.datetime(2023, 8, 10, 10, 18, 5, 535262)
```
### Determining Types

- `type()` function determines the type of an object:

```python
print(type(1))         # <class 'int'>
print(type(3.14))      # <class 'float'>
print(type(True))      # <class 'bool'>
print(type('abc'))     # <class 'str'>
print(type([1, 2, 3])) # <class 'list'>
print(type(None))      # <class 'NoneType'>

foo = 42               # Variables work, too
print(type(foo))       # <class 'int'>
```

- If you want the class name, you can access the `__name__` property from the result:

```python
print(type('abc').__name__)   # str
print(type(False).__name__)   # bool
print(type([]).__name__)      # list
```

- You can use `type` with the `is` operator (doesn't take inheritance into account):

```python
print(type('abc') is str)     # True
print(type('abc') is int)     # False
print(type(False) is bool)    # True
print(type([]) is list)       # True
print(type([]) is set)        # False
```

- Consider using the `isinstance` function, which determines whether an object is an instance of a particular type. It takes inheritance into account:

```python
print(isinstance('abc', str))    # True
print(isinstance([], set))       # False

class A:
    pass

class B(A):
    pass

b = B()

print(type(b).__name__) # B
print(type(b) is B)     # True
print(type(b) is A)     # False (b's type is
                        # not A)
print(isinstance(b, B)) # True
print(isinstance(b, A)) # True (b is instance of A and B)
```


## 3.) Numbers

### Number types

* **Integers**​: Whole numbers without decimals (`42`, `-7`)
* **Floating-Point**​: Numbers with decimals (`3.14`, `-0.5`)
* **Complex Numbers**​: Numbers with real and imaginary parts (`3+4j`)

### Integers

- Data Type: `int`
- Can't use commas or periods for grouping: `123,456,789` nor `123.456.789`.
- Can write the number without separators or break up the number with underscores: `123_456_789`. 

### Floats

- Data Type: `float`
- Can't use commas or periods for grouping: `42,348,912.346` nor `42.348.912,346`.
- Can write the number without separators or break up the number with underscores: `42_348.912_346`.

### Truthiness of Numbers

* Zero values (`0`, `0.0`) are falsy  
* All other numeric values are truthy

### Type Conversion

* ​**Explicit**​: Using `int()`, `float()`, `complex()`  
* **Implicit**​: Happens automatically in mixed operations (integers convert to floats)

### Number Functions

* `abs()`: Absolute value
* `round()`: Rounding
* `max()`, `min()`: Finding maximum/minimum

## 4.) Strings

### Basics

* **Strings** are an immutable sequence of Unicode characters
* String **literals** can be written with a single `('string')` or double `("string")` quotes
* Triple quotes `('''string''')` or `("""string""")` for multi-line strings
* Empty strings are created with `''` or `""`
* **Text sequences** are strings of characters.
* The difference between a **Text sequence** and an **ordinary sequence** is that the **ordinary sequence** contain zero or more objects, while the **text sequence** does not contain any objects: only contains the characters (which are not objects in itself) that make up the text sequence.

### String Operations

•   ​**Concatenation**​: Using the `+` operator (`"hello" + " world"`)  
•   ​**Repetition**​: Using the `*` operator (`"ha" * 3` produces `"hahaha"`)  
•   ​**Indexing**​: Access individual characters (`text[0]`)  
•   ​**Slicing**​: Extract substrings (`text[1:4]`)  
•   ​**Length**​: Using `len()` function (`len("hello")` returns `5`)

### String Methods

•   ​**Case manipulation**​: `upper()`, `lower()`, `capitalize()`, `title()`, `swapcase()`  
•   ​**Testing**​: `isalpha()`, `isdigit()`, `isalnum()`, `isspace()`, `isupper()`, `islower()`  
•   ​**Searching**​: `find()`, `rfind()`, `index()`, `rindex()`, `count()`  
•   ​**Modification**​: `replace()`, `strip()`, `lstrip()`, `rstrip()`, `split()`, `join()`

### String Formatting

•   ​**f-strings**​: `f"Hello, {name}!"` (interpolates variables and/or expressions)  
•   ​**format() method**​: `"Hello, {}!".format(name)`  
•   ​`%` **operator**​: `"Hello, %s!" % name` (older style)

### Indexing Strings

- To access the individual characters in a string, use the `[ ]` **indexing syntax**.
- The value between the brackets must be an integer between 0 and the length of the string minus 1:

```python
>>> my_str = 'abc' 
>>> my_str[0]
a 
>>> my_str[1] 
b 
>>> my_str[2]
c
```

- You can also use negative integers to access characters based on the distance from the end of the string. For instance, `my_str[-1]` returns the last character in the string, while `my_str[-2]` returns the next to last character. The index of the first character is given by `-len(my_str)`:

```python
>>> my_str = 'abc'
>>> my_str[-1]
c
>>> my_str[-2]
b 
>>> my_str[-3]
a
```

### String Representations

- `str` and `repr` return a string representation of any object.
- `str` output is intended for human readability.
- `repr` is lower-level and returns a string that can be use to create a new instance of the object.

```python
my_str = 'abc'
print(my_str)       # abc
print(str(my_str))  # abc (same as print(my_str))
print(repr(my_str)) # 'abc' (note the quotes)
```

### Important Concepts

* Strings are ​[**passed by object reference**](20.pass_by_object_reference.md)​ to functions
* String methods ​**return new strings**​ rather than modifying existing ones
* String comparisons use **lexicographical (dictionary) ordering**
* Escape sequences like `\n`, `\t`, and `\\` for special characters

### Lexicographical (dictionary) ordering

When we talk about lexicographical ordering in string comparisons, we're referring to how Python determines whether one string is "greater than," "less than," or "equal to" another string. This is similar to how words are ordered in a dictionary (hence the term "dictionary ordering").

#### How Lexicographical Comparison Works?

When Python compares two strings using operators like `<`, `>`, `==`, `!=`, `<=`, or `>=`, it does so character by character, from left to right:

1.  Python compares the first character of each string using their Unicode code points  
2.  If they differ, the comparison result is determined immediately  
3.  If they're the same, Python moves to the next character and repeats the process  
4.  If one string is a prefix of the other (meaning it runs out of characters first), the shorter string is considered "less than" the longer one

* Python compares strings character-by-character from left to right in both strings. The comparison stops as soon as Python reaches a decision.
- `'abcdef' > 'abc'`. In this example, the strings have unequal sizes. Furthermore, the longer string is identical up to the shorter string's length. Python returns `True` here; when it can no longer take characters from the shorter string, it concludes that the longer string has the greater value. Similar behaviors occur with the other ordered comparison operators.
- It's also worth noting that even numeric strings are compared character by character. Thus, `'3' > '24'` returns `True` since the character `3` is greater than the character `2`.
- In general, numeric characters in a string are less than alphabetic characters, and uppercase letter characters are less than lowercase letters.

#### Unicode Ordering

The comparison is based on the Unicode code point (numerical value) of each character. In ASCII/Unicode:

•   Uppercase letters (`A-Z`) come before lowercase letters (`a-z`)  
•   Digits (`0-9`) come before letters  
•   Special characters have their own ordering
### Examples

```python
# String operations
name = "Python is cool"
greeting = "Hello, " + name + "!"  # 'Hello, Python is cool!'
repeated = name * 3  # Repetition: "Python is coolPython is coolPython is cool"

# Indexing and slicing
first_char = name[0]  # 'P'
substring = name[1:4]  # 'yth'

# String methods (Case Manipulation)
upper_name = name.upper()  # 'PYTHON IS COOL'
lower_name = name.lower()  # 'python is cool'
capitalize_name = lower_name.capitalize() # 'Python is cool'
title_name = name.title()  # 'Python Is Cool'
swapcase_name = name.swapcase() # 'pYTHON IS COOL'

# String methods (Testing)
has_alpha = name.isalpha()  # False (there are spaces in the String)
has_digits = name.isdigit()  # False
has_alnum = name.isalnum()   # False
is_space = name.isspace()    # False
is_upper = name.isupper()    # False
is_lower = name.islower()    # False

# String methods (Searching)
position = name.find('th')  # 2 (returns -1 if not found)
rfind = name.rfind('o')     # 12 (Highest Index)
idx = name.index('th')      # 2 (like find but raises ValueError if not found)
ridx = name.rindex('o')     # 12
count = name.count('o')     # 3

# String Modification
replace_name = name.replace('Python', 'JavaScript') # JavaScript is cool
new_name = " Python is cool "
strip = name.strip() # 'Python is cool'
lstrip = name.strip() # 'Python is cool '
rstrip = name.rstrip() # ' Python is cool'
split = name.split() # ['Python', 'is', 'cool']
split_join = ' '.join(split) # 'Python is cool'

# String formatting
age = 30
message = f"{name} is {age} years old"
```



## 5.) F-Strings

### Raw Strings and F-Strings

* String literals with an `r` prefix are **raw string literals**. Raw string literals don't recognize escapes, so you can use literal `\` characters freely.

```python
# Both of these print C:\Users\Xyzzy
print("C:\\Users\\Xyzzy")  # Each \\ produces a literal \
print(r"C:\Users\Xyzzy")  # raw string literal
```

* String literals with an `f` are **formatted string literals** or **f-strings**. These enable a way, via **string interpolation**, to embed expressions inside string literals.

```python
>>> f'5 plus 5 equals {5 + 5}.' 
'5 plus 5 equals 10.' 
>>> my_name = 'Karl' 
>>> f'My name is {my_name}.' 
'My name is Karl.' 
>>> my_name = 'Clare' 
>>> greeting = 'Ey up?' 
>>> f'{greeting} My name is {my_name}.' 
'Ey up? My name is Clare.
```

### Basic syntax

F-strings begin with the letter `f` or `F` before the opening quotation mark:

```python
name = "Ivan"  
profession = "programmer"  
greeting = f"Hello, {name}. You are a {profession}."
```

The expressions inside the curly braces `{}` are evaluated at runtime and converted to strings.

### Advantages of F-strings

1.  ​**Readability**​: They're more concise and easier to read than other formatting methods  
2.  ​**Performance**​: F-strings are generally faster than `str.format()` and `%` formatting  
3.  ​**Direct expression evaluation**​: You can put any valid Python expression inside the braces

### Comparison with `str.format()`

```python
name = "Ivan"  
profession = "programmer" 
greeting = "Hello, {}. You are a {}.".format(name, profession)
```

F-strings typically make your code more readable, especially with multiple variables.

### Advanced Features

You can also include formatting specifications within f-strings:

```python
pi = 3.14159  
print(f"Pi rounded to 2 decimal places: {pi:.2f}")
```



## 6.) String Methods

### Casing Methods

#### `upper()`

Converts string to uppercase

```python
first_name = "Ivan"
print(first_name.upper())    # IVAN
```

#### lower()

Converts string to lowercase

```python
last_name = "Hernandez"
print(last_name.lower())     # hernandez
```

#### `capitalize()`

Capitalizes first character of string and the rest lowercased

```python
city = "caracas"
print(city.capitalize())      # Caracas
```

#### `title()`

Converts first character of each word to uppercase

```python
book_title = "cien años de soledad"
print(book_title.title()).   # Cien Años De Soledad
```

#### ```swapcase()```

Return a copy of the string with uppercase characters converted to lowercase and vice versa.

```python
first_name = "Ivan"
print(first_name.swapcase())        # "iVAN"
```

### Search Methods

#### `str.find(sub)`

Returns lowest index where substring is found, or -1 if not found

```python
string = "Hello, World!"
print(string.find('o'))             # 4
print(string.find('x'))             # -1
```

#### `str.rfind(sub)`

Returns the highest index where the substring is found, or -1 if not found

```python
name = "Python is cool"
rfind = name.rfind('o')     # 12 (Highest Index)
```

#### `str.index(sub)`

Like find, but raises `ValueError` if substring not found

```python
string = "Hello, World!"
print(string.index('o'))             # 4
print(string.index('x'))             # ValueError
```

#### `str.rindex(sub)`

Like `rfind` but raises `ValueError` if substring not found

```python
name = "Python is cool"
rfind = name.rindex('o')     # 12 (Highest Index)
```

#### `str.count(sub)`

Counts occurrences of substring

```python
string = "Hello, World!"
print(string.count('o'))        # 2
```

### Check Methods

#### `str.startswith(prefix)` 

Checks if string starts with prefix

```python
string = "Today is a great day"
print(string.startswith('T'))   # True
```

#### `str.endswith(suffix)` 

 Checks if string ends with suffix

```python
string = "Today is a great day"
print(string.endswith('day'))    # True
```

#### `str.isalpha()` 

Checks if all characters are alphabetic

```python
string = "Today is a great day"
print(string.isalpha())        # False
string2 = "TodayIsAGreatDay"
print(string2.isalpha())       # True
```

#### `str.isdigit()` 

Checks if all characters are digits

```python
string = '12345'
print(string.isdigit())      # True
```

#### `str.isalnum()` 

Checks if all characters are alphanumeric

```python
string = "TodayIs2Good2BeTrue"
print(string.isalnum())       # True
```

#### `str.isspace()` 

Checks if all characters are whitespace

```python
string = " "
print(string.isspace())     # True
```

#### `str.islower()`

Check if all characters are in lower case

```python
string = 'hello world'
print(string.islower())    # True
```

#### `str.isupper()`

Check if all characters are in upper case

```python
string = "HELLO WORLD"
print(string.isupper())   # True
```
### Manipulation Methods

#### `str.strip()`

Removes leading and trailing whitespace (or specified characters)

```python
string = " Hello "
print(string.strip())   # Hello

string2 = "%Hello%"
print(string2.strip('%'))  # Hello
```

#### `str.lstrip()`

Removes leading whitespace (or specified characters)

```python
string = " Hello "
print(string.lstrip())   # Hello

string2 = "%Hello%"
print(string2.lstrip('%')) #Hello%
```

#### `str.rstrip()`

Removes trailing whitespace (or specified characters)

```python
string = "%Hello%"
print(string.rstrip('%'))    # %Hello
```

#### `str.replace(old, new)`

Replaces occurrences of 'old' with 'new'

```python
string = "Good Morning"
print(string.replace("Morning", "Afternoon"))  # Good Afternoon
```

#### `str.split(sep)`

Splits string by separator into a list

```python
string = "Good Morning Vietnam"
print(string.split())   # ["Good", "Morning", "Vietnam"]
```

#### `str.join(iterable)`

Joins elements of an iterable with the string as separator

```python
lst = ["Good", "Morning", "Vietnam"]
print(' '.join(lst)) # Good Morning Vietnam
```

## 7.) Boolean vs. Truthiness

### Boolean values

- `True`
- `False`

These are Boolean objects that you can assign to variables, pass as arguments, and return from functions.

### Truthiness

* Is a concept that refers to how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.
* Python can evaluate objects and values as either **truthy** or **falsy**.
- Truthiness arises in conditional expressions, such as `if` and `while` statements. Conditional expressions don't need to produce Boolean values. Instead, Python only needs to determine their truthiness. In an `if` statement, a conditional expression that evaluates as truthy causes the `if` block to execute. The `else` or `elif` block runs when the expression evaluates as falsy.

#### Python's built-in **falsy** values:

- `False`
- all numeric `0` values (integers, floats, complex)
- `None`
- `''` or `""`
- empty collections: `[]`, `{}`, `()`, `set()`, `frozenset()` and `range(0)`
- Custom data types can also define additional falsy values.

#### Python's **truthy** values:

- Anything that is not in the **falsy** list

### Truthiness and Short-Circuit Evaluation

- Logical operators don't always return `True` or `False`.
- They only care about the truthiness of their operands. 
- In each case, they evaluate as the object that evaluates last in the expression.

```python
print(3 and 'foo')   # last evaluated op: 'foo'
print('foo' and 3)   # last evaluated op: 3
print(0 and 'foo')   # last evaluated op: 0
print('foo' and 0)   # last evaluated op: 0

print(3 or 'foo')    # last evaluated op: 3
print('foo' or 3)    # last evaluated op: 'foo'
print(0 or 'foo')    # last evaluated op: 'foo'
print('foo' or 0)    # last evaluated op: 'foo'
print('' or 0)       # last evaluated op: 0
print(None or [])    # last evaluated op: []
```



## 8.) `None`

- Express the absence of a value.
- Data Type: `NoneType`
- Literal: `None`
- `None` **is a singleton object**​ - There is only one `None` object in Python.
- `None` **is falsy**​ - It evaluates to `False` in Boolean contexts
- Immutable
- **Implicit function returns**​ - Functions without an explicit `return` statement will return `None` by default.

### **Important Distinctions for PY109**

1. The difference between `None` and `False`: 
	-   `None` is the absence of a value, while `False` is a Boolean value  
	-  They are both falsy, but `None is not False`
	
2. When discussing function return values:  
    - Be specific about when a function returns `None`  
    - Distinguish between a function's output (what it prints) and its return value
   
3. Testing for `None`: 
	- Use `is None` or `is not None` rather than `== None` for identity comparison  
	- Remember that `None` is a singleton object



## 9.) Ranges

Are a built-in sequence type in Python used to represent a sequence of numbers.

### Basics

- A `range` object represents an immutable sequence of numbers
- Most commonly used in `for` loops to repeat actions a specific number of times
- Created using the `range()` function
- It's a non-primitive
- **`range(integer)`** doesn't produce the integers before a program ask for it. This optimizes memory. They are lazy sequences.

### Creating ranges

The `range()` function can be called with 1-3 arguments:

- `range(stop)`: Numbers from 0 up to but not including `stop`
- `range(start, stop)`: Numbers from `start` up to but not including `stop`
- `range(start, stop, step)`: Numbers from `start` up to but not including `stop`, incrementing by `step` 

### Key Characteristics

- Ranges are memory-efficient because they don't store all values in memory
- They're immutable (cannot be changed after creation)
- Support standard sequence operations like indexing, slicing, and iteration
- Can be converted to other sequences like lists with `list(range(...))`

### Examples

```python
>>> list(range(1, 10, 2))
[1, 3, 5, 7, 9]

>>> list(range(0, -5, -1))
[0, -1, -2, -3, -4]

# Basic range  
for i in range(5):  
    print(i)  # Prints 0, 1, 2, 3, 4

# With start and stop  
for i in range(2, 7):  
    print(i)  # Prints 2, 3, 4, 5, 6

# With step  
for i in range(1, 10, 2):  
    print(i)  # Prints 1, 3, 5, 7, 9

# Negative step (counting down)  
for i in range(10, 0, -1):  
    print(i)  # Prints 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
```



## 10.) List and Dictionary Syntax

### Lists and Tuples

#### Basics of Lists

- **Lists** are ordered, mutable collections that can store different types of data.
- **Lists** literals: `[]`
- The comma-delimited values are known as **elements**
- Use indexing syntax to retrieve specific elements.
- Use indexing syntax to reassign specific list elements. (**Element reassignment**)

##### Examples

```python
# Creating lists  
empty_list = []  
numbers = [1, 2, 3, 4, 5]  
mixed = [1, "hello", True, 3.14]  
  
# Accessing elements (zero-indexed)  
first_item = numbers[0]  # 1  
last_item = numbers[-1]  # 5  
  
# Slicing  
subset = numbers[1:4]  # [2, 3, 4]  
  
# Modifying lists  
numbers.append(6)       # adds 6 to the end  
numbers.insert(0, 0)    # inserts 0 at index 0  
numbers.remove(3)       # removes first occurrence of 3  
popped_item = numbers.pop()  # removes and returns last item  
numbers[0] = 99         # lists are mutable, can change elements
```

#### Basics of Tuples

- **Tuples** are ordered, immutable collections, often used for data that shouldn't change.
- **Tuples** literals = `()`

##### Examples

```python
# Creating tuples  
empty_tuple = ()  
single_item = (1,)      # comma is needed for single-item tuples  
coordinates = (10, 20)  
mixed_tuple = (1, "hello", True)  
  
# Accessing elements (same as lists)  
x = coordinates[0]      # 10  
  
# Attempting to modify will cause an error  
# coordinates[0] = 5    # TypeError: 'tuple' object does not support item assignment
```

#### Key Differences

- **Mutability**​: Lists can be modified after creation, tuples cannot.
- **Syntax**​: Lists use square brackets `[]`, tuples use parentheses `()`.
- **Performance**​: Tuples are slightly faster and use less memory.
- **Use cases**​: Lists for collections that change, tuples for data that shouldn't change.

#### Common Operations

```python
# Length  
len(numbers)              # number of items  
  
# Membership testing  
3 in numbers              # True if 3 is in numbers  
  
# Concatenation  
combined_list = [1, 2] + [3, 4]   # [1, 2, 3, 4]  
combined_tuple = (1, 2) + (3, 4)  # (1, 2, 3, 4)  
  
# Repetition  
repeated_list = [0] * 3   # [0, 0, 0]  
  
# Iteration  
for item in numbers:  
    print(item)  
      
# List comprehensions (lists only)  
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]  
  
# Unpacking  
a, b = coordinates       # a = 10, b = 20
```


### Mappings (Dictionaries)

#### Basics

- Maps are types that maintain an **unordered** collection of **key/value** pairs (also called elements or members).
- Maps are accessed by their keys.
- Each key is a unique identifier for a specific object in the mapping.
- The dictionary is the most common mapping in Python.
- Created using curly braces `{}` or the `dict()` constructor
- Dictionary or `dict` type.
- Dictionaries are mutable
- Elements are separated by commas. {key:value,...}
- You can access objects in a dict with the `[ ]` key access syntax
- You can use almost any immutable object as a key in a dict; it doesn't have to be a string
- The only significant requirement for keys is that they are hashable. immutable types are almost always hashable, while mutable types are almost always non-hashable.
- Tuples can be used as dictionary keys since they are immutable. However, this only applies if all the elements inside the tuple are also immutable and hashable. For example, a tuple that contains lists cannot be used as a dictionary key since lists are mutable and non-hashable, making the entire tuple non-hashable as well.
- The values in each key/value pair may be any object.

#### Creating Dictionaries

```python
# Empty dictionary 
empty_dict = {} 
# Dictionary with initial values 
student = {'name': 'John', 'age': 25, 'courses': ['Math', 'Science']}
```

#### Accessing Values

```python
student = {'name': 'John', 'age': 25}
print(student['name'])  # Output: John

# Using get() to avoid KeyError
print(student.get('grade', 'Not Found'))  # Output: Not Found
```

#### Modifying Dictionaries

```python
student = {'name': 'John', 'age': 25}
# Adding new key-value pairs
student['grade'] = 'A'
# Modifying existing values
student['age'] = 26
```

#### Iterating Through Dictionaries

```python
student = {'name': 'John', 'age': 25, 'grade': 'A'}

# Iterating through keys
for key in student:
    print(key)

# Iterating through key-value pairs
for key, value in student.items():
    print(f"{key}: {value}")
```

#### Dictionary Use Cases

During PY101, you likely used dictionaries for:

1.  Storing related data together  
2.  Creating lookup tables for values  
3.  Counting and tracking occurrences (e.g., character frequency in strings)  
4.  Representing more complex data structures

#### Common Patterns with Dictionaries

##### 1. Checking if a Key Exists:

```python
if 'name' in student:
    print("Name exists")
```

##### 2. Setting default values​: 

```python
# Using get()
value = student.get('grade', 'No grade assigned')

# Using setdefault()
student.setdefault('grade', 'N/A')  # Sets 'grade' to 'N/A' if it doesn't exist
```

##### 3. Dictionary comprehensions:

```python
# Create a dictionary of squares
squares = {x: x * x for x in range(6)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```





## 11.) List Methods

### Common List Methods

1. `append()` - Adds an element to the end of a list

```python
fruits = ["apple", "banana"] 
fruits.append("cherry") # fruits is now ["apple", "banana", "cherry"]
```

2. `extend()` - Adds all elements from another iterable to the end of the list

```python
fruits = ["apple", "banana"]
more_fruits = ["cherry", "orange"]
fruits.extend(more_fruits)  # fruits is now ["apple", "banana", "cherry", "orange"]
```

3. `insert()` - Adds an element at a specific position

```python
fruits = ["apple", "banana"] 
fruits.insert(1, "orange") # fruits is now ["apple", "orange", "banana"]
```

4. `remove()` - Removes the first occurrence of a specified value

```python
fruits = ["apple", "banana", "apple"] 
fruits.remove("apple") # fruits is now ["banana", "apple"]
```

5. `pop()` - Removes and returns the element at a specified position (or the last element if no index is provided)

```python
fruits = ["apple", "banana", "cherry"] 
last_fruit = fruits.pop() # last_fruit = "cherry", fruits = ["apple", "banana"]
first_fruit = fruits.pop(0) # first_fruit = "apple", fruits = ["banana"]
```

6. `clear()` - Removes all elements from the list

```python
fruits = ["apple", "banana"] 
fruits.clear() # fruits is now []
```

7. `index()` - Returns the index of the first occurrence of a specified value

```python
fruits = ["apple", "banana", "cherry"] 
index = fruits.index("cherry") # index = 2
```

8. `count()` - Returns the number of elements with the specified value

```python
fruits = ["apple", "banana", "apple"] 
count = fruits.count("apple") # count = 2
```

9. `sort()` - Sorts the list in-place

```python
fruits = ["cherry", "apple", "banana"] 
fruits.sort() # fruits is now ["apple", "banana", "cherry"]
```

10. `reverse()` - Reverses the order of elements in the list

```python
fruits = ["apple", "banana", "cherry"] 
fruits.reverse() # fruits is now ["cherry", "banana", "apple"]
```

11. `copy()` - Returns a shallow copy of the list

```python
fruits = ["apple", "banana"]  
fruits_copy = fruits.copy()  # fruits_copy = ["apple", "banana"]
```



## 12.) Dictionary Methods

### Creating Dictionaries

```python
# Empty dictionary
empty_dict = {}
empty_dict = dict()

# Dictionary with initial values
student = {'name': 'John', 'age': 25, 'courses': ['Math', 'Science']}
```

### Accessing Values

```python
student = {'name': 'John', 'age': 25}
print(student['name'])  # John

# Using get() to safely access keys (returns None if key doesn't exist)
print(student.get('grade'))  # None
print(student.get('grade', 'Not Found'))  # Not Found (custom default)
```

### Modifying Dictionaries

```python
student = {'name': 'John', 'age': 25}

# Adding or updating values
student['grade'] = 'A'
student['age'] = 26

# Update multiple key-values at once
student.update({'age': 27, 'grade': 'B', 'school': 'Launch School'})
```

### Removing Items

```python
student = {'name': 'John', 'age': 25, 'grade': 'A'}

# Remove specific key and return its value
age = student.pop('age')  # age = 25

# Remove and return the last inserted item (Python 3.7+ preserves insertion order)
last_item = student.popitem()  # ('grade', 'A')

# Clear all items
student.clear()  # {}

# Delete a specific key
del student['name']
```

### Methods for Iteration

```python
student = {'name': 'John', 'age': 25, 'grade': 'A'}

# Get all keys
keys = student.keys()

# Get all values
values = student.values()

# Get all key-value pairs as tuples
items = student.items()

# Iterating through a dictionary
for key in student:
    print(f"{key}: {student[key]}")

# Iterating through key-value pairs
for key, value in student.items():
    print(f"{key}: {value}")
```

### Other Useful Dictionary Methods

```python
# Copy a dictionary
student_copy = student.copy()

# Create a new dictionary with specified keys and default value
new_dict = dict.fromkeys(['name', 'age', 'grade'], 'Unknown')

# Check if a key exists
'name' in student  # True
'address' in student  # False

# Get length of dictionary
len(student)  # Number of key-value pairs
```



## 13.) Slicing

Slicing allows you to extract parts of sequences like strings, lists, and tuples.

### Syntax

```python
sequence[start:stop:step]
```

- `start`: The index where the slice begins (inclusive)
- `stop`: The index where the slice ends (exclusive)
- `step`: The interval between elements (default is 1)

All three parameters are optional:

```python
my_list[2:5]    # From index 2 up to (but not including) index 5
my_list[:5]     # From beginning up to (but not including) index 5
my_list[2:]     # From index 2 to the end
my_list[:]      # A copy of the entire sequence
my_list[::2]    # Every second element
```

### Negative Indices

Python allows negative indices, which count from the end:

```python
my_string = "Python"
my_string[-3:]   # "hon" (last 3 characters)
my_string[:-2]   # "Pyth" (all except last 2 characters)
```

### Reverse Slicing

You can use a negative step to reverse the direction:

```python
my_list = [1, 2, 3, 4, 5]
my_list[::-1]    # [5, 4, 3, 2, 1] (reversed list)
my_list[4:1:-1]  # [5, 4, 3] (from index 4 to index 2, reversed)
```

### Common Applications

1. Extracting substrings: `name = "Launch School"; first_name = name[:6]`
2. Creating copies of sequences: `new_list = original_list[:]`
3. Reversing sequences: `reversed_string = my_string[::-1]`
4. Removing elements from start/end: `without_first_two = my_list[2:]`

### Important Notes

- Slicing creates a new object; it doesn't modify the original
- Out-of-range indices in slices don't cause errors (unlike direct indexing)
- Slices can be used as targets for assignments: `my_list[1:3] = [10, 20]`
- You get an empty slice when the start and stop values are the same.
- Slicing performs a shallow copy if the sequence contains any collections (lists or tuples).

```python
seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(seq[3:7])       # [4, 5, 6, 7]
print(seq[-6:-2])     # [5, 6, 7, 8]
print(seq[2:8:2])     # [3, 5, 7]
print(seq[3:3])       # []
print(seq[:])         # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] => returns a duplicated sequence
print(seq[::-1])      # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] returns a reverse copy of a sequence

seq = [[1, 2], [3, 4]]
seq_dup = seq[:]
print(seq[0] is seq_dup[0])   # True
```


## 14.) Operators

### Arithmetic operators
#### Addition

```python
print(5 + 5)     # 25
print(5.0 + 5.0) # 10.0
# mixing integers and floats
print(5 + 5.0)   # 10.0
```

#### Subtraction

```python
print(5 - 5)     # 0
print(5.0 - 5.0) # 0.0
# mixing integers and floats
print(5 - 5.0)   # 0.0
```

#### Multiplication

```python
print(5 * 5)     # 25
print(5.0 * 5.0) # 25.0
# mixing integers and floats
print(5 * 5.0)   # 25.0
```

#### Division 

```python
print(15 / 3)   # 5.0
print(19 / 2.5) # 7.6
```

#### Integer Division (Floor Division)

```python
print(16 // 3)     # 5
print(16 // -3)    # -6
print(16 // 2.3)   # 6.0
print(-16 // 2.3)  # -7.0
```

- The `//` operator returns the largest whole number less than or equal to the floating point result. This is quite simple when you visualize a number line: -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6. Let's start at zero. Going right means the numbers _increase,_ whilst going left means the numbers _decrease_. So, integer division indeed returns the largest whole number _less than or equal to_ (<=) the floating-point result: 16//3 -> 5.33333...  -> 5 (because rounding 5.33333 _down_ gives us 5 (find the floating-point result on the number line and move _left_))So... now let's consider 16//-3.  16//-3 -> -5.33333... -> ? (well, if we consult our number line again, our dear -5 "sits" between -6 and -5. Which of these two numbers is _less_ (i.e. to the _left_)? Well, -6. So, this means rounding -5.33333... _down_ results in -6)

#### Exponentiation (powers)

```python
print(16 ** 3)     # 4096
```

#### Modulo

- The `%` operator is called the **modulo operator**.
- The result of the operation is called a modulus and not remainder.
- As long as both numbers have the same sign, modulo and remainder are equivalent operations.
- There is one situation where you can safely use `%` without worrying about negative numbers: when you only care about divisibility. If `x % y == 0`, then `x` is evenly divisible by `y`. It doesn't matter whether `x` or `y` is negative.

```python
# 15 // 3 is 5; what's the remainder?
print(15 % 3)   # 0
print(16 % 3)   # 1
print(17 % 3)   # 2
print(18 % 3)   # 0
```

#### Floating Point Imprecision

```python
print(0.1 + 0.2 == 0.3)       # False
```

- One way around the problem in Python is to use the `math.isclose` function:

```python
import math
math.isclose(0.1 + 0.2, 0.3)  # True
```

- You can also use the `decimal.Decimal` type to make precise computations:

```python
from decimal import Decimal
Decimal('0.1') + Decimal('0.2') == Decimal('0.3')
# True
```

- always use strings with `decimal.Decimal`. You can use float values. However, you will lose the benefit of precise computation if you do.

### String operators

#### String Concatenation

- Use `+` and `*` operators to join strings
```python
>>> 'foo' + 'bar'
'foobar'
```

```python
print('abc' * 3)              # 'abcabcabc'
print(3 * 'abc')              # 'abcabcabc'
```

### List Operators

### Comparison operators

- Comparison operators return a Boolean value: `True` or `False`.
- **Operands** are the expressions to the left and right of an operator.

#### The **equality operator** (`==`)

- The **equality operator** returns `True` when the operands have equal values, `False` otherwise.
- In most cases, operands must have the same type and value to be equal. Thus, `5` is not equal to `'5'`. There are some places where you can mix types, however. For instance, integers and floats that are mathematically equivalent are usually, but not always, considered equal:

```python
print(5 == float(5))                # True

big_num = 12345678901234567
print(float(big_num) == big_num)    # False
```

- While `casefold` is only needed when working with non-US characters, it's best practice in Python to use `casefold` instead of `lower` or `upper`, especially when comparing strings. **(Check this with LSBot**).

#### The **inequality operator** (`!=`)

- is `==`'s inverse: It returns `False` when `==` would return `True`, and `True` when `==` would return `False`. It returns `False` when the operands have the same type and value, `True` otherwise. Other than the return value, the behaviors of `==` and `!=` are identical.


#### The **less than operator** (`<`) and **less than or equal to operator** (`<=`)

- The **less than operator** (`<`) returns `True` when the value of the left operand has a value that is less than the value on the right, `False` otherwise. The **less than or equal to operator** (`<=`) is similar, but it also returns `True` when the values are equal; `<` returns `False` when the operands are equal.
- Python compares strings character-by-character, moving from left to right. It looks for the first character that differs from its counterpart in the other string. Once it finds differing characters, it compares them to determine the relationship. If both strings are equal up to the shorter string's length, as in the last two examples, the shorter one is considered less than the longer one.

```python
print('42' < '402')       # False
print('42' < '420')       # True
print('420' < '42')       # False
```

#### The **greater than operator** (`>`) and **greater than or equal to operator** (`>=`)

- The **greater than operator** (`>`) returns `True` when the value of the left operand has a value that is greater than the value on the right, `False` otherwise. The **greater than or equal to operator** (`>=`) is similar, but it also returns `True` when the values are equal; `>` returns `False` when the operands are equal.
- As with `<` and `<=`, you can compare strings with the `>` and `>=` operators; the rules are similar.

```python
print(42 < 41)           # False
print(42 < 42)           # False
print(42 <= 42)          # True
print(42 < 43)           # True

print('abcdf' < 'abcef') # True
print('abc' < 'abcdef')  # True
print('abcdef' < 'abc')  # False
print('abc' < 'abc')     # False
print('abc' <= 'abc')    # True
print('abd' < 'abcdef')  # False
print('A' < 'a')         # True
print('Z' < 'a')         # True

print('3' < '24')        # False
print('24' < '3')        # True
```

- Strings are compared **lexicographically**, meaning they are compared character-by-character from left-to-right. 
- Python compares strings character-by-character from left to right in both strings. The comparison stops as soon as Python reaches a decision.
- `'abcdef' > 'abc'`. In this example, the strings have unequal sizes. Furthermore, the longer string is identical up to the shorter string's length. Python returns `True` here; when it can no longer take characters from the shorter string, it concludes that the longer string has the greater value. Similar behaviors occur with the other ordered comparison operators.
- It's also worth noting that even numeric strings are compared character by character. Thus, `'3' > '24'` returns `True` since the character `3` is greater than the character `2`.
- In general, numeric characters in a string are less than alphabetic characters, and uppercase letter characters are less than lowercase letters.
- As with `==` and `!=`, many other types besides numbers and strings work with the ordered comparison operators. For instance, you can compare sets with these operators to determine if set a is a subset or superset of set b. You can also compare lists and tuples: like string comparisons, list and tuple comparison goes element by element to determine which object is less than or greater than the other:


```python
print({3, 1, 2} < {2, 4, 3, 1})         # True
print({3, 1, 2} > {2, 4, 3, 1})         # False
print({2, 4, 3, 1} > {3, 1, 2})         # True

print([1, 2, 3] < [1, 2, 3, 4])         # True
print([1, 4, 3] < [1, 3, 3])            # False
print([1, 3, 3] < [1, 4, 3])            # True
```

### Logical operators

#### `not`

- The **not operator** returns `True` when its operand is `False` and returns `False` when the operand is `True`. That is, it negates its operand.
- `not` takes a single operand; it appears to the operator's right. Operators that take only one operand are called **unary operators**. Operators that take two operands are **binary operators**.

#### `and` and `or`

- The **and operator** returns `True` when both operands are `True`. It returns `False` when either operand is `False`.
- The **or operator** returns `True` when either operand is `True` and `False` when both operands are `False`.
- The following **truth** table shows how `True` and `False` interact with the `and` and `or` operators:

| **A**   | **B**   | **A and B** | **A or B** |
| ------- | ------- | ----------- | ---------- |
| `True`  | `True`  | `True`      | `True`     |
| `True`  | `False` | `False`     | `True`     |
| `False` | `True`  | `False`     | `True`     |
| `False` | `False` | `False`     | `False`    |
### Short Circuits

- The `and` and `or` operators use a mechanism called **short circuit evaluation** to evaluate their operands.
- When Python evaluates these operators, it stops as soon as it can determine the final result, without necessarily evaluating all parts of the expression.
- For the `and` operator:
	- If the first operand is `falsy`, Python returns that value immediately without evaluating the second operand.
	- If the first operand is `truthy`, Python evaluates and returns the second operand.
- For the `or` operator:
	- If the first operand is `truthy`, Python returns the value immediately without evaluating the second operand.
	- If the first operand is `falsy`, Python evaluates and returns the second operand.

### Identity operators

- `is`: Returns True if both variables are the same object
- `is not`: Returns True if the variables are not the same object
### Operator Precedence

1.  Parentheses `()`  
2.  Exponentiation `**`  
3.  Unary operators `+x`, `-x`  
4.  Multiplication/division `*`, `/`, `//`, `%`  
5.  Addition/subtraction `+`, `-`

### Logical Operator precedence

- `==`, `!=`, `<=`, `<`, `>`, `>=` - Comparison
- `not` - Logical NOT
- `and` - Logical AND
- `or` - Logical OR
## 15.) Mutability and Immutability

### What is the definition of mutable/immutable?

* Mutable types are types whose objects can be changed after they are created.
* Immutable types cannot be changed after they are created.

### Mutable objects

Mutable objects can be modified after creation. In Python, these include:

- Lists
- Dictionaries
- Sets
- User-defined classes (by default)

### Immutable objects

Immutable objects cannot be modified after creation. In Python, these include:

- Integers
- Floats
- Strings
- Tuples
- Frozensets

Understanding mutability helps predict how your code will behave and is essential for avoiding unexpected side effects in your programs.


## 16.) Pass by Object Reference

This concept explains how arguments are handled when passing to functions. 

### What is it?

In Python, when you pass an argument to a function, you're actually passing a reference to the object, not the object itself. However, whether you can modify the original object depends on whether that object is mutable or immutable.

### Immutable objects

```python
def change_name(name):
    name = 'bob'  # reassignment

name = 'jim'
change_name(name)
print(name)  # Output: jim
```

In this example, the string `'jim'` is immutable. When the function tried to reassign the parameter `name`, it only modified the local variable inside the function, not the original variable outside the function.

Here Python behaves as if "Pass-by-Value"

### Mutable Objects

```python
def add_element(my_list):
    my_list.append([4])  # modifying the object

my_list = [1, 2, 3]
add_element(my_list)
print(my_list)  # Output: [1, 2, 3, [4]]
```

Here, the list is mutable, and when we use a method like `append()` that modifies the list in-place, the original list outside the function is also modified.

### Reassignment vs. Modification

```python
def add_element(my_list):
    my_list = my_list + [4]  # reassignment, not modification

my_list = [1, 2, 3]
add_element(my_list)
print(my_list)  # Output: [1, 2, 3]
```

In this case, even though lists are mutable, the operation `my_list = my_list + [4]` is a reassignment operation, not a modification. This creates a new list object and assigns it to the local variable `my_list`, without affecting the original list.

### The Key to Understanding

The behavior in Python is neither pure "pass by value" nor pure "pass by reference" - it's a hybrid approach called "pass by object reference." Here's what this means:

- Python always passes references to objects, never copies of the objects themselves
- For immutable objects (strings, numbers, tuples), you cannot modify the object itself
- For mutable objects (lists, dictionaries, sets), you can modify the object if you use methods that change the object in-place
- Reassignment of a parameter always creates a new local variable, regardless of whether the object is mutable or immutable



## 17.) Variables

### Definitions

- **Variables** are labels that point to values in memory
- **Identifiers** refer to: 
	- Variable and constant names
	- Function and method names
	- Function and method parameter names
	- Class and module names

### Naming Conventions

- Names that follow the naming conventions are called **idiomatic**
- Names that do not follow the naming conventions are called **non-idiomatic**
- Names that are not allowed are called **illegal**

#### Naming conventions for most identifiers (except constants and class names):

- Use **snake_case**.
- Names may contain: (`a-z`), (`0,9`) and (`_`).
- Names should begin with a letter.
- When using multiple words, separate them with a single (`_`).
- Names may only use letters and digits from the standard ASCII character set. (Extended ASCII and Unicode letters and digits are allowed, but are **non-idiomatic** )

#### Naming conventions for Constant names:

- Use **SCREAMING_SNAKE_CASE**.
- Names may contain: (`A-Z`), (`0,9`) and (`_`).
- Names should begin with a letter.
- When using multiple words, separate them with a single (`_`).
- Names may only use letters and digits from the standard ASCII character set. (Extended ASCII and Unicode letters and digits are allowed, but are **non-idiomatic** )

#### Naming conventions for Class names:

- Use **PascalCase**, also called **CamelCase** .
- Names may contain uppercase and lowercase letters (`A-Z, a-z`) and digits (`0-9`).
- Names should begin with an uppercase letter.
- When using multiple words, capitalize each word.

#### Illegal names:

- You may not use punctuation characters, most special characters, or whitespace.
- You may not start identifiers with a digit.
- You may not use Python's reserved words such as `if`, `def`, `while`, `return`, and `pass` as names.

### Creating and Reassigning Variables

- We create (**initialize**) a variable by simply giving it a value. That happens as part of an assignment statement:

```python
forename = 'Clare'            # initialization
```

- We can also give new values to variables by simply **reassigning** them:

```python
forename = 'Victor'           # reassignment
```

- Way to describe an assignment: The variable `foo`is assigned the value of `bar`.

### Creating Constants

- Constants are created (**initialized**) in the same way as variables: by giving them a value:

```python
PINING_FOR = 'fjords'         # initialization
```

- Constants should never be reassigned.
- Python does not support true constants. Instead, the **SCREAMING_SNAKE_CASE** naming convention is solely for programmers.

### Augmented Assignment

- It's a shorthand notation also called **assignment operators**, of the process of taking the current value of a variable, perform an operation on the variable's value, and then reassign the variable to the newly computed value.
- **Augmented assignment** is a statement, not an expression. You can't use augmented assignment as a function argument or return value

```python
foo = 42            # foo is 42
foo -= 2            # foo is now 40
foo *= 3            # foo is now 120
foo += 5            # foo is now 125
foo //= 25          # foo is now 5
foo /= 2            # foo is now 2.5
foo **= 3           # foo is now 15.625
print(foo)          # prints 15.625

def foo(bar):
    print(bar)

a = 3
foo(a *= 2)
#     ^^
# SyntaxError: invalid syntax

def foo():
    a = 3
    return a *= 2
#            ^^
# SyntaxError: invalid syntax
```

### Reassignment vs. Mutation

- There are two ways to change things in Python:
	- Change the **binding** of the variable by making it reference a new object (**Reassignment**)
	- Change the value of the object assigned (**bound**) to the variable (**Mutation**).
- **Reassignment** makes the variable name refer to a different object somewhere else in memory.
- **Mutation** does not change which object the variable refers to, instead it changes the object itself. After mutating an object assigned to a specific variable, the variable continues to refer to the same object (albeit altered) at the same memory location.
- **Reassigning** an element of a mutable collection doesn't reassign the variable; it mutates the collection.

```python
num = 3               # assignment (initialization)
my_list = [1, 2, 3]   # assignment (initialization)
my_dict = {           # assignment (initialization)
    'a': 1,
    'b': 2,
}

num = 42              # Reassignment
my_list[1] = 42       # Reassignment of element,
                      # my_list is mutated!
my_dict['b'] = 3      # Reassignment of dict pair
                      # my_dict is mutated!

# You can still reassign the variables
my_list = [2, 3, 4]   # Reassignment
my_dict = { 'x': 0 }  # Reassignment
```

### Variable Scope

Variable scope refers to the parts of a program where a variable can be accessed by name.

Python has two main types of scope:

#### Global scope

Variables defined outside of any function have global scope, meaning they can be accessed from anywhere in your program.

```python
num = 5  # Global variable

def my_func():
    print(num)  # Can access the global variable

my_func()  # Outputs: 5
```

#### Local scope

Variables defined inside a function have local scope, meaning they can only be accessed within that function.

```python
def my_func():
    local_var = 10  # Local variable
    print(local_var)

my_func()  # Outputs: 10
print(local_var)  # This would cause an error - local_var is not defined here
```


### `global` keyword

You can access global variables inside a function:

```python
num = 5

def my_func():
    print(num)  # Accessing is fine

my_func()  # Outputs: 5
```

But if you try to assign to a global variable inside a function, Python will create a new local variable instead:

```python
num = 5

def my_func():
    num = 10  # Creates a new local variable, not modifying the global one

my_func()
print(num)  # Still outputs: 5
```

To modify a global variable inside a function, use the `global` keyword:

```python
num = 5

def my_func():
    global num
    num = 10  # Now modifies the global variable

my_func()
print(num)  # Outputs: 10
```

### **Common Pitfall**

Be careful when you try to modify a global variable before declaring it as global:

```python
my_var = "Hello"

def my_func():
    my_var = my_var + " world"  # Error: UnboundLocalError
    return my_var

my_func()
```

This happens because Python sees the assignment to `my_var` and treats it as a local variable, but then tries to use it before it's been assigned a value.
### Variables as Pointers

In Python, variables don't actually contain values directly. Instead, they act as references or pointers to objects in memory.

#### **How Variables Work in Python**

When you create a variable in Python, what actually happens is:

1.  Python creates an object in memory to store the value  
2.  Python then associates the variable name with a reference (or pointer) to that object's location in memory

```python
number = 42
```

In this example, Python:
- Creates an integer object with value 42 in memory
- Associates the name 'number' with the memory location of that object

#### **Variable Assignment**

When you assign a value to a variable, you're creating a new reference:

```python
a = [1, 2, 3]  # 'a' points to a list object
b = a          # 'b' now points to the SAME list object
```

Both `a` and `b` point to the same list object in memory. This has important implications when working with mutable objects.

### **Mutability and References**

The pointer concept becomes especially important when considering mutable vs. immutable objects:

#### **With Mutable Objects (lists, dictionaries, sets):**

```python
a = [1, 2, 3]
b = a          # both variables point to the same list
b.append(4)    # modifies the list that both variables point to
print(a)       # Output: [1, 2, 3, 4]
```

When you modify a mutable object through one variable, the change is visible through all variables pointing to that object.

#### **With Immutable Objects (numbers, strings, tuples):**

```python
a = 5
b = a
b = 10         # creates a new integer object, reassigns b to point to it
print(a)       # Output: 5 (unchanged)
```

For immutable objects, any "modification" actually creates a new object and updates the reference.

#### **Checking Identity with `id()`**

You can verify that variables point to the same object using the `id()` function:

```python
a = [1, 2, 3]
b = a
print(id(a) == id(b))  # Output: True - they point to the same object
```


### Variable Shadowing

Variable shadowing occurs when a variable in an inner scope has the same name as a variable in an outer scope, effectively "hiding" or "shadowing" the outer variable.

```python
x = 10  # Global variable

def my_func():
    x = 20  # Local variable shadows the global variable
    print(f"Inside function: {x}")  # Accesses the local x

my_func()
print(f"Outside function: {x}")  # Accesses the global x
```

This code would output:

```python
Inside function: 20  
Outside function: 10
```

#### **Why This Happens**

In Python, when you assign a value to a variable inside a function without declaring it as `global`, Python creates a new local variable instead of modifying the global one. This new local variable with the same name "shadows" the global variable within that function's scope.

Consider this slightly more complex example:

```python
def my_func():
    x = 15  # Local to my_func
    
    def inner_func1():
        x = 25  # Local to inner_func1, shadows my_func's x
        print(f"Inner 1: {x}")
        
    def inner_func2():
        print(f"Inner 2: {x}")  # Uses my_func's x
        
    inner_func1()
    inner_func2()

my_func()
```

Output:

```python
Inner 1: 25
Inner 2: 15
```

- The variable `x` in `inner_func1` shadows the `x` from `my_func`
- `inner_func2` doesn't define its own `x`, so it accesses the `x` from the outer scope (`my_func`)

#### **Why Understanding Variable Shadowing Matters**

Variable shadowing is important to understand because:
- It can lead to unexpected behavior if you're not aware of it
- It makes your code harder to debug when variables with the same name exist in different scopes
- It's a common source of bugs for programmers new to Python's scoping rules

## 18.) Conditionals and Loops

## 19.) `print()` and `input()`

### Input/Output

#### Terminal Output

- `print`function: takes any value and prints it.
- The `print()` function works with all data types, but the formatting output is not always understandable to humans
- You can print multiple objects by just listing them one after the other as arguments to `print()`:

```python
>>> print(1, 2, 3, 'a', 'b')
1 2 3 a b

>>> print([1, 2, 3], 4, False, { 5, 6, 7, 8})
[1, 2, 3] 4 False {8, 5, 6, 7}
```

- keyword argument `sep` is used to separate the values printed.
- The `end` keyboard defines what `print()` prints after it prints the last argument. By default, it prints a newline (`\n`). The most common reasons for using `end` are compatibility with Windows (which sometimes needs a newline of `\r\n`) and for suppressing the newline altogether.

```python
>>> print(1, 2, 'a', 'b', sep=',', end=' <-\n')
1,2,a,b <-

>>> print('a', 'b', end='', sep=','); print('c', 'd', sep=',')
a,bc,d
```

- Note the semicolon (`;`) on line 4: that's an easy way to enter multiple statements on a single line. Mostly, you should only use semicolons like this in the REPL.

#### Terminal Input

- `input()` is a built-in function that lets Python read input from the terminal.

```python
number1 = input('Enter the first number: ')
number2 = input('Enter the second number: ')
sum = float(number1) + float(number2)

print(f'The numbers {number1} and {number2} add to {sum}')
```


## 20.) Exceptions

### **Key Points About Exceptions in Python**

1. **What They Are**​: Exceptions are events that occur during program execution that disrupt the normal flow of instructions.
2. **When They Occur**​: You should be able to identify common situations that trigger exceptions, such as:
	1. Attempting to divide by zero
	2. Accessing an index that doesn't exist in a sequence
	3. Using an undefined variable
	4. Type errors (trying operations with incompatible types)
	5. Value errors (passing inappropriate arguments to functions)
3. **How to Handle Them**​: You should understand exception handling using the try/except blocks:

```python
try:
       # Code that might cause an exception
except ExceptionType:
       # Code to run if that exception occurs
```

4. **Common Exception Types**​: Know the basic exception types like ValueError, TypeError, IndexError, KeyError, ZeroDivisionError, etc.


## 21.) Functions

## 22.) Expressions and Statements

- An **expression** produces a value that can be assigned to a variable, passed to a function or method, or returned by a function or a method.
- Examples of **expressions**:
	- Literals: `5`, `'Karl'`, `3.141592`, `True`, `None`
	- Variable references: `foo` or `name` when these variables have been previously defined.
	- Arithmetic operations: `x + y` or `a * b - 5`.
	- Comparison operations: `'x' == 'x'` or `'x' < 'y'`.
	- String operations: `'x' + 'y'` or `'x' * 32`.
	- Function calls: `print('Hello')` or `len('Python')`.
	- Any valid combination of the above that evaluates to a single object.
- A **statement** is an instruction that tells Python to perform an action. They don't return or produce values.
- Examples:
	- Assignment: like `x = 5`. This doesn't evaluate as a value; it assigns a value to a variable.
	- Control flow: such as `if`, `else`, `while`, `for`, and so on. These determine the flow of your program but don't evaluate as a value themselves.
	- Function and class definitions: using `def` or `class`.
	- Return statements: like `return x`, which tells a function to exit and return a value. `return` itself doesn't return a value; it informs the function what value it should return.
	- Import statements: such as `import math`.

Key differences:

- Expressions always return a value; statements do not.
- Expressions are often part of statements. For example, in the statement `y = x + 5`, here `x + 5` is an expression.
- Statements often represent bigger chunks of functionality like loops or conditionals; expressions deal with determining values.

Stand-alone expressions are both expressions and statements:

```python
3 + 4            # Simple expression
print('Hello')   # Function call; returns None
my_list.sort()   # Method call; returns None
```

**IMPORTANT**

```python
my_number = 3
```

The code snippet contains both a statement and an expression:

- `my_number = 3` is a statement that assigns the value `3` to the variable `my_number`.
- The value `3` itself is an expression. (Code appearing to the right of an `=` in an assignment or reassignment is an expression.)

### Expression Evaluation

- Python evaluates most expressions from left to right (when all operators are the same)
- When the operators are mixed, precedence rules are followed.
- Parentheses have the higher precedence.


## 23.) Naming Conventions


* **idiomatic**: Names that follow Python's style convention (PEP8).
* **non-idiomatic**: Names that are legal but do not follow the naming conventions
* **illegal**: Names that are either not allowed or are not syntactically correct.

### Legal vs. Idiomatic

* **Legal Names**  are syntactically valid and do not raise a syntax error.
* **Idiomatic Names**: are those that follow Python's style convention (Python Enhancement Proposals (PEP8)).

Not every variable name that is **legal** is **idiomatic**.

```python
# Legal but non-idiomatic
firstName = "Ivan"
FirstName = "Ivan"
LASTName = "Hernandez"

# Legal and idiomatic
first_name = "Ivan"
MY_CONSTANT = 10
class MyClass():
	pass
```

### Illegal vs. non-idiomatic

* **Illegal names** are those that will raise a syntax error, either because is syntactically incorrect or is a Python's reserved word.
* **Non-idiomatic** names are legal names that do not follow the Python's style convention (PEP8)

Not every **non-idiomatic** name is **illegal**.

```python
# Illegal names
1stName = "Ivan"
first-name = "Ivan"
pass = "I will"
```

### Illegal Names

* Punctuation characters, most special characters, and whitespaces are not allowed
* Names must not begin with a digit
* Python reserved words are not allowed: `if`, `def`, `while`, `for`, `return`, `class` and `pass`






### Escape Sequences

The concept demonstrated here is escape sequences in strings, which allow us to encode special characters into strings via escape notation that would be impossible to include in another way. Examples: newlines, carriage returns, tabs, etc.



### Truthiness

Is how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.











