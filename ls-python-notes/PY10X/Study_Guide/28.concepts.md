# Concepts with Examples

- [[#1.) Data Types]]
- [[#2.) Type Coercions]]
- [[#3.) Numbers]]
- [[#4.) Strings]]
- [[#5.) F-Strings]]
- [[#6.) String Methods]]
- [[#7.) Boolean vs. Truthiness]]
- [[#8.) `None`]]
- [[#9.) Ranges]]
- [[#Variables Naming Conventions]]
- [[#Constants Naming Conventions]]
- [[#Variable Scope]]
- [[#Assignment vs. Reassignment]]
- [[#Variables as Pointers]]
- [[#Variable Shadowing]]
- [[#Global keyword]]
- [[#Expressions vs. Statements]]
- [[#Mutability vs. Immutability]]
- [[#Operators]]
- [[#Conditionals Statements and Truthiness]]
- [[#Loops]]
- [[#F-strings]]
- [[#Escape Sequences]]
- [[#Function definition vs. Function invocation]]
- [[#Parameters vs. Arguments]]
- [[#Return Values vs. Side Effects]]
- [[#Nested Functions]]
- [[#Pass-by-Object-Reference]]
- [[#String Methods]]
- [[#List Methods]]
- [[#Dictionary Methods]]
- [[#Slicing]]
- [[#Exception Handling]]
- [[#Mutation vs Reassignment]]
- [[#Default Parameters]]
- [[#Implicit vs. Explicit return values]]
- [[#Truthiness]]


## 1.) Data Types

### Basics

- Everything with a value in Python is an **object**.
- Each **object** has a **type** and an associated **class**.
- A **primitive type** is the most fundamental type in a language.

### Data Types in Python

##### Core Data Types

###### **Primitive/Immutable Types:**

- **Integers**​: Whole numbers like `42`, `-7`, `0`
- ​**Floats**​: Decimal numbers like `3.14`, `-2.5`
- **Strings**​: Text enclosed in quotes: `'hello'`, `"Python"`
- **Booleans**​: `True` or `False` values

###### **Compound/Mutable Types:**

- **Lists**​: Ordered, mutable collections `[1, 2, 3]`
- **Dictionaries**​: Key-value pairs `{'name': 'Alice', 'age': 30}`
- **Sets**​: Unordered collections of unique elements `{1, 2, 3}`
- **Functions**

###### **Compound/Immutable Types:**

- **Tuples**​: Immutable sequences like `(1, 2, 3)`
- **Frozen Sets**: Unordered collections of unique elements `frozenset([1, 2, 3])`
- **ranges**: represent an immutable sequence of numbers `range(5)`
### Summary

Built-in data types:

| Data Type                          | Class       | Category                | Kind          | Mutable | Immutable |
| ---------------------------------- | ----------- | ----------------------- | ------------- | ------- | --------- |
| [[#Integers]]                      | `int`       | numerics                | Primitive     |         | X         |
| [[#Floats]]                        | `float`     | numerics                | Primitive     |         | X         |
| [boolean](8.boolean_vs_truthiness) | `bool`      | booleans                | Primitive     |         | X         |
| [strings](5.strings)               | `str`       | text sequences          | Primitive     |         | X         |
| [ranges](12.ranges.md)             | `range`     | sequences (collections) | Non-primitive |         | X         |
| [tuples](13.lists)                 | `tuple`     | sequences (collections) | Non-primitive |         | X         |
| [lists](13.lists)                  | `list`      | sequences (collections) | Non-primitive | X       |           |
| [dictionaries](15.dictionaries)    | `dict`      | mappings (collections)  | Non-primitive | X       |           |
| sets                               | `set`       | sets (collections)      | Non-primitive | X       |           |
| frozen sets                        | `frozenset` | sets (collections)      | Non-primitive |         | X         |
| [functions](25.functions)          | `function`  | functions               | Non-primitive | X       |           |
| [`NoneType`](9.none)               | `NoneType`  | nulls                   | _--?--_       |         | X         |

### Literals

Is any syntactic notation used to represent an object in source code. 

These are the literals in Python:

```python
'Hello, world!'   # str literal
3.141592          # float literal
True              # bool literal
{'a': 1, 'b': 2}  # dict literal
[1, 2, 3]         # list literal
(4, 5, 6)         # tuple literal
{7, 8, 9}         # set literal
```

Not all objects have literal forms, for those the **type constructor** is used to create objects of the type:

```python
range(10)         # Range of numbers: 0-9
range(1, 11)      # Range of numbers: 1-10
set()             # Empty set
frozenset([1, 2]) # Frozen set of values: 1 and 2
```

## 2.) Type Coercions

### What is it?

* Is the process of converting a value from one data type, implicitly or explicitly, to another data type.
* operations between values of the same type in Python don't require coercion.
* `print()` function implicitly converts any value to a string but this is not considered coercion.

### **Implicit Coercion**

* Is one Python automatically transforms one data type into another, without any specific instruction.
* When we use the `print()` function, Python automatically converts the value to a string using the `str()` function. `print()` isn't considered to be coercion. While it does coerce its arguments to strings, that is done behind the scenes. It doesn't return the resulting strings; it just prints them.

#### Combining Integer with Float

* Implicit coercion occurs when doing a calculation that involves an integer and a float. Python automatically coerces the integer to a float, producing a float.

```python
x = 3          # Integer
y = 2.0        # Float

result = x + y
print(result)  # Outputs: 5.0
print(type(result))  # Outputs: <class 'float'>
```

#### Combining String with Non-string

- if you try to use the `+` operator with a string and a number, Python will raise a `TypeError`.

#### Combining Booleans with Numbers

* Python implicitly coerces `True` to the integer value 1 and `False` to 0:

```python
print(True + True + True)     # 3
print(True + 1 + 1.0)         # 3.0
print(False * 5000)           # 0
```

#### Truthiness Coercion

* Python can use any value, regardless of type, in a conditional expression in an `if` or `while` statement.

```python
# These are all falsy values
bool(False)  # False
bool(0)      # False
bool("")     # False
bool([])     # False
bool({})     # False
bool(None)   # False

# Everything else is truthy
bool(42)     # True
bool("hello")  # True
bool([1, 2])   # True
```

### **Explicit Coercion**

* Is when we intentionally transform the value of a data type into another with the use of built-in functions, such as `int()`, `float()`, `str()`.

#### Coercing values to integers

* The `int()` function coerces a value to an integer.
* Trying to convert a non-numeric string or a numeric string that does not represent an integer value to an integer will raise a `ValueError`
* Passing any other data type, like a `list` for example will result in a `TypeError`.

```python
print(int('10'))            # 10
print(int(10.0))            # 10
print(int('3.1415'))      # ValueError: invalid literal for int()
```

#### Coercing values to floats

* The `float()` function is used to convert values to floating-point numbers.
* Attempting to convert a non-numeric string to a float using `float()` will raise a `ValueError`.
* If we pass any other data type, other than `string`, a real number, bytes-type object, and a boolean to it, it will raise a `TypeError`.
* Floats have a special **"Not-a-Number"** value `nan`. Not-a-Number is one of the common ways to represent the missing value in the data. It typically arises from operations that don't have a meaningful result.

```python
float_str = "3.14"
float_number = float(float_str)
print(float_number)  # Output: 3.14
```

```python
result = float('inf') - float('inf')
print(result) # nan
```

```python
nan_string = "NaN"
nan_float = float(nan_string)

print(nan_float)  # Output: nan
```

#### Coercing values to Strings

* The `str()` function coerces values to strings.
* `str()` can convert most Python values to a valid String
* String interpolation is a common technique for including values within a string. When you use interpolation, Python automatically coerces the values to strings using the `str()` function.


```python
print(str(10))         # '10'
print(str(3.1415))     # '3.1415'
```

#### Coercing values to Booleans

- The `bool()` function is used to convert values to booleans. It works with all built-in Python values and most non-built-in values.
- It returns `True` if the value is truthy (evaluates to `True` in a boolean context), and `False` if the value is falsy (evaluates to `False` in a boolean context).

```python
truthy_value = "Hello"
falsy_value = None

is_truthy = bool(truthy_value)
is_falsy = bool(falsy_value)

print(is_truthy)  # Output: True
print(is_falsy)   # Output: False
```

### `repr()` vs `str()`

- `str()`: This function is used to create a string representation of an object that is meant to be human-readable. It focuses on providing a concise and user-friendly representation of the object's value. It is often used for display purposes, such as in `print()` and string interpolation.
- `repr()`: This function is used to create an unambiguous string representation of an object that can be used to recreate the object. It is often used for debugging and development purposes. The `repr()` representation should ideally be a valid Python expression that, when evaluated, would recreate the original object.

```python
import datetime

today = datetime.datetime.now()
print(str(today)) # 2023-08-10 10:18:05.535262
print(repr(today)) # datetime.datetime(2023, 8, 10, 10, 18, 5, 535262)
```
### Determining Types

- `type()` function determines the type of an object:

```python
print(type(1))         # <class 'int'>
print(type(3.14))      # <class 'float'>
print(type(True))      # <class 'bool'>
print(type('abc'))     # <class 'str'>
print(type([1, 2, 3])) # <class 'list'>
print(type(None))      # <class 'NoneType'>

foo = 42               # Variables work, too
print(type(foo))       # <class 'int'>
```

- If you want the class name, you can access the `__name__` property from the result:

```python
print(type('abc').__name__)   # str
print(type(False).__name__)   # bool
print(type([]).__name__)      # list
```

- You can use `type` with the `is` operator (doesn't take inheritance into account):

```python
print(type('abc') is str)     # True
print(type('abc') is int)     # False
print(type(False) is bool)    # True
print(type([]) is list)       # True
print(type([]) is set)        # False
```

- Consider using the `isinstance` function, which determines whether an object is an instance of a particular type. It takes inheritance into account:

```python
print(isinstance('abc', str))    # True
print(isinstance([], set))       # False

class A:
    pass

class B(A):
    pass

b = B()

print(type(b).__name__) # B
print(type(b) is B)     # True
print(type(b) is A)     # False (b's type is
                        # not A)
print(isinstance(b, B)) # True
print(isinstance(b, A)) # True (b is instance of A and B)
```


## 3.) Numbers

### Number types

* **Integers**​: Whole numbers without decimals (`42`, `-7`)
* **Floating-Point**​: Numbers with decimals (`3.14`, `-0.5`)
* **Complex Numbers**​: Numbers with real and imaginary parts (`3+4j`)

### Integers

- Data Type: `int`
- Can't use commas or periods for grouping: `123,456,789` nor `123.456.789`.
- Can write the number without separators or break up the number with underscores: `123_456_789`. 

### Floats

- Data Type: `float`
- Can't use commas or periods for grouping: `42,348,912.346` nor `42.348.912,346`.
- Can write the number without separators or break up the number with underscores: `42_348.912_346`.

### Truthiness of Numbers

* Zero values (`0`, `0.0`) are falsy  
* All other numeric values are truthy

### Type Conversion

* ​**Explicit**​: Using `int()`, `float()`, `complex()`  
* **Implicit**​: Happens automatically in mixed operations (integers convert to floats)

### Number Functions

* `abs()`: Absolute value
* `round()`: Rounding
* `max()`, `min()`: Finding maximum/minimum

## 4.) Strings

### Basics

* **Strings** are an immutable sequence of Unicode characters
* String **literals** can be written with a single `('string')` or double `("string")` quotes
* Triple quotes `('''string''')` or `("""string""")` for multi-line strings
* Empty strings are created with `''` or `""`
* **Text sequences** are strings of characters.
* The difference between a **Text sequence** and an **ordinary sequence** is that the **ordinary sequence** contain zero or more objects, while the **text sequence** does not contain any objects: only contains the characters (which are not objects in itself) that make up the text sequence.

### String Operations

•   ​**Concatenation**​: Using the `+` operator (`"hello" + " world"`)  
•   ​**Repetition**​: Using the `*` operator (`"ha" * 3` produces `"hahaha"`)  
•   ​**Indexing**​: Access individual characters (`text[0]`)  
•   ​**Slicing**​: Extract substrings (`text[1:4]`)  
•   ​**Length**​: Using `len()` function (`len("hello")` returns `5`)

### String Methods

•   ​**Case manipulation**​: `upper()`, `lower()`, `capitalize()`, `title()`, `swapcase()`  
•   ​**Testing**​: `isalpha()`, `isdigit()`, `isalnum()`, `isspace()`, `isupper()`, `islower()`  
•   ​**Searching**​: `find()`, `rfind()`, `index()`, `rindex()`, `count()`  
•   ​**Modification**​: `replace()`, `strip()`, `lstrip()`, `rstrip()`, `split()`, `join()`

### String Formatting

•   ​**f-strings**​: `f"Hello, {name}!"` (interpolates variables and/or expressions)  
•   ​**format() method**​: `"Hello, {}!".format(name)`  
•   ​`%` **operator**​: `"Hello, %s!" % name` (older style)

### Indexing Strings

- To access the individual characters in a string, use the `[ ]` **indexing syntax**.
- The value between the brackets must be an integer between 0 and the length of the string minus 1:

```python
>>> my_str = 'abc' 
>>> my_str[0]
a 
>>> my_str[1] 
b 
>>> my_str[2]
c
```

- You can also use negative integers to access characters based on the distance from the end of the string. For instance, `my_str[-1]` returns the last character in the string, while `my_str[-2]` returns the next to last character. The index of the first character is given by `-len(my_str)`:

```python
>>> my_str = 'abc'
>>> my_str[-1]
c
>>> my_str[-2]
b 
>>> my_str[-3]
a
```

### String Representations

- `str` and `repr` return a string representation of any object.
- `str` output is intended for human readability.
- `repr` is lower-level and returns a string that can be use to create a new instance of the object.

```python
my_str = 'abc'
print(my_str)       # abc
print(str(my_str))  # abc (same as print(my_str))
print(repr(my_str)) # 'abc' (note the quotes)
```

### Important Concepts

* Strings are ​[**passed by object reference**](20.pass_by_object_reference.md)​ to functions
* String methods ​**return new strings**​ rather than modifying existing ones
* String comparisons use **lexicographical (dictionary) ordering**
* Escape sequences like `\n`, `\t`, and `\\` for special characters

### Lexicographical (dictionary) ordering

When we talk about lexicographical ordering in string comparisons, we're referring to how Python determines whether one string is "greater than," "less than," or "equal to" another string. This is similar to how words are ordered in a dictionary (hence the term "dictionary ordering").

#### How Lexicographical Comparison Works?

When Python compares two strings using operators like `<`, `>`, `==`, `!=`, `<=`, or `>=`, it does so character by character, from left to right:

1.  Python compares the first character of each string using their Unicode code points  
2.  If they differ, the comparison result is determined immediately  
3.  If they're the same, Python moves to the next character and repeats the process  
4.  If one string is a prefix of the other (meaning it runs out of characters first), the shorter string is considered "less than" the longer one

* Python compares strings character-by-character from left to right in both strings. The comparison stops as soon as Python reaches a decision.
- `'abcdef' > 'abc'`. In this example, the strings have unequal sizes. Furthermore, the longer string is identical up to the shorter string's length. Python returns `True` here; when it can no longer take characters from the shorter string, it concludes that the longer string has the greater value. Similar behaviors occur with the other ordered comparison operators.
- It's also worth noting that even numeric strings are compared character by character. Thus, `'3' > '24'` returns `True` since the character `3` is greater than the character `2`.
- In general, numeric characters in a string are less than alphabetic characters, and uppercase letter characters are less than lowercase letters.

#### Unicode Ordering

The comparison is based on the Unicode code point (numerical value) of each character. In ASCII/Unicode:

•   Uppercase letters (`A-Z`) come before lowercase letters (`a-z`)  
•   Digits (`0-9`) come before letters  
•   Special characters have their own ordering
### Examples

```python
# String operations
name = "Python is cool"
greeting = "Hello, " + name + "!"  # 'Hello, Python is cool!'
repeated = name * 3  # Repetition: "Python is coolPython is coolPython is cool"

# Indexing and slicing
first_char = name[0]  # 'P'
substring = name[1:4]  # 'yth'

# String methods (Case Manipulation)
upper_name = name.upper()  # 'PYTHON IS COOL'
lower_name = name.lower()  # 'python is cool'
capitalize_name = lower_name.capitalize() # 'Python is cool'
title_name = name.title()  # 'Python Is Cool'
swapcase_name = name.swapcase() # 'pYTHON IS COOL'

# String methods (Testing)
has_alpha = name.isalpha()  # False (there are spaces in the String)
has_digits = name.isdigit()  # False
has_alnum = name.isalnum()   # False
is_space = name.isspace()    # False
is_upper = name.isupper()    # False
is_lower = name.islower()    # False

# String methods (Searching)
position = name.find('th')  # 2 (returns -1 if not found)
rfind = name.rfind('o')     # 12 (Highest Index)
idx = name.index('th')      # 2 (like find but raises ValueError if not found)
ridx = name.rindex('o')     # 12
count = name.count('o')     # 3

# String Modification
replace_name = name.replace('Python', 'JavaScript') # JavaScript is cool
new_name = " Python is cool "
strip = name.strip() # 'Python is cool'
lstrip = name.strip() # 'Python is cool '
rstrip = name.rstrip() # ' Python is cool'
split = name.split() # ['Python', 'is', 'cool']
split_join = ' '.join(split) # 'Python is cool'

# String formatting
age = 30
message = f"{name} is {age} years old"
```



## 5.) F-Strings

### Raw Strings and F-Strings

* String literals with an `r` prefix are **raw string literals**. Raw string literals don't recognize escapes, so you can use literal `\` characters freely.

```python
# Both of these print C:\Users\Xyzzy
print("C:\\Users\\Xyzzy")  # Each \\ produces a literal \
print(r"C:\Users\Xyzzy")  # raw string literal
```

* String literals with an `f` are **formatted string literals** or **f-strings**. These enable a way, via **string interpolation**, to embed expressions inside string literals.

```python
>>> f'5 plus 5 equals {5 + 5}.' 
'5 plus 5 equals 10.' 
>>> my_name = 'Karl' 
>>> f'My name is {my_name}.' 
'My name is Karl.' 
>>> my_name = 'Clare' 
>>> greeting = 'Ey up?' 
>>> f'{greeting} My name is {my_name}.' 
'Ey up? My name is Clare.
```

### Basic syntax

F-strings begin with the letter `f` or `F` before the opening quotation mark:

```python
name = "Ivan"  
profession = "programmer"  
greeting = f"Hello, {name}. You are a {profession}."
```

The expressions inside the curly braces `{}` are evaluated at runtime and converted to strings.

### Advantages of F-strings

1.  ​**Readability**​: They're more concise and easier to read than other formatting methods  
2.  ​**Performance**​: F-strings are generally faster than `str.format()` and `%` formatting  
3.  ​**Direct expression evaluation**​: You can put any valid Python expression inside the braces

### Comparison with `str.format()`

```python
name = "Ivan"  
profession = "programmer" 
greeting = "Hello, {}. You are a {}.".format(name, profession)
```

F-strings typically make your code more readable, especially with multiple variables.

### Advanced Features

You can also include formatting specifications within f-strings:

```python
pi = 3.14159  
print(f"Pi rounded to 2 decimal places: {pi:.2f}")
```



## 6.) String Methods

### Casing Methods

#### `upper()`

Converts string to uppercase

```python
first_name = "Ivan"
print(first_name.upper())    # IVAN
```

#### lower()

Converts string to lowercase

```python
last_name = "Hernandez"
print(last_name.lower())     # hernandez
```

#### `capitalize()`

Capitalizes first character of string and the rest lowercased

```python
city = "caracas"
print(city.capitalize())      # Caracas
```

#### `title()`

Converts first character of each word to uppercase

```python
book_title = "cien años de soledad"
print(book_title.title()).   # Cien Años De Soledad
```

#### ```swapcase()```

Return a copy of the string with uppercase characters converted to lowercase and vice versa.

```python
first_name = "Ivan"
print(first_name.swapcase())        # "iVAN"
```

### Search Methods

#### `str.find(sub)`

Returns lowest index where substring is found, or -1 if not found

```python
string = "Hello, World!"
print(string.find('o'))             # 4
print(string.find('x'))             # -1
```

#### `str.rfind(sub)`

Returns the highest index where the substring is found, or -1 if not found

```python
name = "Python is cool"
rfind = name.rfind('o')     # 12 (Highest Index)
```

#### `str.index(sub)`

Like find, but raises `ValueError` if substring not found

```python
string = "Hello, World!"
print(string.index('o'))             # 4
print(string.index('x'))             # ValueError
```

#### `str.rindex(sub)`

Like `rfind` but raises `ValueError` if substring not found

```python
name = "Python is cool"
rfind = name.rindex('o')     # 12 (Highest Index)
```

#### `str.count(sub)`

Counts occurrences of substring

```python
string = "Hello, World!"
print(string.count('o'))        # 2
```

### Check Methods

#### `str.startswith(prefix)` 

Checks if string starts with prefix

```python
string = "Today is a great day"
print(string.startswith('T'))   # True
```

#### `str.endswith(suffix)` 

 Checks if string ends with suffix

```python
string = "Today is a great day"
print(string.endswith('day'))    # True
```

#### `str.isalpha()` 

Checks if all characters are alphabetic

```python
string = "Today is a great day"
print(string.isalpha())        # False
string2 = "TodayIsAGreatDay"
print(string2.isalpha())       # True
```

#### `str.isdigit()` 

Checks if all characters are digits

```python
string = '12345'
print(string.isdigit())      # True
```

#### `str.isalnum()` 

Checks if all characters are alphanumeric

```python
string = "TodayIs2Good2BeTrue"
print(string.isalnum())       # True
```

#### `str.isspace()` 

Checks if all characters are whitespace

```python
string = " "
print(string.isspace())     # True
```

#### `str.islower()`

Check if all characters are in lower case

```python
string = 'hello world'
print(string.islower())    # True
```

#### `str.isupper()`

Check if all characters are in upper case

```python
string = "HELLO WORLD"
print(string.isupper())   # True
```
### Manipulation Methods

#### `str.strip()`

Removes leading and trailing whitespace (or specified characters)

```python
string = " Hello "
print(string.strip())   # Hello

string2 = "%Hello%"
print(string2.strip('%'))  # Hello
```

#### `str.lstrip()`

Removes leading whitespace (or specified characters)

```python
string = " Hello "
print(string.lstrip())   # Hello

string2 = "%Hello%"
print(string2.lstrip('%')) #Hello%
```

#### `str.rstrip()`

Removes trailing whitespace (or specified characters)

```python
string = "%Hello%"
print(string.rstrip('%'))    # %Hello
```

#### `str.replace(old, new)`

Replaces occurrences of 'old' with 'new'

```python
string = "Good Morning"
print(string.replace("Morning", "Afternoon"))  # Good Afternoon
```

#### `str.split(sep)`

Splits string by separator into a list

```python
string = "Good Morning Vietnam"
print(string.split())   # ["Good", "Morning", "Vietnam"]
```

#### `str.join(iterable)`

Joins elements of an iterable with the string as separator

```python
lst = ["Good", "Morning", "Vietnam"]
print(' '.join(lst)) # Good Morning Vietnam
```

## 7.) Boolean vs. Truthiness

### Boolean values

- `True`
- `False`

These are Boolean objects that you can assign to variables, pass as arguments, and return from functions.

### Truthiness

* Is a concept that refers to how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.
* Python can evaluate objects and values as either **truthy** or **falsy**.
- Truthiness arises in conditional expressions, such as `if` and `while` statements. Conditional expressions don't need to produce Boolean values. Instead, Python only needs to determine their truthiness. In an `if` statement, a conditional expression that evaluates as truthy causes the `if` block to execute. The `else` or `elif` block runs when the expression evaluates as falsy.

#### Python's built-in **falsy** values:

- `False`
- all numeric `0` values (integers, floats, complex)
- `None`
- `''` or `""`
- empty collections: `[]`, `{}`, `()`, `set()`, `frozenset()` and `range(0)`
- Custom data types can also define additional falsy values.

#### Python's **truthy** values:

- Anything that is not in the **falsy** list

### Truthiness and Short-Circuit Evaluation

- Logical operators don't always return `True` or `False`.
- They only care about the truthiness of their operands. 
- In each case, they evaluate as the object that evaluates last in the expression.

```python
print(3 and 'foo')   # last evaluated op: 'foo'
print('foo' and 3)   # last evaluated op: 3
print(0 and 'foo')   # last evaluated op: 0
print('foo' and 0)   # last evaluated op: 0

print(3 or 'foo')    # last evaluated op: 3
print('foo' or 3)    # last evaluated op: 'foo'
print(0 or 'foo')    # last evaluated op: 'foo'
print('foo' or 0)    # last evaluated op: 'foo'
print('' or 0)       # last evaluated op: 0
print(None or [])    # last evaluated op: []
```



## 8.) `None`

- Express the absence of a value.
- Data Type: `NoneType`
- Literal: `None`
- `None` **is a singleton object**​ - There is only one `None` object in Python.
- `None` **is falsy**​ - It evaluates to `False` in Boolean contexts
- Immutable
- **Implicit function returns**​ - Functions without an explicit `return` statement will return `None` by default.

### **Important Distinctions for PY109**

1. The difference between `None` and `False`: 
	-   `None` is the absence of a value, while `False` is a Boolean value  
	-  They are both falsy, but `None is not False`
	
2. When discussing function return values:  
    - Be specific about when a function returns `None`  
    - Distinguish between a function's output (what it prints) and its return value
   
3. Testing for `None`: 
	- Use `is None` or `is not None` rather than `== None` for identity comparison  
	- Remember that `None` is a singleton object



## 9.) Ranges

Are a built-in sequence type in Python used to represent a sequence of numbers.

### Basics

- A `range` object represents an immutable sequence of numbers
- Most commonly used in `for` loops to repeat actions a specific number of times
- Created using the `range()` function
- It's a non-primitive
- **`range(integer)`** doesn't produce the integers before a program ask for it. This optimizes memory. They are lazy sequences.

### Creating ranges

The `range()` function can be called with 1-3 arguments:

- `range(stop)`: Numbers from 0 up to but not including `stop`
- `range(start, stop)`: Numbers from `start` up to but not including `stop`
- `range(start, stop, step)`: Numbers from `start` up to but not including `stop`, incrementing by `step` 

### Key Characteristics

- Ranges are memory-efficient because they don't store all values in memory
- They're immutable (cannot be changed after creation)
- Support standard sequence operations like indexing, slicing, and iteration
- Can be converted to other sequences like lists with `list(range(...))`

### Examples

```python
>>> list(range(1, 10, 2))
[1, 3, 5, 7, 9]

>>> list(range(0, -5, -1))
[0, -1, -2, -3, -4]

# Basic range  
for i in range(5):  
    print(i)  # Prints 0, 1, 2, 3, 4

# With start and stop  
for i in range(2, 7):  
    print(i)  # Prints 2, 3, 4, 5, 6

# With step  
for i in range(1, 10, 2):  
    print(i)  # Prints 1, 3, 5, 7, 9

# Negative step (counting down)  
for i in range(10, 0, -1):  
    print(i)  # Prints 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
```



## 10.) List and Dictionary Syntax

### Lists and Tuples

#### Basics of Lists

- **Lists** are ordered, mutable collections that can store different types of data.
- **Lists** literals: `[]`
- The comma-delimited values are known as **elements**
- Use indexing syntax to retrieve specific elements.
- Use indexing syntax to reassign specific list elements. (**Element reassignment**)

##### Examples

```python
# Creating lists  
empty_list = []  
numbers = [1, 2, 3, 4, 5]  
mixed = [1, "hello", True, 3.14]  
  
# Accessing elements (zero-indexed)  
first_item = numbers[0]  # 1  
last_item = numbers[-1]  # 5  
  
# Slicing  
subset = numbers[1:4]  # [2, 3, 4]  
  
# Modifying lists  
numbers.append(6)       # adds 6 to the end  
numbers.insert(0, 0)    # inserts 0 at index 0  
numbers.remove(3)       # removes first occurrence of 3  
popped_item = numbers.pop()  # removes and returns last item  
numbers[0] = 99         # lists are mutable, can change elements
```

#### Basics of Tuples

- **Tuples** are ordered, immutable collections, often used for data that shouldn't change.
- **Tuples** literals = `()`

##### Examples

```python
# Creating tuples  
empty_tuple = ()  
single_item = (1,)      # comma is needed for single-item tuples  
coordinates = (10, 20)  
mixed_tuple = (1, "hello", True)  
  
# Accessing elements (same as lists)  
x = coordinates[0]      # 10  
  
# Attempting to modify will cause an error  
# coordinates[0] = 5    # TypeError: 'tuple' object does not support item assignment
```

#### Key Differences

- **Mutability**​: Lists can be modified after creation, tuples cannot.
- **Syntax**​: Lists use square brackets `[]`, tuples use parentheses `()`.
- **Performance**​: Tuples are slightly faster and use less memory.
- **Use cases**​: Lists for collections that change, tuples for data that shouldn't change.

#### Common Operations

```python
# Length  
len(numbers)              # number of items  
  
# Membership testing  
3 in numbers              # True if 3 is in numbers  
  
# Concatenation  
combined_list = [1, 2] + [3, 4]   # [1, 2, 3, 4]  
combined_tuple = (1, 2) + (3, 4)  # (1, 2, 3, 4)  
  
# Repetition  
repeated_list = [0] * 3   # [0, 0, 0]  
  
# Iteration  
for item in numbers:  
    print(item)  
      
# List comprehensions (lists only)  
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]  
  
# Unpacking  
a, b = coordinates       # a = 10, b = 20
```





## 11.) List Methods

## 12.) Dictionary Methods

## 13.) Slicing

## 14.) Operators

### Arithmetic Operators

* Addition: `+`
* Subtraction: `-`
* Multiplication: `*`
* Division: `/` (always returns a float)
* Floor division: `//` (returns integer part)
* Modulo: `%` (returns remainder)
* Exponentiation: `**`

### Operator Precedence

1.  Parentheses `()`  
2.  Exponentiation `**`  
3.  Unary operators `+x`, `-x`  
4.  Multiplication/division `*`, `/`, `//`, `%`  
5.  Addition/subtraction `+`, `-`

## 15.) Mutability and Immutability

## 16.) Pass by Object Reference

## 17.) Variables

## 18.) Conditionals and Loops

## 19.) `print()` and `input()`

## 20.) Exceptions

## 21.) Functions

## 22.) Expressions and Statements

### Variables Naming Conventions

**Concepts:**

- **idiomatic**: the Python's naming conventions are followed (Python Enhancements Proposal - PEP8)
- **non-idiomatic**: the Python's naming conventions are not followed but the name is **legal**
- **illegal**: names that are syntactically incorrect or are using a Python's reserved word: `if`, `elif`, `else`, `pass`, `def`, `while`, `for`, `class`, `return`.

**Variables Naming Conventions:**

- Use of **snake_case**
- Names can contain `a-z` and `0-9`
- Cannot begin with a digit
- Names with multiple words must be separated by `_`

**Special Cases:**

- Names with double underscores on both sides like `__var__` are not idiomatic (except when specifically defined by Python).
- Non-ASCII characters (like `π`) are non-idiomatic.
- Words without separation (like `milesperhour`) are non-idiomatic.

**Illegal Names**:

* Punctuation characters, most special characters, and whitespaces are not allowed
* Names must not begin with a digit
* Python reserved words are not allowed: `if`, `def`, `while`, `for`, `return`, `class` and `pass`

### Constants Naming Conventions

- Use of **SCREAMING_SNAKE_CASE**
- Names can contain `A-Z`and `0-9`
- Cannot begin with a digit
- Names with multiple words must be separated by `_`

### Variable Scope

Variables defined outside of any function have **global scope**, meaning they can be accessed from anywhere in your program.

Variables defined inside a function have **local scope**, meaning they can only be accessed within that function.

### Assignment vs. Reassignment

### Variables as Pointers

### Variable Shadowing

### Global keyword

### Expressions vs. Statements

### Mutability vs. Immutability

#### What is the definition of mutable/immutable?

* Mutable types are types whose objects can be changed after they are created.
* Immutable types cannot be changed after they are created.

## Operations and Control Flow
### Operators

### Conditionals Statements and Truthiness

### Loops

### F-strings

The concept demonstrated here is string interpolation using f-strings, which were introduced in Python 3.6 as a concise and readable way to embed expressions inside string literals. f-strings automatically handle the conversion of non-string values to strings.

**Example**
Within the function, on line X, we use an f-string (formatted string literal) which is denoted by the `f` prefix before the string. The expression `{XXX}` within the curly braces is evaluated at runtime, and the value of the `name` variable (`'XXX'`) is converted to a string and inerpolated into the string.

### Escape Sequences

The concept demonstrated here is escape sequences in strings, which allow us to encode special characters into strings via escape notation that would be impossible to include in another way. Examples: newlines, carriage returns, tabs, etc.

## Functions
### Function definition vs. Function invocation

### Parameters vs. Arguments

### Return Values vs. Side Effects

### Nested Functions

### Pass-by-Object-Reference


## Collections and String Operations

### String Methods

### String Check Methods

The concept demonstrated here is string check methods, specifically `XXX()` that check that the string contains only XXX characters, without modifying the original string, demonstrating string immutability.

### List Methods

### Dictionary Methods

### Slicing

### Exception Handling

Is the process to manage or handle errors that might occur during the execution of a program.

The flow of exception handling includes:
1.  The try block that contains code that might raise an exception  
2.  The except block that runs only if a matching exception occurs  
3.  The else block (if present) that runs only if no exceptions occurred  
4.  The finally block (if present) that always runs regardless of exceptions

## Other
### Mutation vs Reassignment

### Default Parameters

### Implicit vs. Explicit return values

### Truthiness

Is how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.











