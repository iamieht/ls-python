# Concepts with Examples

- [[#1.) Data Types]]
- [[#2.) Type Coercions]]
- [[#3.) Numbers]]
- [[#4.) Strings]]
- [[#5.) F-Strings]]
- [[#6.) String Methods]]
- [[#7.) Boolean vs. Truthiness]]
- [[#8.) `None`]]
- [[#9.) Ranges]]
- [[#10.) List and Dictionary Syntax]]
- [[#11.) List Methods]]
- [[#12.) Dictionary Methods]]
- [[#13.) Slicing]]
- [[#14.) Operators]]
- [[#15.) Mutability and Immutability]]
- [[#16.) Pass by Object Reference]]
- [[#17.) Variables]]
- [[#18.) Conditionals and Loops]]
- [[#19.) `print()` and `input()`]]
- [[#20.) Exceptions]]
- [[#21.) Functions]]
- [[#22.) Expressions and Statements]]
- [[#23.) Naming Conventions]]


## 1.) Data Types

### Basics

- Everything with a value in Python is an **object**.
- Each **object** has a **type** and an associated **class**.
- A **primitive type** is the most fundamental type in a language.

### Data Types in Python

##### Core Data Types

###### **Primitive/Immutable Types:**

- **Integers**​: Whole numbers like `42`, `-7`, `0`
- ​**Floats**​: Decimal numbers like `3.14`, `-2.5`
- **Strings**​: Text enclosed in quotes: `'hello'`, `"Python"`
- **Booleans**​: `True` or `False` values

###### **Compound/Mutable Types:**

- **Lists**​: Ordered, mutable collections `[1, 2, 3]`
- **Dictionaries**​: Key-value pairs `{'name': 'Alice', 'age': 30}`
- **Sets**​: Unordered collections of unique elements `{1, 2, 3}`
- **Functions**

###### **Compound/Immutable Types:**

- **Tuples**​: Immutable sequences like `(1, 2, 3)`
- **Frozen Sets**: Unordered collections of unique elements `frozenset([1, 2, 3])`
- **ranges**: represent an immutable sequence of numbers `range(5)`
### Summary

Built-in data types:

| Data Type                          | Class       | Category                | Kind          | Mutable | Immutable |
| ---------------------------------- | ----------- | ----------------------- | ------------- | ------- | --------- |
| [[#Integers]]                      | `int`       | numerics                | Primitive     |         | X         |
| [[#Floats]]                        | `float`     | numerics                | Primitive     |         | X         |
| [boolean](8.boolean_vs_truthiness) | `bool`      | booleans                | Primitive     |         | X         |
| [strings](5.strings)               | `str`       | text sequences          | Primitive     |         | X         |
| [ranges](12.ranges.md)             | `range`     | sequences (collections) | Non-primitive |         | X         |
| [tuples](13.lists)                 | `tuple`     | sequences (collections) | Non-primitive |         | X         |
| [lists](13.lists)                  | `list`      | sequences (collections) | Non-primitive | X       |           |
| [dictionaries](15.dictionaries)    | `dict`      | mappings (collections)  | Non-primitive | X       |           |
| sets                               | `set`       | sets (collections)      | Non-primitive | X       |           |
| frozen sets                        | `frozenset` | sets (collections)      | Non-primitive |         | X         |
| [functions](25.functions)          | `function`  | functions               | Non-primitive | X       |           |
| [`NoneType`](9.none)               | `NoneType`  | nulls                   | _--?--_       |         | X         |

### Literals

Is any syntactic notation used to represent an object in source code. 

These are the literals in Python:

```python
'Hello, world!'   # str literal
3.141592          # float literal
True              # bool literal
{'a': 1, 'b': 2}  # dict literal
[1, 2, 3]         # list literal
(4, 5, 6)         # tuple literal
{7, 8, 9}         # set literal
```

Not all objects have literal forms, for those the **type constructor** is used to create objects of the type:

```python
range(10)         # Range of numbers: 0-9
range(1, 11)      # Range of numbers: 1-10
set()             # Empty set
frozenset([1, 2]) # Frozen set of values: 1 and 2
```

### Intro to Collections

#### Collection Types

- Collections are objects that contain zero or more **member objects**, often called **elements**.
- There are 3 main categories of collection: sequences, maps, and sets.

| Type                            | Class       | Category  | Kind          | Mutable |
| ------------------------------- | ----------- | --------- | ------------- | ------- |
| [ranges](12.ranges.md)          | `range`     | sequences | Non-primitive | No      |
| [tuples](13.lists.md)              | `tuple`     | sequences | Non-primitive | No      |
| [lists](13.lists.md)               | `list`      | sequences | Non-primitive | **Yes** |
| [dictionaries](15.dictionaries.md) | `dict`      | mappings  | Non-primitive | **Yes** |
| sets                            | `set`       | sets      | Non-primitive | **Yes** |
| frozen sets                     | `frozenset` | sets      | Non-primitive | No      |
#### What are Sequences?

- Sequences are types that maintain an **ordered** collection of objects (also: elements or values) that can be **indexed** by whole numbers.
- Ordered collections are collections organized in some sequence: a first element, a second element, a third element, and so on. Indexed sequences associate every object member with a whole number (0, 1, 2, etc.) that can be used to access or modify that object. 
- Lists and tuples are **heterogeneous**; they may contain different kinds of objects, including other sequences.
- Ranges are **homogenous**; they always contain integers.
- Strings are a form of sequence called a **text sequence**. They differ from ordinary sequences in two main ways:
    - Strings are homogenous; all characters in a string are characters.
    - Characters are not a distinct kind of object; they are merely strings of length 1.
    - A string's individual characters are not separate strings until you reference a character.
    - Strings are not actual collections since the characters inside the string aren't objects.

#### What are Sets?

- Sets are types that maintain an **unordered** collection of unique objects (also called **elements** or **members**).
- Sets cannot be indexed.
- **Unordered** means no well-defined order exists for the objects in a set.
- There are two types of set types: sets (mutable) and frozen sets (immutable).
- Both are **heterogeneous**

#### What are Mappings?

- Maps are types that maintain an **unordered** collection of **key/value** pairs (also called elements or members).
- Maps are accessed by their keys.
- Dictionary or `dict` type.
- Dicts are mutable.
- The keys in a dict must be unique.
- Keys must be "hashable" values (immutable): A hashable type is a type from which consistent hash values can be computed. A hash function takes an object and returns a hash value, which is used internally in a dictionary to store and retrieve values. Given two identical objects, the hash function must return the same value for both objects.
- Tuples can be used as dictionary keys since they are immutable. However, this only applies if all the elements inside the tuple are also immutable and hashable. For example, a tuple that contains lists cannot be used as a dictionary key since lists are mutable and non-hashable, making the entire tuple non-hashable as well.
- The values in each key/value pair may be any object.

#### Sequence Constructors

- You can also use special functions called **constructors** to create new objects. In fact, sometimes you can't use literals; you must use constructors to create ranges, frozen sets, and empty sets.

#### String Constructor

- `str()` and `str(Python object)`
```python
str()            # returns '' (empty string)
str('abc')       # returns 'abc'
str(42)          # returns '42'
str(3.141592)    # returns '3.141592'
str(False)       # returns 'False'
str(None)        # returns 'None'
str(range(3, 7)) # returns 'range(3, 7)'
str([1, 2, 3])   # returns '[1, 2, 3]'

class Person:
    def __init__(self, name):
        self.name = name

str(Person('May'))
# returns '<\_\_main\_\_.Person object at 0x...>'
```

#### Range Constructor

It comes in 3 forms:

- `range(start, stop, step)`
    - This constructor generates a sequence of integers between start and stop - 1 with an increment of step between each consecutive integer.
    - You can use a negative step to generate a sequence in reverse order. In this case, the range ends at stop + 1. 

```python
r = range(5, 12, 2)
print(list(r))            # [5, 7, 9, 11]

r = range(12, 8, -1)
print(list(r))            # [12, 11, 10, 9]

r = range(12, 5, -2)
print(list(r))            # [12, 10, 8, 6]
```

- `range(start, stop)`

    - When you omit the step argument, Python uses a default value of 1. Hence, range(start, stop) is identical to range(start, stop, 1).

- `range(stop)`

    - When you omit the start argument, Python uses a default value of 0 for start. Hence, range(stop) is identical to range(0, stop, 1).

- Ranges are **lazy sequences**: they don't create any element values until your program needs them.

#### The List, Tuple, Set, and Frozen Set Constructors

Lists, tuples, sets, and frozen sets share two common constructor forms:

- `list()` or `list(iterable)`
- `tuple()` or `tuple(iterable)`
- `set()` or `set(iterable)`
- `frozenset()` or `frozenset(iterable)`

- The constructors with no arguments create an empty list, tuple, set, or frozen set, as appropriate: a sequence or set with no members.
- The constructors that take an iterable argument expect an object that Python can iterate: an iterable. From the built-in types, the iterables include all sequences, text strings, sets, and maps.

```python
my_str = 'Python'

my_list = list(my_str)
print(my_list)  # ['P', 'y', 't', 'h', 'o', 'n']

my_tuple = tuple(my_list)
print(my_tuple) # ('P', 'y', 't', 'h', 'o', 'n')

my_set = set(my_tuple)
print(my_set)   # {'t', 'o', 'n', 'h', 'P', 'y'}
```

### Using Collections

#### Indexing

- Is the process of using a whole number to access and alter an element of a sequence.
- All sequences, including string, support indexing.
- zero-based numbering is used
- The last index of a sequence is `len(seq) - 1`
- Negative indexes are used as well

```python
seq = ('a', 'b', 'c')
print(seq[0])  # a (1st element)
print(seq[1])  # b (2nd element)
print(seq[2])  # c (3rd element)
print(seq[3])  # IndexError: tuple index out of range

seq = ('a', 'b', 'c')
print(seq[-1])  # c (last element)
print(seq[-2])  # b (next to last element)
print(seq[-3])  # a (2nd to last element)
```

#### Slicing

- **Slicing** augmentation: can extract or modify any number of consecutive elements simultaneously.
- Syntax: `seq[start:stop:step]`
- Negative indexes are also supported
- You get an empty slice when the start and stop values are the same.
- Slicing performs a shallow copy if the sequence contains any collections (lists or tuples).

```python
seq = 'abcdefghi'
print(seq[3:7])       # defg
print(seq[-6:-2])     # defg
print(seq[2:8:2])     # ceg
print(repr(seq[3:3])) # ''
print(seq[:])         # abcdefghi => returns a duplicated sequence
print(seq[::-1])      # ihgfedcba => returns a reverse copy of a sequence

seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(seq[3:7])       # [4, 5, 6, 7]
print(seq[-6:-2])     # [5, 6, 7, 8]
print(seq[2:8:2])     # [3, 5, 7]
print(seq[3:3])       # []
print(seq[:])         # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] => returns a duplicated sequence
print(seq[::-1])      # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] returns a reverse copy of a sequence

seq = [[1, 2], [3, 4]]
seq_dup = seq[:]
print(seq[0] is seq_dup[0])   # True
```

#### Key-Based Access

- Mappings use key-based syntax.
- Any hashable object can be used as a key
- When using a non-existent key we get the error `KeyError:`
- `dict.get` method returns the value associated with a given key if they exists, otherwise produces a default return value (usually `None`, but other values can be specified)
- We can assign a new key to the dictionary: `my_dict['key'] = 'value'`
- We cannot use mutable keys.

```python
my_dict = {
    'a': 'abc',
    37: 'def',
    (5, 6, 7): 'ghi',
    frozenset([1, 2]): 'jkl',
}

print(my_dict['a'])                # abc
print(my_dict[37])                 # def
print(my_dict[(5, 6, 7)])          # ghi
print(my_dict[frozenset([1, 2])])  # jkl
print(my_dict['nothing'])     # KeyError: 'nothing'

my_dict = {
    'a': 'abc',
    37: 'def',
    (5, 6, 7): 'ghi',
    frozenset([1, 2]): 'jkl',
}

print(my_dict.get('a'))                 # abc
print(my_dict.get('nothing'))           # None
print(my_dict.get('nothing', 'N/A'))    # N/A
print(my_dict.get('nothing', 100))      # 100
```

### Common Collection Operations

#### Non-Mutating Operations for Collections

##### Collection Membership

- The `in` operator determines whether the object to the operator's left is in the iterable collection on the right. Returns `True` if the item is in the collection, `False` otherwise.
- The `not in` operator is the inverse of `in`.
- With sequences and sets, both operators compare the object for equality against each collection element.
- For mappings, it checks whether the item is a key in the dictionary.
- For strings, it determines whether the right string contains the left string.

```python
seq = [4, 'abcdef', (True, False, None)]
print(4 in seq)                         # True
print(4 not in seq)                     # False
print('abcdef' in seq)                  # True
print('abcdef' not in seq)              # False
print('cde' in seq[1])                  # True
print('cde' not in seq[1])              # False
print('acde' in seq[1])                 # False
print('acde' not in seq[1])             # True
print((True, False, None) in seq)       # True
print((True, False, None) not in seq)   # False
print(3.14 in seq)                      # False
print(3.15 not in seq)                  # True
```

##### Minimun and Maximun Members

- `min` and `max` return the minimun and maximum members in an iterable collection.
- Any pair of the collection's elements must be comparable with the `<` and `>` operators.
- In most cases, you can't use `min` and `max` with heterogeneous collections, but it's possible in some situations (int and float)
- You can use them with multiple arguments instead of an iterable.

```python
my_set1 = {1, 4, -9, 16, 25, -36, -63, -1}
my_set2 = {'1', '4', '-9', '16', '25', '-36', '-1'}

print(min(my_set1), max(my_set1))     # -63 25
print(min(my_set2), max(my_set2))     # -1 4
```
```python
>>> my_set = {1, 4, '-9', 16, '25', -36, -63, -1}
>>> min(my_set)
TypeError: '<' not supported between instances of
'str' and 'int'

>>> max(my_set)
TypeError: '>' not supported between instances of
'str' and 'int'
```
```python
my_set = {1, 3.14, -2.71}
print(min(my_set), max(my_set))      # -2.71 3.14
```

##### Summation

- `sum` function is used with iterable collections which elements are numeric values. It returns the sum of all the collection's numbers.
- `sum` cannot be used with strings

```python
numbers = (1, 1, 2, 3, 5, 8, 13, 21, 34)
print(sum(numbers))                       # 88
```

##### Locating Indices and Counting

- `seq.index`method returns the index of the first element in the sequence that matches a given object. It raises a `ValueError` exception if the object is not found.
- Also works with strings. It searches for the first matching substring of a string.

```python
names = ['Karl', 'Grace', 'Clare', 'Victor',
         'Antonina', 'Allison', 'Trevor']
print(names.index('Clare'))   # 2
print(names.index('Trevor'))  # 6
print(names.index('Chris'))
# ValueError: 'Chris' is not in list

names = 'Karl Grace Clare Victor Antonina Trevor'
print(names.index('Clare'))   # 11
print(names.index('Trevor'))  # 33
print(names.index('Chris'))
# ValueError: substring not found
```

- `seq.count` returns the number of times a value occurs in the sequence.

```python
numbers = [1, 3, 6, 5, 4, 10, 1, 5, 4, 4, 5, 4]
print(numbers.count(1))       # 2
print(numbers.count(3))       # 1
print(numbers.count(4))       # 4
print(numbers.count(7))       # 0
```

##### Merging Collections

- `zip` function merges the members/elements of multiple iterables into a single list of tuples.
- Makes it easy to iterate through many collections simultaneously.
- Each tuple in the list contains objects from each iterable (tuple1 contains all 0-indexed elements, tuple2 contains all 1-indexed elements, tupleN all Nth-indexed elements).
- `zip's` result is a lazy sequence like `range`

```python
iterable1 = [1, 2, 3]
iterable2 = ('Kim', 'Leslie', 'Bertie')
iterable3 = [None, True, False]

zipped_iterables = zip(iterable1, iterable2, iterable3)
print(list(zipped_iterables))
# Pretty printed for clarity
# [
#   (1, 'Kim', None),
#   (2, 'Leslie', True),
#   (3, 'Bertie', False)
# ]
```

- `zip`'s collection arguments don't have to be of the same length. To enforce it, add `strict=True` to raise an exception in that case.

```python
zipped_iterables = zip(iterable1, iterable2, strict=True)
```

- If lengths are different and no `strict=True` is provided: `zip` stops after exhausting the shortest iterable, meaning the number of tuples in the generated list will be determined by the length of the shortest iterable

```python
result = zip(range(5, 10),    # length is 5
             range(1, 3),     # length is 2 (shortest)
             range(3, 7))     # length is 4
print(list(result)) # [(5, 1, 3), (6, 2, 4)]
```
- `zip` returns an iterator, meaning can only be consumed once.

```python
result = zip(range(5, 10),    # length is 5
             range(1, 3),     # length is 2 (shortest)
             range(3, 7))     # length is 4
print(list(result)) # [(5, 1, 3), (6, 2, 4)]
print(list(result)) # []
```

#### Nested Collections

- Collections can be nested inside other collections.
- You can't nest a mutable collection inside a set, but you can nest an immutable one: frozenset or tuple.
- You can nest mutable collections inside a tuple and mutate it.

```python
>>> my_set = {1, 2, 3, [4, 5]}
TypeError: unhashable type: 'list'

>>> my_set = {1, 2, 3, {4, 5}}
TypeError: unhashable type: 'set'

>>> my_set = { 1, 2, 3, frozenset([4, 5]) }
>>> my_set          # {frozenset({4, 5}), 1, 2, 3}

>>> my_tuple = (1, 2, 3, [4, 5], {6, 7}, {'x': 'a dict'})
>>> my_tuple
(1, 2, 3, [4, 5], {6, 7}, {'x': 'a dict'})
```


#### Comparing Collections

- Python supports comparison operations for collections. It provides comparison mechanisms for all built-in iterable collections, and you can define comparisons for any custom iterables you create.

-  If two iterables meet all of the following requirements, they are equal. Otherwise, they are unequal:
    - They have the same type: (list, tuple, set, etc.) Note that sets and frozen sets are considered the same for comparison purposes.
    - They have the same number of elements.
    - For sequences, each pair of corresponding elements compares as equal.
    - For sets, each set has the same members (order doesn't matter).
    - For maps, each key/value pair must be present and identical in both maps (order doesn't matter).

```python
print([2, 3] == [2, 3])    # True
print([2, 3] == [3, 2])    # False (diff sequence)
print([2, 3] == [2])       # False (diff lengths)
print([2, 3] == (2, 3))    # False (diff types)
print({2, 3} == {3, 2})    # True (same members)

dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 2, 'a': 1}
dict3 = {'a': 1, 'b': 2, 'c': 3}

print(dict1 == dict2)      # True (same pairs)
print(dict1 == dict3)      # False
```


## 2.) Type Coercions

### What is it?

* Is the process of converting a value from one data type, implicitly or explicitly, to another data type.
* operations between values of the same type in Python don't require coercion.
* `print()` function implicitly converts any value to a string but this is not considered coercion.

### **Implicit Coercion**

* Is one Python automatically transforms one data type into another, without any specific instruction.
* When we use the `print()` function, Python automatically converts the value to a string using the `str()` function. `print()` isn't considered to be coercion. While it does coerce its arguments to strings, that is done behind the scenes. It doesn't return the resulting strings; it just prints them.

#### Combining Integer with Float

* Implicit coercion occurs when doing a calculation that involves an integer and a float. Python automatically coerces the integer to a float, producing a float.

```python
x = 3          # Integer
y = 2.0        # Float

result = x + y
print(result)  # Outputs: 5.0
print(type(result))  # Outputs: <class 'float'>
```

#### Combining String with Non-string

- if you try to use the `+` operator with a string and a number, Python will raise a `TypeError`.

#### Combining Booleans with Numbers

* Python implicitly coerces `True` to the integer value 1 and `False` to 0:

```python
print(True + True + True)     # 3
print(True + 1 + 1.0)         # 3.0
print(False * 5000)           # 0
```

#### Truthiness Coercion

* Python can use any value, regardless of type, in a conditional expression in an `if` or `while` statement.

```python
# These are all falsy values
bool(False)  # False
bool(0)      # False
bool("")     # False
bool([])     # False
bool({})     # False
bool(None)   # False

# Everything else is truthy
bool(42)     # True
bool("hello")  # True
bool([1, 2])   # True
```

### **Explicit Coercion**

* Is when we intentionally transform the value of a data type into another with the use of built-in functions, such as `int()`, `float()`, `str()`.

#### Coercing values to integers

* The `int()` function coerces a value to an integer.
* Trying to convert a non-numeric string or a numeric string that does not represent an integer value to an integer will raise a `ValueError`
* Passing any other data type, like a `list` for example will result in a `TypeError`.

```python
print(int('10'))            # 10
print(int(10.0))            # 10
print(int('3.1415'))      # ValueError: invalid literal for int()
```

#### Coercing values to floats

* The `float()` function is used to convert values to floating-point numbers.
* Attempting to convert a non-numeric string to a float using `float()` will raise a `ValueError`.
* If we pass any other data type, other than `string`, a real number, bytes-type object, and a boolean to it, it will raise a `TypeError`.
* Floats have a special **"Not-a-Number"** value `nan`. Not-a-Number is one of the common ways to represent the missing value in the data. It typically arises from operations that don't have a meaningful result.

```python
float_str = "3.14"
float_number = float(float_str)
print(float_number)  # Output: 3.14
```

```python
result = float('inf') - float('inf')
print(result) # nan
```

```python
nan_string = "NaN"
nan_float = float(nan_string)

print(nan_float)  # Output: nan
```

#### Coercing values to Strings

* The `str()` function coerces values to strings.
* `str()` can convert most Python values to a valid String
* String interpolation is a common technique for including values within a string. When you use interpolation, Python automatically coerces the values to strings using the `str()` function.


```python
print(str(10))         # '10'
print(str(3.1415))     # '3.1415'
```

#### Coercing values to Booleans

- The `bool()` function is used to convert values to booleans. It works with all built-in Python values and most non-built-in values.
- It returns `True` if the value is truthy (evaluates to `True` in a boolean context), and `False` if the value is falsy (evaluates to `False` in a boolean context).

```python
truthy_value = "Hello"
falsy_value = None

is_truthy = bool(truthy_value)
is_falsy = bool(falsy_value)

print(is_truthy)  # Output: True
print(is_falsy)   # Output: False
```

### `repr()` vs `str()`

- `str()`: This function is used to create a string representation of an object that is meant to be human-readable. It focuses on providing a concise and user-friendly representation of the object's value. It is often used for display purposes, such as in `print()` and string interpolation.
- `repr()`: This function is used to create an unambiguous string representation of an object that can be used to recreate the object. It is often used for debugging and development purposes. The `repr()` representation should ideally be a valid Python expression that, when evaluated, would recreate the original object.

```python
import datetime

today = datetime.datetime.now()
print(str(today)) # 2023-08-10 10:18:05.535262
print(repr(today)) # datetime.datetime(2023, 8, 10, 10, 18, 5, 535262)
```
### Determining Types

- `type()` function determines the type of an object:

```python
print(type(1))         # <class 'int'>
print(type(3.14))      # <class 'float'>
print(type(True))      # <class 'bool'>
print(type('abc'))     # <class 'str'>
print(type([1, 2, 3])) # <class 'list'>
print(type(None))      # <class 'NoneType'>

foo = 42               # Variables work, too
print(type(foo))       # <class 'int'>
```

- If you want the class name, you can access the `__name__` property from the result:

```python
print(type('abc').__name__)   # str
print(type(False).__name__)   # bool
print(type([]).__name__)      # list
```

- You can use `type` with the `is` operator (doesn't take inheritance into account):

```python
print(type('abc') is str)     # True
print(type('abc') is int)     # False
print(type(False) is bool)    # True
print(type([]) is list)       # True
print(type([]) is set)        # False
```

- Consider using the `isinstance` function, which determines whether an object is an instance of a particular type. It takes inheritance into account:

```python
print(isinstance('abc', str))    # True
print(isinstance([], set))       # False

class A:
    pass

class B(A):
    pass

b = B()

print(type(b).__name__) # B
print(type(b) is B)     # True
print(type(b) is A)     # False (b's type is
                        # not A)
print(isinstance(b, B)) # True
print(isinstance(b, A)) # True (b is instance of A and B)
```


## 3.) Numbers

### Number types

* **Integers**​: Whole numbers without decimals (`42`, `-7`)
* **Floating-Point**​: Numbers with decimals (`3.14`, `-0.5`)
* **Complex Numbers**​: Numbers with real and imaginary parts (`3+4j`)

### Integers

- Data Type: `int`
- Can't use commas or periods for grouping: `123,456,789` nor `123.456.789`.
- Can write the number without separators or break up the number with underscores: `123_456_789`. 

### Floats

- Data Type: `float`
- Can't use commas or periods for grouping: `42,348,912.346` nor `42.348.912,346`.
- Can write the number without separators or break up the number with underscores: `42_348.912_346`.

### Truthiness of Numbers

* Zero values (`0`, `0.0`) are falsy  
* All other numeric values are truthy

### Type Conversion

* ​**Explicit**​: Using `int()`, `float()`, `complex()`  
* **Implicit**​: Happens automatically in mixed operations (integers convert to floats)

### Number Functions

* `abs()`: Absolute value
* `round()`: Rounding
* `max()`, `min()`: Finding maximum/minimum

## 4.) Strings

### Basics

* **Strings** are an immutable sequence of Unicode characters
* String **literals** can be written with a single `('string')` or double `("string")` quotes
* Triple quotes `('''string''')` or `("""string""")` for multi-line strings
* Empty strings are created with `''` or `""`
* **Text sequences** are strings of characters.
* The difference between a **Text sequence** and an **ordinary sequence** is that the **ordinary sequence** contain zero or more objects, while the **text sequence** does not contain any objects: only contains the characters (which are not objects in itself) that make up the text sequence.

### String Operations

•   ​**Concatenation**​: Using the `+` operator (`"hello" + " world"`)  
•   ​**Repetition**​: Using the `*` operator (`"ha" * 3` produces `"hahaha"`)  
•   ​**Indexing**​: Access individual characters (`text[0]`)  
•   ​**Slicing**​: Extract substrings (`text[1:4]`)  
•   ​**Length**​: Using `len()` function (`len("hello")` returns `5`)

### String Methods

•   ​**Case manipulation**​: `upper()`, `lower()`, `capitalize()`, `title()`, `swapcase()`  
•   ​**Testing**​: `isalpha()`, `isdigit()`, `isalnum()`, `isspace()`, `isupper()`, `islower()`  
•   ​**Searching**​: `find()`, `rfind()`, `index()`, `rindex()`, `count()`  
•   ​**Modification**​: `replace()`, `strip()`, `lstrip()`, `rstrip()`, `split()`, `join()`

### String Formatting

•   ​**f-strings**​: `f"Hello, {name}!"` (interpolates variables and/or expressions)  
•   ​**format() method**​: `"Hello, {}!".format(name)`  
•   ​`%` **operator**​: `"Hello, %s!" % name` (older style)

### Indexing Strings

- To access the individual characters in a string, use the `[ ]` **indexing syntax**.
- The value between the brackets must be an integer between 0 and the length of the string minus 1:

```python
>>> my_str = 'abc' 
>>> my_str[0]
a 
>>> my_str[1] 
b 
>>> my_str[2]
c
```

- You can also use negative integers to access characters based on the distance from the end of the string. For instance, `my_str[-1]` returns the last character in the string, while `my_str[-2]` returns the next to last character. The index of the first character is given by `-len(my_str)`:

```python
>>> my_str = 'abc'
>>> my_str[-1]
c
>>> my_str[-2]
b 
>>> my_str[-3]
a
```

### String Representations

- `str` and `repr` return a string representation of any object.
- `str` output is intended for human readability.
- `repr` is lower-level and returns a string that can be use to create a new instance of the object.

```python
my_str = 'abc'
print(my_str)       # abc
print(str(my_str))  # abc (same as print(my_str))
print(repr(my_str)) # 'abc' (note the quotes)
```

### Important Concepts

* Strings are ​[**passed by object reference**](20.pass_by_object_reference.md)​ to functions
* String methods ​**return new strings**​ rather than modifying existing ones
* String comparisons use **lexicographical (dictionary) ordering**
* Escape sequences like `\n`, `\t`, and `\\` for special characters

### Lexicographical (dictionary) ordering

When we talk about lexicographical ordering in string comparisons, we're referring to how Python determines whether one string is "greater than," "less than," or "equal to" another string. This is similar to how words are ordered in a dictionary (hence the term "dictionary ordering").

#### How Lexicographical Comparison Works?

When Python compares two strings using operators like `<`, `>`, `==`, `!=`, `<=`, or `>=`, it does so character by character, from left to right:

1.  Python compares the first character of each string using their Unicode code points  
2.  If they differ, the comparison result is determined immediately  
3.  If they're the same, Python moves to the next character and repeats the process  
4.  If one string is a prefix of the other (meaning it runs out of characters first), the shorter string is considered "less than" the longer one

* Python compares strings character-by-character from left to right in both strings. The comparison stops as soon as Python reaches a decision.
- `'abcdef' > 'abc'`. In this example, the strings have unequal sizes. Furthermore, the longer string is identical up to the shorter string's length. Python returns `True` here; when it can no longer take characters from the shorter string, it concludes that the longer string has the greater value. Similar behaviors occur with the other ordered comparison operators.
- It's also worth noting that even numeric strings are compared character by character. Thus, `'3' > '24'` returns `True` since the character `3` is greater than the character `2`.
- In general, numeric characters in a string are less than alphabetic characters, and uppercase letter characters are less than lowercase letters.

#### Unicode Ordering

The comparison is based on the Unicode code point (numerical value) of each character. In ASCII/Unicode:

•   Uppercase letters (`A-Z`) come before lowercase letters (`a-z`)  
•   Digits (`0-9`) come before letters  
•   Special characters have their own ordering
### Examples

```python
# String operations
name = "Python is cool"
greeting = "Hello, " + name + "!"  # 'Hello, Python is cool!'
repeated = name * 3  # Repetition: "Python is coolPython is coolPython is cool"

# Indexing and slicing
first_char = name[0]  # 'P'
substring = name[1:4]  # 'yth'

# String methods (Case Manipulation)
upper_name = name.upper()  # 'PYTHON IS COOL'
lower_name = name.lower()  # 'python is cool'
capitalize_name = lower_name.capitalize() # 'Python is cool'
title_name = name.title()  # 'Python Is Cool'
swapcase_name = name.swapcase() # 'pYTHON IS COOL'

# String methods (Testing)
has_alpha = name.isalpha()  # False (there are spaces in the String)
has_digits = name.isdigit()  # False
has_alnum = name.isalnum()   # False
is_space = name.isspace()    # False
is_upper = name.isupper()    # False
is_lower = name.islower()    # False

# String methods (Searching)
position = name.find('th')  # 2 (returns -1 if not found)
rfind = name.rfind('o')     # 12 (Highest Index)
idx = name.index('th')      # 2 (like find but raises ValueError if not found)
ridx = name.rindex('o')     # 12
count = name.count('o')     # 3

# String Modification
replace_name = name.replace('Python', 'JavaScript') # JavaScript is cool
new_name = " Python is cool "
strip = name.strip() # 'Python is cool'
lstrip = name.strip() # 'Python is cool '
rstrip = name.rstrip() # ' Python is cool'
split = name.split() # ['Python', 'is', 'cool']
split_join = ' '.join(split) # 'Python is cool'

# String formatting
age = 30
message = f"{name} is {age} years old"
```



## 5.) F-Strings

### Raw Strings and F-Strings

* String literals with an `r` prefix are **raw string literals**. Raw string literals don't recognize escapes, so you can use literal `\` characters freely.

```python
# Both of these print C:\Users\Xyzzy
print("C:\\Users\\Xyzzy")  # Each \\ produces a literal \
print(r"C:\Users\Xyzzy")  # raw string literal
```

* String literals with an `f` are **formatted string literals** or **f-strings**. These enable a way, via **string interpolation**, to embed expressions inside string literals.

```python
>>> f'5 plus 5 equals {5 + 5}.' 
'5 plus 5 equals 10.' 
>>> my_name = 'Karl' 
>>> f'My name is {my_name}.' 
'My name is Karl.' 
>>> my_name = 'Clare' 
>>> greeting = 'Ey up?' 
>>> f'{greeting} My name is {my_name}.' 
'Ey up? My name is Clare.
```

### Basic syntax

F-strings begin with the letter `f` or `F` before the opening quotation mark:

```python
name = "Ivan"  
profession = "programmer"  
greeting = f"Hello, {name}. You are a {profession}."
```

The expressions inside the curly braces `{}` are evaluated at runtime and converted to strings.

### Advantages of F-strings

1.  ​**Readability**​: They're more concise and easier to read than other formatting methods  
2.  ​**Performance**​: F-strings are generally faster than `str.format()` and `%` formatting  
3.  ​**Direct expression evaluation**​: You can put any valid Python expression inside the braces

### Comparison with `str.format()`

```python
name = "Ivan"  
profession = "programmer" 
greeting = "Hello, {}. You are a {}.".format(name, profession)
```

F-strings typically make your code more readable, especially with multiple variables.

### Advanced Features

You can also include formatting specifications within f-strings:

```python
pi = 3.14159  
print(f"Pi rounded to 2 decimal places: {pi:.2f}")
```



## 6.) String Methods

### Casing Methods

#### `upper()`

Converts string to uppercase

```python
first_name = "Ivan"
print(first_name.upper())    # IVAN
```

#### lower()

Converts string to lowercase

```python
last_name = "Hernandez"
print(last_name.lower())     # hernandez
```

#### `capitalize()`

Capitalizes first character of string and the rest lowercased

```python
city = "caracas"
print(city.capitalize())      # Caracas
```

#### `title()`

Converts first character of each word to uppercase

```python
book_title = "cien años de soledad"
print(book_title.title()).   # Cien Años De Soledad
```

#### ```swapcase()```

Return a copy of the string with uppercase characters converted to lowercase and vice versa.

```python
first_name = "Ivan"
print(first_name.swapcase())        # "iVAN"
```

### Search Methods

#### `str.find(sub)`

Returns lowest index where substring is found, or -1 if not found

```python
string = "Hello, World!"
print(string.find('o'))             # 4
print(string.find('x'))             # -1
```

#### `str.rfind(sub)`

Returns the highest index where the substring is found, or -1 if not found

```python
name = "Python is cool"
rfind = name.rfind('o')     # 12 (Highest Index)
```

#### `str.index(sub)`

Like find, but raises `ValueError` if substring not found

```python
string = "Hello, World!"
print(string.index('o'))             # 4
print(string.index('x'))             # ValueError
```

#### `str.rindex(sub)`

Like `rfind` but raises `ValueError` if substring not found

```python
name = "Python is cool"
rfind = name.rindex('o')     # 12 (Highest Index)
```

#### `str.count(sub)`

Counts occurrences of substring

```python
string = "Hello, World!"
print(string.count('o'))        # 2
```

### Check Methods

#### `str.startswith(prefix)` 

Checks if string starts with prefix

```python
string = "Today is a great day"
print(string.startswith('T'))   # True
```

#### `str.endswith(suffix)` 

 Checks if string ends with suffix

```python
string = "Today is a great day"
print(string.endswith('day'))    # True
```

#### `str.isalpha()` 

Checks if all characters are alphabetic

```python
string = "Today is a great day"
print(string.isalpha())        # False
string2 = "TodayIsAGreatDay"
print(string2.isalpha())       # True
```

#### `str.isdigit()` 

Checks if all characters are digits

```python
string = '12345'
print(string.isdigit())      # True
```

#### `str.isalnum()` 

Checks if all characters are alphanumeric

```python
string = "TodayIs2Good2BeTrue"
print(string.isalnum())       # True
```

#### `str.isspace()` 

Checks if all characters are whitespace

```python
string = " "
print(string.isspace())     # True
```

#### `str.islower()`

Check if all characters are in lower case

```python
string = 'hello world'
print(string.islower())    # True
```

#### `str.isupper()`

Check if all characters are in upper case

```python
string = "HELLO WORLD"
print(string.isupper())   # True
```
### Manipulation Methods

#### `str.strip()`

Removes leading and trailing whitespace (or specified characters)

```python
string = " Hello "
print(string.strip())   # Hello

string2 = "%Hello%"
print(string2.strip('%'))  # Hello
```

#### `str.lstrip()`

Removes leading whitespace (or specified characters)

```python
string = " Hello "
print(string.lstrip())   # Hello

string2 = "%Hello%"
print(string2.lstrip('%')) #Hello%
```

#### `str.rstrip()`

Removes trailing whitespace (or specified characters)

```python
string = "%Hello%"
print(string.rstrip('%'))    # %Hello
```

#### `str.replace(old, new)`

Replaces occurrences of 'old' with 'new'

```python
string = "Good Morning"
print(string.replace("Morning", "Afternoon"))  # Good Afternoon
```

#### `str.split(sep)`

Splits string by separator into a list

```python
string = "Good Morning Vietnam"
print(string.split())   # ["Good", "Morning", "Vietnam"]
```

#### `str.join(iterable)`

Joins elements of an iterable with the string as separator

```python
lst = ["Good", "Morning", "Vietnam"]
print(' '.join(lst)) # Good Morning Vietnam
```

## 7.) Boolean vs. Truthiness

### Boolean values

- `True`
- `False`

These are Boolean objects that you can assign to variables, pass as arguments, and return from functions.

### Truthiness

* Is a concept that refers to how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.
* Python can evaluate objects and values as either **truthy** or **falsy**.
- Truthiness arises in conditional expressions, such as `if` and `while` statements. Conditional expressions don't need to produce Boolean values. Instead, Python only needs to determine their truthiness. In an `if` statement, a conditional expression that evaluates as truthy causes the `if` block to execute. The `else` or `elif` block runs when the expression evaluates as falsy.

#### Python's built-in **falsy** values:

- `False`
- all numeric `0` values (integers, floats, complex)
- `None`
- `''` or `""`
- empty collections: `[]`, `{}`, `()`, `set()`, `frozenset()` and `range(0)`
- Custom data types can also define additional falsy values.

#### Python's **truthy** values:

- Anything that is not in the **falsy** list

### Truthiness and Short-Circuit Evaluation

- Logical operators don't always return `True` or `False`.
- They only care about the truthiness of their operands. 
- In each case, they evaluate as the object that evaluates last in the expression.

```python
print(3 and 'foo')   # last evaluated op: 'foo'
print('foo' and 3)   # last evaluated op: 3
print(0 and 'foo')   # last evaluated op: 0
print('foo' and 0)   # last evaluated op: 0

print(3 or 'foo')    # last evaluated op: 3
print('foo' or 3)    # last evaluated op: 'foo'
print(0 or 'foo')    # last evaluated op: 'foo'
print('foo' or 0)    # last evaluated op: 'foo'
print('' or 0)       # last evaluated op: 0
print(None or [])    # last evaluated op: []
```



## 8.) `None`

- Express the absence of a value.
- Data Type: `NoneType`
- Literal: `None`
- `None` **is a singleton object**​ - There is only one `None` object in Python.
- `None` **is falsy**​ - It evaluates to `False` in Boolean contexts
- Immutable
- **Implicit function returns**​ - Functions without an explicit `return` statement will return `None` by default.

### **Important Distinctions for PY109**

1. The difference between `None` and `False`: 
	-   `None` is the absence of a value, while `False` is a Boolean value  
	-  They are both falsy, but `None is not False`
	
2. When discussing function return values:  
    - Be specific about when a function returns `None`  
    - Distinguish between a function's output (what it prints) and its return value
   
3. Testing for `None`: 
	- Use `is None` or `is not None` rather than `== None` for identity comparison  
	- Remember that `None` is a singleton object



## 9.) Ranges

Are a built-in sequence type in Python used to represent a sequence of numbers.

### Basics

- A `range` object represents an immutable sequence of numbers
- Most commonly used in `for` loops to repeat actions a specific number of times
- Created using the `range()` function
- It's a non-primitive
- **`range(integer)`** doesn't produce the integers before a program ask for it. This optimizes memory. They are lazy sequences.

### Creating ranges

The `range()` function can be called with 1-3 arguments:

- `range(stop)`: Numbers from 0 up to but not including `stop`
- `range(start, stop)`: Numbers from `start` up to but not including `stop`
- `range(start, stop, step)`: Numbers from `start` up to but not including `stop`, incrementing by `step` 

### Key Characteristics

- Ranges are memory-efficient because they don't store all values in memory
- They're immutable (cannot be changed after creation)
- Support standard sequence operations like indexing, slicing, and iteration
- Can be converted to other sequences like lists with `list(range(...))`

### Examples

```python
>>> list(range(1, 10, 2))
[1, 3, 5, 7, 9]

>>> list(range(0, -5, -1))
[0, -1, -2, -3, -4]

# Basic range  
for i in range(5):  
    print(i)  # Prints 0, 1, 2, 3, 4

# With start and stop  
for i in range(2, 7):  
    print(i)  # Prints 2, 3, 4, 5, 6

# With step  
for i in range(1, 10, 2):  
    print(i)  # Prints 1, 3, 5, 7, 9

# Negative step (counting down)  
for i in range(10, 0, -1):  
    print(i)  # Prints 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
```



## 10.) List and Dictionary Syntax

### Lists and Tuples

#### Basics of Lists

- **Lists** are ordered, mutable collections that can store different types of data.
- **Lists** literals: `[]`
- The comma-delimited values are known as **elements**
- Use indexing syntax to retrieve specific elements.
- Use indexing syntax to reassign specific list elements. (**Element reassignment**)

##### Examples

```python
# Creating lists  
empty_list = []  
numbers = [1, 2, 3, 4, 5]  
mixed = [1, "hello", True, 3.14]  
  
# Accessing elements (zero-indexed)  
first_item = numbers[0]  # 1  
last_item = numbers[-1]  # 5  
  
# Slicing  
subset = numbers[1:4]  # [2, 3, 4]  
  
# Modifying lists  
numbers.append(6)       # adds 6 to the end  
numbers.insert(0, 0)    # inserts 0 at index 0  
numbers.remove(3)       # removes first occurrence of 3  
popped_item = numbers.pop()  # removes and returns last item  
numbers[0] = 99         # lists are mutable, can change elements
```

#### Basics of Tuples

- **Tuples** are ordered, immutable collections, often used for data that shouldn't change.
- **Tuples** literals = `()`

##### Examples

```python
# Creating tuples  
empty_tuple = ()  
single_item = (1,)      # comma is needed for single-item tuples  
coordinates = (10, 20)  
mixed_tuple = (1, "hello", True)  
  
# Accessing elements (same as lists)  
x = coordinates[0]      # 10  
  
# Attempting to modify will cause an error  
# coordinates[0] = 5    # TypeError: 'tuple' object does not support item assignment
```

#### Key Differences

- **Mutability**​: Lists can be modified after creation, tuples cannot.
- **Syntax**​: Lists use square brackets `[]`, tuples use parentheses `()`.
- **Performance**​: Tuples are slightly faster and use less memory.
- **Use cases**​: Lists for collections that change, tuples for data that shouldn't change.

#### Common Operations

```python
# Length  
len(numbers)              # number of items  
  
# Membership testing  
3 in numbers              # True if 3 is in numbers  
  
# Concatenation  
combined_list = [1, 2] + [3, 4]   # [1, 2, 3, 4]  
combined_tuple = (1, 2) + (3, 4)  # (1, 2, 3, 4)  
  
# Repetition  
repeated_list = [0] * 3   # [0, 0, 0]  
  
# Iteration  
for item in numbers:  
    print(item)  
      
# List comprehensions (lists only)  
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]  
  
# Unpacking  
a, b = coordinates       # a = 10, b = 20
```


### Mappings (Dictionaries)

#### Basics

- Maps are types that maintain an **unordered** collection of **key/value** pairs (also called elements or members).
- Maps are accessed by their keys.
- Each key is a unique identifier for a specific object in the mapping.
- The dictionary is the most common mapping in Python.
- Created using curly braces `{}` or the `dict()` constructor
- Dictionary or `dict` type.
- Dictionaries are mutable
- Elements are separated by commas. {key:value,...}
- You can access objects in a dict with the `[ ]` key access syntax
- You can use almost any immutable object as a key in a dict; it doesn't have to be a string
- The only significant requirement for keys is that they are hashable. immutable types are almost always hashable, while mutable types are almost always non-hashable.
- Tuples can be used as dictionary keys since they are immutable. However, this only applies if all the elements inside the tuple are also immutable and hashable. For example, a tuple that contains lists cannot be used as a dictionary key since lists are mutable and non-hashable, making the entire tuple non-hashable as well.
- The values in each key/value pair may be any object.

#### Creating Dictionaries

```python
# Empty dictionary 
empty_dict = {} 
# Dictionary with initial values 
student = {'name': 'John', 'age': 25, 'courses': ['Math', 'Science']}
```

#### Accessing Values

```python
student = {'name': 'John', 'age': 25}
print(student['name'])  # Output: John

# Using get() to avoid KeyError
print(student.get('grade', 'Not Found'))  # Output: Not Found
```

#### Modifying Dictionaries

```python
student = {'name': 'John', 'age': 25}
# Adding new key-value pairs
student['grade'] = 'A'
# Modifying existing values
student['age'] = 26
```

#### Iterating Through Dictionaries

```python
student = {'name': 'John', 'age': 25, 'grade': 'A'}

# Iterating through keys
for key in student:
    print(key)

# Iterating through key-value pairs
for key, value in student.items():
    print(f"{key}: {value}")
```

#### Dictionary Use Cases

During PY101, you likely used dictionaries for:

1.  Storing related data together  
2.  Creating lookup tables for values  
3.  Counting and tracking occurrences (e.g., character frequency in strings)  
4.  Representing more complex data structures

#### Common Patterns with Dictionaries

##### 1. Checking if a Key Exists:

```python
if 'name' in student:
    print("Name exists")
```

##### 2. Setting default values​: 

```python
# Using get()
value = student.get('grade', 'No grade assigned')

# Using setdefault()
student.setdefault('grade', 'N/A')  # Sets 'grade' to 'N/A' if it doesn't exist
```

##### 3. Dictionary comprehensions:

```python
# Create a dictionary of squares
squares = {x: x * x for x in range(6)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```





## 11.) List Methods

### Common List Methods

1. `append()` - Adds an element to the end of a list

```python
fruits = ["apple", "banana"] 
fruits.append("cherry") # fruits is now ["apple", "banana", "cherry"]
```

2. `extend()` - Adds all elements from another iterable to the end of the list

```python
fruits = ["apple", "banana"]
more_fruits = ["cherry", "orange"]
fruits.extend(more_fruits)  # fruits is now ["apple", "banana", "cherry", "orange"]
```

3. `insert()` - Adds an element at a specific position

```python
fruits = ["apple", "banana"] 
fruits.insert(1, "orange") # fruits is now ["apple", "orange", "banana"]
```

4. `remove()` - Removes the first occurrence of a specified value

```python
fruits = ["apple", "banana", "apple"] 
fruits.remove("apple") # fruits is now ["banana", "apple"]
```

5. `pop()` - Removes and returns the element at a specified position (or the last element if no index is provided)

```python
fruits = ["apple", "banana", "cherry"] 
last_fruit = fruits.pop() # last_fruit = "cherry", fruits = ["apple", "banana"]
first_fruit = fruits.pop(0) # first_fruit = "apple", fruits = ["banana"]
```

6. `clear()` - Removes all elements from the list

```python
fruits = ["apple", "banana"] 
fruits.clear() # fruits is now []
```

7. `index()` - Returns the index of the first occurrence of a specified value

```python
fruits = ["apple", "banana", "cherry"] 
index = fruits.index("cherry") # index = 2
```

8. `count()` - Returns the number of elements with the specified value

```python
fruits = ["apple", "banana", "apple"] 
count = fruits.count("apple") # count = 2
```

9. `sort()` - Sorts the list in-place

```python
fruits = ["cherry", "apple", "banana"] 
fruits.sort() # fruits is now ["apple", "banana", "cherry"]
```

10. `reverse()` - Reverses the order of elements in the list

```python
fruits = ["apple", "banana", "cherry"] 
fruits.reverse() # fruits is now ["cherry", "banana", "apple"]
```

11. `copy()` - Returns a shallow copy of the list

```python
fruits = ["apple", "banana"]  
fruits_copy = fruits.copy()  # fruits_copy = ["apple", "banana"]
```



## 12.) Dictionary Methods

### Creating Dictionaries

```python
# Empty dictionary
empty_dict = {}
empty_dict = dict()

# Dictionary with initial values
student = {'name': 'John', 'age': 25, 'courses': ['Math', 'Science']}
```

### Accessing Values

```python
student = {'name': 'John', 'age': 25}
print(student['name'])  # John

# Using get() to safely access keys (returns None if key doesn't exist)
print(student.get('grade'))  # None
print(student.get('grade', 'Not Found'))  # Not Found (custom default)
```

### Modifying Dictionaries

```python
student = {'name': 'John', 'age': 25}

# Adding or updating values
student['grade'] = 'A'
student['age'] = 26

# Update multiple key-values at once
student.update({'age': 27, 'grade': 'B', 'school': 'Launch School'})
```

### Removing Items

```python
student = {'name': 'John', 'age': 25, 'grade': 'A'}

# Remove specific key and return its value
age = student.pop('age')  # age = 25

# Remove and return the last inserted item (Python 3.7+ preserves insertion order)
last_item = student.popitem()  # ('grade', 'A')

# Clear all items
student.clear()  # {}

# Delete a specific key
del student['name']
```

### Methods for Iteration

```python
student = {'name': 'John', 'age': 25, 'grade': 'A'}

# Get all keys
keys = student.keys()

# Get all values
values = student.values()

# Get all key-value pairs as tuples
items = student.items()

# Iterating through a dictionary
for key in student:
    print(f"{key}: {student[key]}")

# Iterating through key-value pairs
for key, value in student.items():
    print(f"{key}: {value}")
```

### Other Useful Dictionary Methods

```python
# Copy a dictionary
student_copy = student.copy()

# Create a new dictionary with specified keys and default value
new_dict = dict.fromkeys(['name', 'age', 'grade'], 'Unknown')

# Check if a key exists
'name' in student  # True
'address' in student  # False

# Get length of dictionary
len(student)  # Number of key-value pairs
```



## 13.) Slicing

Slicing allows you to extract parts of sequences like strings, lists, and tuples.

### Syntax

```python
sequence[start:stop:step]
```

- `start`: The index where the slice begins (inclusive)
- `stop`: The index where the slice ends (exclusive)
- `step`: The interval between elements (default is 1)

All three parameters are optional:

```python
my_list[2:5]    # From index 2 up to (but not including) index 5
my_list[:5]     # From beginning up to (but not including) index 5
my_list[2:]     # From index 2 to the end
my_list[:]      # A copy of the entire sequence
my_list[::2]    # Every second element
```

### Negative Indices

Python allows negative indices, which count from the end:

```python
my_string = "Python"
my_string[-3:]   # "hon" (last 3 characters)
my_string[:-2]   # "Pyth" (all except last 2 characters)
```

### Reverse Slicing

You can use a negative step to reverse the direction:

```python
my_list = [1, 2, 3, 4, 5]
my_list[::-1]    # [5, 4, 3, 2, 1] (reversed list)
my_list[4:1:-1]  # [5, 4, 3] (from index 4 to index 2, reversed)
```

### Common Applications

1. Extracting substrings: `name = "Launch School"; first_name = name[:6]`
2. Creating copies of sequences: `new_list = original_list[:]`
3. Reversing sequences: `reversed_string = my_string[::-1]`
4. Removing elements from start/end: `without_first_two = my_list[2:]`

### Important Notes

- Slicing creates a new object; it doesn't modify the original
- Out-of-range indices in slices don't cause errors (unlike direct indexing)
- Slices can be used as targets for assignments: `my_list[1:3] = [10, 20]`
- You get an empty slice when the start and stop values are the same.
- Slicing performs a shallow copy if the sequence contains any collections (lists or tuples).

```python
seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(seq[3:7])       # [4, 5, 6, 7]
print(seq[-6:-2])     # [5, 6, 7, 8]
print(seq[2:8:2])     # [3, 5, 7]
print(seq[3:3])       # []
print(seq[:])         # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] => returns a duplicated sequence
print(seq[::-1])      # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] returns a reverse copy of a sequence

seq = [[1, 2], [3, 4]]
seq_dup = seq[:]
print(seq[0] is seq_dup[0])   # True
```


## 14.) Operators

### Arithmetic operators
#### Addition

```python
print(5 + 5)     # 25
print(5.0 + 5.0) # 10.0
# mixing integers and floats
print(5 + 5.0)   # 10.0
```

#### Subtraction

```python
print(5 - 5)     # 0
print(5.0 - 5.0) # 0.0
# mixing integers and floats
print(5 - 5.0)   # 0.0
```

#### Multiplication

```python
print(5 * 5)     # 25
print(5.0 * 5.0) # 25.0
# mixing integers and floats
print(5 * 5.0)   # 25.0
```

#### Division 

```python
print(15 / 3)   # 5.0
print(19 / 2.5) # 7.6
```

#### Integer Division (Floor Division)

```python
print(16 // 3)     # 5
print(16 // -3)    # -6
print(16 // 2.3)   # 6.0
print(-16 // 2.3)  # -7.0
```

- The `//` operator returns the largest whole number less than or equal to the floating point result. This is quite simple when you visualize a number line: -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6. Let's start at zero. Going right means the numbers _increase,_ whilst going left means the numbers _decrease_. So, integer division indeed returns the largest whole number _less than or equal to_ (<=) the floating-point result: 16//3 -> 5.33333...  -> 5 (because rounding 5.33333 _down_ gives us 5 (find the floating-point result on the number line and move _left_))So... now let's consider 16//-3.  16//-3 -> -5.33333... -> ? (well, if we consult our number line again, our dear -5 "sits" between -6 and -5. Which of these two numbers is _less_ (i.e. to the _left_)? Well, -6. So, this means rounding -5.33333... _down_ results in -6)

#### Exponentiation (powers)

```python
print(16 ** 3)     # 4096
```

#### Modulo

- The `%` operator is called the **modulo operator**.
- The result of the operation is called a modulus and not remainder.
- As long as both numbers have the same sign, modulo and remainder are equivalent operations.
- There is one situation where you can safely use `%` without worrying about negative numbers: when you only care about divisibility. If `x % y == 0`, then `x` is evenly divisible by `y`. It doesn't matter whether `x` or `y` is negative.

```python
# 15 // 3 is 5; what's the remainder?
print(15 % 3)   # 0
print(16 % 3)   # 1
print(17 % 3)   # 2
print(18 % 3)   # 0
```

#### Floating Point Imprecision

```python
print(0.1 + 0.2 == 0.3)       # False
```

- One way around the problem in Python is to use the `math.isclose` function:

```python
import math
math.isclose(0.1 + 0.2, 0.3)  # True
```

- You can also use the `decimal.Decimal` type to make precise computations:

```python
from decimal import Decimal
Decimal('0.1') + Decimal('0.2') == Decimal('0.3')
# True
```

- always use strings with `decimal.Decimal`. You can use float values. However, you will lose the benefit of precise computation if you do.

### String operators

#### String Concatenation

- Use `+` and `*` operators to join strings
```python
>>> 'foo' + 'bar'
'foobar'
```

```python
print('abc' * 3)              # 'abcabcabc'
print(3 * 'abc')              # 'abcabcabc'
```

### List Operators

### Comparison operators

- Comparison operators return a Boolean value: `True` or `False`.
- **Operands** are the expressions to the left and right of an operator.

#### The **equality operator** (`==`)

- The **equality operator** returns `True` when the operands have equal values, `False` otherwise.
- In most cases, operands must have the same type and value to be equal. Thus, `5` is not equal to `'5'`. There are some places where you can mix types, however. For instance, integers and floats that are mathematically equivalent are usually, but not always, considered equal:

```python
print(5 == float(5))                # True

big_num = 12345678901234567
print(float(big_num) == big_num)    # False
```

- While `casefold` is only needed when working with non-US characters, it's best practice in Python to use `casefold` instead of `lower` or `upper`, especially when comparing strings. **(Check this with LSBot**).

#### The **inequality operator** (`!=`)

- is `==`'s inverse: It returns `False` when `==` would return `True`, and `True` when `==` would return `False`. It returns `False` when the operands have the same type and value, `True` otherwise. Other than the return value, the behaviors of `==` and `!=` are identical.


#### The **less than operator** (`<`) and **less than or equal to operator** (`<=`)

- The **less than operator** (`<`) returns `True` when the value of the left operand has a value that is less than the value on the right, `False` otherwise. The **less than or equal to operator** (`<=`) is similar, but it also returns `True` when the values are equal; `<` returns `False` when the operands are equal.
- Python compares strings character-by-character, moving from left to right. It looks for the first character that differs from its counterpart in the other string. Once it finds differing characters, it compares them to determine the relationship. If both strings are equal up to the shorter string's length, as in the last two examples, the shorter one is considered less than the longer one.

```python
print('42' < '402')       # False
print('42' < '420')       # True
print('420' < '42')       # False
```

#### The **greater than operator** (`>`) and **greater than or equal to operator** (`>=`)

- The **greater than operator** (`>`) returns `True` when the value of the left operand has a value that is greater than the value on the right, `False` otherwise. The **greater than or equal to operator** (`>=`) is similar, but it also returns `True` when the values are equal; `>` returns `False` when the operands are equal.
- As with `<` and `<=`, you can compare strings with the `>` and `>=` operators; the rules are similar.

```python
print(42 < 41)           # False
print(42 < 42)           # False
print(42 <= 42)          # True
print(42 < 43)           # True

print('abcdf' < 'abcef') # True
print('abc' < 'abcdef')  # True
print('abcdef' < 'abc')  # False
print('abc' < 'abc')     # False
print('abc' <= 'abc')    # True
print('abd' < 'abcdef')  # False
print('A' < 'a')         # True
print('Z' < 'a')         # True

print('3' < '24')        # False
print('24' < '3')        # True
```

- Strings are compared **lexicographically**, meaning they are compared character-by-character from left-to-right. 
- Python compares strings character-by-character from left to right in both strings. The comparison stops as soon as Python reaches a decision.
- `'abcdef' > 'abc'`. In this example, the strings have unequal sizes. Furthermore, the longer string is identical up to the shorter string's length. Python returns `True` here; when it can no longer take characters from the shorter string, it concludes that the longer string has the greater value. Similar behaviors occur with the other ordered comparison operators.
- It's also worth noting that even numeric strings are compared character by character. Thus, `'3' > '24'` returns `True` since the character `3` is greater than the character `2`.
- In general, numeric characters in a string are less than alphabetic characters, and uppercase letter characters are less than lowercase letters.
- As with `==` and `!=`, many other types besides numbers and strings work with the ordered comparison operators. For instance, you can compare sets with these operators to determine if set a is a subset or superset of set b. You can also compare lists and tuples: like string comparisons, list and tuple comparison goes element by element to determine which object is less than or greater than the other:


```python
print({3, 1, 2} < {2, 4, 3, 1})         # True
print({3, 1, 2} > {2, 4, 3, 1})         # False
print({2, 4, 3, 1} > {3, 1, 2})         # True

print([1, 2, 3] < [1, 2, 3, 4])         # True
print([1, 4, 3] < [1, 3, 3])            # False
print([1, 3, 3] < [1, 4, 3])            # True
```

### Logical operators

#### `not`

- The **not operator** returns `True` when its operand is `False` and returns `False` when the operand is `True`. That is, it negates its operand.
- `not` takes a single operand; it appears to the operator's right. Operators that take only one operand are called **unary operators**. Operators that take two operands are **binary operators**.

#### `and` and `or`

- The **and operator** returns `True` when both operands are `True`. It returns `False` when either operand is `False`.
- The **or operator** returns `True` when either operand is `True` and `False` when both operands are `False`.
- The following **truth** table shows how `True` and `False` interact with the `and` and `or` operators:

| **A**   | **B**   | **A and B** | **A or B** |
| ------- | ------- | ----------- | ---------- |
| `True`  | `True`  | `True`      | `True`     |
| `True`  | `False` | `False`     | `True`     |
| `False` | `True`  | `False`     | `True`     |
| `False` | `False` | `False`     | `False`    |
### Short Circuits

- The `and` and `or` operators use a mechanism called **short circuit evaluation** to evaluate their operands.
- When Python evaluates these operators, it stops as soon as it can determine the final result, without necessarily evaluating all parts of the expression.
- For the `and` operator:
	- If the first operand is `falsy`, Python returns that value immediately without evaluating the second operand.
	- If the first operand is `truthy`, Python evaluates and returns the second operand.
- For the `or` operator:
	- If the first operand is `truthy`, Python returns the value immediately without evaluating the second operand.
	- If the first operand is `falsy`, Python evaluates and returns the second operand.

### Identity operators

- `is`: Returns True if both variables are the same object
- `is not`: Returns True if the variables are not the same object
### Operator Precedence

1.  Parentheses `()`  
2.  Exponentiation `**`  
3.  Unary operators `+x`, `-x`  
4.  Multiplication/division `*`, `/`, `//`, `%`  
5.  Addition/subtraction `+`, `-`

### Logical Operator precedence

- `==`, `!=`, `<=`, `<`, `>`, `>=` - Comparison
- `not` - Logical NOT
- `and` - Logical AND
- `or` - Logical OR
## 15.) Mutability and Immutability

### What is the definition of mutable/immutable?

* Mutable types are types whose objects can be changed after they are created.
* Immutable types cannot be changed after they are created.

### Mutable objects

Mutable objects can be modified after creation. In Python, these include:

- Lists
- Dictionaries
- Sets
- User-defined classes (by default)

### Immutable objects

Immutable objects cannot be modified after creation. In Python, these include:

- Integers
- Floats
- Strings
- Tuples
- Frozensets

Understanding mutability helps predict how your code will behave and is essential for avoiding unexpected side effects in your programs.


## 16.) Pass by Object Reference

This concept explains how arguments are handled when passing to functions. 

### What is it?

In Python, when you pass an argument to a function, you're actually passing a reference to the object, not the object itself. However, whether you can modify the original object depends on whether that object is mutable or immutable.

### Immutable objects

```python
def change_name(name):
    name = 'bob'  # reassignment

name = 'jim'
change_name(name)
print(name)  # Output: jim
```

In this example, the string `'jim'` is immutable. When the function tried to reassign the parameter `name`, it only modified the local variable inside the function, not the original variable outside the function.

Here Python behaves as if "Pass-by-Value"

### Mutable Objects

```python
def add_element(my_list):
    my_list.append([4])  # modifying the object

my_list = [1, 2, 3]
add_element(my_list)
print(my_list)  # Output: [1, 2, 3, [4]]
```

Here, the list is mutable, and when we use a method like `append()` that modifies the list in-place, the original list outside the function is also modified.

### Reassignment vs. Modification

```python
def add_element(my_list):
    my_list = my_list + [4]  # reassignment, not modification

my_list = [1, 2, 3]
add_element(my_list)
print(my_list)  # Output: [1, 2, 3]
```

In this case, even though lists are mutable, the operation `my_list = my_list + [4]` is a reassignment operation, not a modification. This creates a new list object and assigns it to the local variable `my_list`, without affecting the original list.

### The Key to Understanding

The behavior in Python is neither pure "pass by value" nor pure "pass by reference" - it's a hybrid approach called "pass by object reference." Here's what this means:

- Python always passes references to objects, never copies of the objects themselves
- For immutable objects (strings, numbers, tuples), you cannot modify the object itself
- For mutable objects (lists, dictionaries, sets), you can modify the object if you use methods that change the object in-place
- Reassignment of a parameter always creates a new local variable, regardless of whether the object is mutable or immutable



## 17.) Variables

### Definitions

- **Variables** are labels that point to values in memory
- **Identifiers** refer to: 
	- Variable and constant names
	- Function and method names
	- Function and method parameter names
	- Class and module names

### Naming Conventions

- Names that follow the naming conventions are called **idiomatic**
- Names that do not follow the naming conventions are called **non-idiomatic**
- Names that are not allowed are called **illegal**

#### Naming conventions for most identifiers (except constants and class names):

- Use **snake_case**.
- Names may contain: (`a-z`), (`0,9`) and (`_`).
- Names should begin with a letter.
- When using multiple words, separate them with a single (`_`).
- Names may only use letters and digits from the standard ASCII character set. (Extended ASCII and Unicode letters and digits are allowed, but are **non-idiomatic** )

#### Naming conventions for Constant names:

- Use **SCREAMING_SNAKE_CASE**.
- Names may contain: (`A-Z`), (`0,9`) and (`_`).
- Names should begin with a letter.
- When using multiple words, separate them with a single (`_`).
- Names may only use letters and digits from the standard ASCII character set. (Extended ASCII and Unicode letters and digits are allowed, but are **non-idiomatic** )

#### Naming conventions for Class names:

- Use **PascalCase**, also called **CamelCase** .
- Names may contain uppercase and lowercase letters (`A-Z, a-z`) and digits (`0-9`).
- Names should begin with an uppercase letter.
- When using multiple words, capitalize each word.

#### Illegal names:

- You may not use punctuation characters, most special characters, or whitespace.
- You may not start identifiers with a digit.
- You may not use Python's reserved words such as `if`, `def`, `while`, `return`, and `pass` as names.

### Creating and Reassigning Variables

- We create (**initialize**) a variable by simply giving it a value. That happens as part of an assignment statement:

```python
forename = 'Clare'            # initialization
```

- We can also give new values to variables by simply **reassigning** them:

```python
forename = 'Victor'           # reassignment
```

- Way to describe an assignment: The variable `foo`is assigned the value of `bar`.

### Creating Constants

- Constants are created (**initialized**) in the same way as variables: by giving them a value:

```python
PINING_FOR = 'fjords'         # initialization
```

- Constants should never be reassigned.
- Python does not support true constants. Instead, the **SCREAMING_SNAKE_CASE** naming convention is solely for programmers.

### Augmented Assignment

- It's a shorthand notation also called **assignment operators**, of the process of taking the current value of a variable, perform an operation on the variable's value, and then reassign the variable to the newly computed value.
- **Augmented assignment** is a statement, not an expression. You can't use augmented assignment as a function argument or return value

```python
foo = 42            # foo is 42
foo -= 2            # foo is now 40
foo *= 3            # foo is now 120
foo += 5            # foo is now 125
foo //= 25          # foo is now 5
foo /= 2            # foo is now 2.5
foo **= 3           # foo is now 15.625
print(foo)          # prints 15.625

def foo(bar):
    print(bar)

a = 3
foo(a *= 2)
#     ^^
# SyntaxError: invalid syntax

def foo():
    a = 3
    return a *= 2
#            ^^
# SyntaxError: invalid syntax
```

### Reassignment vs. Mutation

- There are two ways to change things in Python:
	- Change the **binding** of the variable by making it reference a new object (**Reassignment**)
	- Change the value of the object assigned (**bound**) to the variable (**Mutation**).
- **Reassignment** makes the variable name refer to a different object somewhere else in memory.
- **Mutation** does not change which object the variable refers to, instead it changes the object itself. After mutating an object assigned to a specific variable, the variable continues to refer to the same object (albeit altered) at the same memory location.
- **Reassigning** an element of a mutable collection doesn't reassign the variable; it mutates the collection.

```python
num = 3               # assignment (initialization)
my_list = [1, 2, 3]   # assignment (initialization)
my_dict = {           # assignment (initialization)
    'a': 1,
    'b': 2,
}

num = 42              # Reassignment
my_list[1] = 42       # Reassignment of element,
                      # my_list is mutated!
my_dict['b'] = 3      # Reassignment of dict pair
                      # my_dict is mutated!

# You can still reassign the variables
my_list = [2, 3, 4]   # Reassignment
my_dict = { 'x': 0 }  # Reassignment
```

### Variable Scope

Variable scope refers to the parts of a program where a variable can be accessed by name.

Python has two main types of scope:

#### Global scope

Variables defined outside of any function have global scope, meaning they can be accessed from anywhere in your program.

```python
num = 5  # Global variable

def my_func():
    print(num)  # Can access the global variable

my_func()  # Outputs: 5
```

#### Local scope

Variables defined inside a function have local scope, meaning they can only be accessed within that function.

```python
def my_func():
    local_var = 10  # Local variable
    print(local_var)

my_func()  # Outputs: 10
print(local_var)  # This would cause an error - local_var is not defined here
```


### `global` keyword

You can access global variables inside a function:

```python
num = 5

def my_func():
    print(num)  # Accessing is fine

my_func()  # Outputs: 5
```

But if you try to assign to a global variable inside a function, Python will create a new local variable instead:

```python
num = 5

def my_func():
    num = 10  # Creates a new local variable, not modifying the global one

my_func()
print(num)  # Still outputs: 5
```

To modify a global variable inside a function, use the `global` keyword:

```python
num = 5

def my_func():
    global num
    num = 10  # Now modifies the global variable

my_func()
print(num)  # Outputs: 10
```

### **Common Pitfall**

Be careful when you try to modify a global variable before declaring it as global:

```python
my_var = "Hello"

def my_func():
    my_var = my_var + " world"  # Error: UnboundLocalError
    return my_var

my_func()
```

This happens because Python sees the assignment to `my_var` and treats it as a local variable, but then tries to use it before it's been assigned a value.
### Variables as Pointers

In Python, variables don't actually contain values directly. Instead, they act as references or pointers to objects in memory.

#### **How Variables Work in Python**

When you create a variable in Python, what actually happens is:

1.  Python creates an object in memory to store the value  
2.  Python then associates the variable name with a reference (or pointer) to that object's location in memory

```python
number = 42
```

In this example, Python:
- Creates an integer object with value 42 in memory
- Associates the name 'number' with the memory location of that object

#### **Variable Assignment**

When you assign a value to a variable, you're creating a new reference:

```python
a = [1, 2, 3]  # 'a' points to a list object
b = a          # 'b' now points to the SAME list object
```

Both `a` and `b` point to the same list object in memory. This has important implications when working with mutable objects.

### **Mutability and References**

The pointer concept becomes especially important when considering mutable vs. immutable objects:

#### **With Mutable Objects (lists, dictionaries, sets):**

```python
a = [1, 2, 3]
b = a          # both variables point to the same list
b.append(4)    # modifies the list that both variables point to
print(a)       # Output: [1, 2, 3, 4]
```

When you modify a mutable object through one variable, the change is visible through all variables pointing to that object.

#### **With Immutable Objects (numbers, strings, tuples):**

```python
a = 5
b = a
b = 10         # creates a new integer object, reassigns b to point to it
print(a)       # Output: 5 (unchanged)
```

For immutable objects, any "modification" actually creates a new object and updates the reference.

#### **Checking Identity with `id()`**

You can verify that variables point to the same object using the `id()` function:

```python
a = [1, 2, 3]
b = a
print(id(a) == id(b))  # Output: True - they point to the same object
```


### Variable Shadowing

Variable shadowing occurs when a variable in an inner scope has the same name as a variable in an outer scope, effectively "hiding" or "shadowing" the outer variable.

```python
x = 10  # Global variable

def my_func():
    x = 20  # Local variable shadows the global variable
    print(f"Inside function: {x}")  # Accesses the local x

my_func()
print(f"Outside function: {x}")  # Accesses the global x
```

This code would output:

```python
Inside function: 20  
Outside function: 10
```

#### **Why This Happens**

In Python, when you assign a value to a variable inside a function without declaring it as `global`, Python creates a new local variable instead of modifying the global one. This new local variable with the same name "shadows" the global variable within that function's scope.

Consider this slightly more complex example:

```python
def my_func():
    x = 15  # Local to my_func
    
    def inner_func1():
        x = 25  # Local to inner_func1, shadows my_func's x
        print(f"Inner 1: {x}")
        
    def inner_func2():
        print(f"Inner 2: {x}")  # Uses my_func's x
        
    inner_func1()
    inner_func2()

my_func()
```

Output:

```python
Inner 1: 25
Inner 2: 15
```

- The variable `x` in `inner_func1` shadows the `x` from `my_func`
- `inner_func2` doesn't define its own `x`, so it accesses the `x` from the outer scope (`my_func`)

#### **Why Understanding Variable Shadowing Matters**

Variable shadowing is important to understand because:
- It can lead to unexpected behavior if you're not aware of it
- It makes your code harder to debug when variables with the same name exist in different scopes
- It's a common source of bugs for programmers new to Python's scoping rules

## 18.) Conditionals and Loops

### Conditionals

Allow your code to make decisions based on different conditions.

#### **Basic Conditional Statements**

In Python, the basic conditional structure uses `if`, `elif` (else if), and `else` keywords:

```python
if condition1:
    # code executed if condition1 is True
elif condition2:
    # code executed if condition1 is False and condition2 is True
else:
    # code executed if all previous conditions are False
```

- **Block** is one or more Python statements or expressions.
- `else` block isn't a proper statement; it's part of the `if` statement.
- You have as many `elif` blocks as you need. They are evaluated in the order they appear in the code.
- All statements in a block must be indented from the statement that begins the block. The indentation in a block must be consistent.
- Every once in a while, you may want to create a block in an `if` statement that does nothing. We usually do this for readability purposes. However, blocks can't be empty. Instead, you have to use a `pass` statement.

#### match/case Statement

- The `match` statement compares a single value against multiple values, whereas `if` statement can test multiple expressions with any condition.
- The statements in the `case _` block run when the expression doesn't match any other case blocks.
- If you want to match multiple values in a case, you can do so by using the | character to separate item values

```python
value = 5

match value:
    case 1 | 2 | 3 | 4:
        print('value is < 5')
    case 5 | 6:
        print('value is 5 or 6')
    case _: # default case
        print('value is not 1, 2, 3, 4, 5, or 6')
# value is 5 or 6
```

### Ternary Expressions

- A ternary expression is a concise way to choose between two values based on some condition.
- They are often used as an expression on the right side of an assignment, as function arguments, and as function return values.

```python
value1 if condition else value2
```
- Python first evaluates the condition. If it's truthy, the expression returns value1. Otherwise, it returns value2. The return value is either value1 or value2, depending on which expression gets evaluated.

### Loops and Iterating

- Loops runs while a given condition remains truthy or until it becomes falsy.
- Python loops mechanisms: for, while, comprehensions, generators and functional loops.

#### while Loops

- Syntax: `while` `<conditional expression>:` `block of code`
- We must arrange to terminate the loop, otherwise the loop is an **infinite loop** 
- Each block run is called an **iteration**

```python
counter = 1
while counter <= 10:
    print(counter)
    counter += 1
```

#### for Loops

- Syntax: `for` element in `iterable`:

```python
for element in collection:
    # loop body: do something with the element
```

#### Controlling Loops

- Keyword `continue`: starts a new loop iteration, it skips running the rest of the block and jumps ahead to the next iteration. The `continue` statement tells Python to start the next iteration of the nearest enclosing loop. You can't start a new iteration of an outer loop if you're currently in an inner (nested) loop.
- Keyword `break`: terminates the loop early. The `break` statement tells Python to terminate the nearest enclosing loop once we find the desired element. You can't break out of an outer loop if you're currently in an inner (nested) loop.
- `else`clause: Loops can have an `else` clause that executes when the loop completes normally (not via `break`).

### **Common Loop Patterns**

1.  ​**Counting**​: Keeping track of occurrences.  
2.  ​**Accumulation**​: Building up a result through iterations.  
3.  ​**Searching**​: Finding elements that meet specific criteria.  
4.  ​**Transformation**​: Creating a new collection based on an existing one.

### Simultaneous Iteration

- The `zip` function  is specifically designed to make simultaneous iteration easy.
- `zip` creates a lazy sequence that acts like a list of tuples.

```python
forenames = ['Ken', 'Lynn', 'Pat', 'Nancy']
surnames = ['Camp', 'Blake', 'Flanagan', 'Short']

zipped_names = zip(forenames, surnames)
for forename, surname in zipped_names:
    print(f'{forename} {surname}')
```

### Comprehensions

- Are ways of creating mutable collections from existing iterable collections.
- There are 3 types: **list, dict and set**.
- Comprehensions are expressions and not statements.
- You can use a comprehension on the right side of an assignment, as a function argument, as a return value, or any other place where you can use an expression that evaluates as a list, dict, or set. You can even use them as standalone expressions.

#### List Comprehensions

- They take an iterable collection and create a new list through iteration and optional selection.
- Syntax: `[ expression for element in iterable if condition]`
- The `if condition` portion is optional: it tells Python to select only certain elements from the `iterable`.
- The `for element in iterable` portion describes the iteration: it looks exactly like a `for` loop.
- The `expression` is a value that gets returned by each iteration of the loop.
- The `expression` in a comprehension often performs a **transformation**. It determines a new value based on an element from the original collection. Such comprehensions are called **transformations**.
- If the `if condition` portion is present, we say that the comprehension also performs **selection**.
- Multiple selection criteria act like nested `if` statements or as `and`-ed conditions. The selections combine, so only collection members matching all criteria are selected.

**transformative** list comprehension:

```python
squares = [ number * number for number in range(5) ]
print(squares)      # [0, 1, 4, 9, 16]
```

**selection** example:

```python
multiples_of_6 = [ number for number in range(20)
                   if number % 6 == 0 ]
print(multiples_of_6)      # [0, 6, 12, 18]
```

**selection** and **transformation**: 

```python
even_squares = [ number * number
                 for number in range(10)
                 if number % 2 == 0 ]
print(even_squares)      # [0, 4, 16, 36, 64]
```

**multiple selection**

```python
cats_colors = {
    'Tess':   'brown',
    'Leo':    'orange',
    'Fluffy': 'gray',
    'Ben':    'black',
    'Kat':    'orange',
}

names = [ name.upper()
          for name in cats_colors
          if cats_colors[name] == 'orange'
          if name[0] == 'L' ]
print(names) # ['LEO']
```

#### Dictionary Comprehensions

- **Dictionary comprehensions** are almost identical to list comprehensions. However, they create new dictionaries instead of lists.
- Syntax: `{ key: value for element in iterable if condition }`

```python
squares = { f'{number}-squared': number * number
            for number in range(1, 6) }
print(squares)
# pretty-printed for clarity.
{
    '1-squared': 1,
    '2-squared': 4,
    '3-squared': 9,
    '4-squared': 16,
    '5-squared': 25
}
```

#### Set Comprehensions

- **Set comprehensions** look almost identical to dict comprehensions. However, they create a new set instead of a dict and only have one expression to the left of the word `for`
- Syntax: `{ expression for element in iterable if condition }`

```python
squares = { number + 1 for number in range(1, 6) }
print(squares)      # {2, 3, 4, 5, 6}
```





## 19.) `print()` and `input()`

### Input/Output

#### Terminal Output

- `print`function: takes any value and prints it.
- The `print()` function works with all data types, but the formatting output is not always understandable to humans
- You can print multiple objects by just listing them one after the other as arguments to `print()`:

```python
>>> print(1, 2, 3, 'a', 'b')
1 2 3 a b

>>> print([1, 2, 3], 4, False, { 5, 6, 7, 8})
[1, 2, 3] 4 False {8, 5, 6, 7}
```

- keyword argument `sep` is used to separate the values printed.
- The `end` keyboard defines what `print()` prints after it prints the last argument. By default, it prints a newline (`\n`). The most common reasons for using `end` are compatibility with Windows (which sometimes needs a newline of `\r\n`) and for suppressing the newline altogether.

```python
>>> print(1, 2, 'a', 'b', sep=',', end=' <-\n')
1,2,a,b <-

>>> print('a', 'b', end='', sep=','); print('c', 'd', sep=',')
a,bc,d
```

- Note the semicolon (`;`) on line 4: that's an easy way to enter multiple statements on a single line. Mostly, you should only use semicolons like this in the REPL.

#### Terminal Input

- `input()` is a built-in function that lets Python read input from the terminal.

```python
number1 = input('Enter the first number: ')
number2 = input('Enter the second number: ')
sum = float(number1) + float(number2)

print(f'The numbers {number1} and {number2} add to {sum}')
```


## 20.) Exceptions

### **Key Points About Exceptions in Python**

1. **What They Are**​: Exceptions are events that occur during program execution that disrupt the normal flow of instructions.
2. **When They Occur**​: You should be able to identify common situations that trigger exceptions, such as:
	1. Attempting to divide by zero
	2. Accessing an index that doesn't exist in a sequence
	3. Using an undefined variable
	4. Type errors (trying operations with incompatible types)
	5. Value errors (passing inappropriate arguments to functions)
3. **How to Handle Them**​: You should understand exception handling using the try/except blocks:

```python
try:
       # Code that might cause an exception
except ExceptionType:
       # Code to run if that exception occurs
```

4. **Common Exception Types**​: Know the basic exception types like ValueError, TypeError, IndexError, KeyError, ZeroDivisionError, etc.


## 21.) Functions

### Functions and Methods

- Blocks of code that run as a separate unit.
- Benefits:
    - Reduce repetitive code
    - Easy code reuse
    - improve code readability and maintainability.
- Methods are limited to specific objects

### Calling Functions

- Using a function means **calling**, **invoking**, **executing** or **running** it.
- **Flow**: 
    - Python encounters a function call
    - It transfers program flow to the code that comprises the function and executes that code.
    - When the code finish, the function **returns** a value to the code that invoked it.
    - The calling code uses or not the return value.
    - Executions resumes from where the function was called.

- To invoke a function, write function's name followed by a pair of parentheses `()`. Example:

```python
def hello():            #
    print('Hello')      # These 3 lines contain the function definition
    return True         #

hello()         # invoking function; ignore return value
print(hello())  # using return value in a `print` call
```
- Functions can take one or more command-separated **arguments** between the parentheses. They usually use arguments to modify the actions they take.

```python
print('hello', 'good-bye', 'farewell')
```

### Built-in Functions

#### `min` and `max`

- They are used to determine a collection's minimun and maximun values.
- The collection's objects must have an ordering that recognizes the `<` and `>` operators for comparing any pair of those objects.

```python
print(min(-10, 5, 12, 0, -20))      # -20
print(max(-10, 5, 12, 0, -20))      # 12

print(min('over', 'the', 'moon'))   # 'moon'
print(max('over', 'the', 'moon'))   # 'the'

print(max(-10, '5', '12', '0', -20))
# TypeError: '>' not supported between instances
# of 'str' and 'int'
```

#### `ord` and `chr`

- `ord`: given a single character, returns an integer that represents the Unicode or ASCII code point of that character.

```python
print(ord('a'))               # 97
print(ord('A'))               # 65
print(ord('='))               # 61
print(ord('~'))               # 126
```
- `chr` is the inverse of `ord`: converts an integer into the corresponding Unicode character.

```python
print(chr(97))                # a
print(chr(65))                # A
print(chr(61))                # =
print(chr(126))               # ~
```

#### `any` and `all`

- Both operate on iterable collections.
- `any` returns `True` if any element in a collection is truthy.
- `any` returns `False` if all the elements in a collection are falsy.
- `all` returns `True` if all the elements in a collection are truthy.
- `all` returns `False` if all elements in a collection are falsy.

```python
collection1 = [False, False, False]
collection2 = (False, True, False)
collection3 = {True, True, True}

print(any(collection1))       # False
print(any(collection2))       # True
print(any(collection3))       # True
print(any([]))                # False ("Are any of the members truthy? No.")

print(all(collection1))       # False
print(all(collection2))       # False
print(all(collection3))       # True
print(all([]))                # True ("Are all of the members truthy? Yes, because we would need sth falsy to return False.")
```
- `print(all[])` returns `True` because: this is termed a "vacuous truth"... since there is nothing in the list, there are no false elements in the list, and by definition all() can only return False when the list contains at least one False ...so, since all zero elements in the list are not False, all() "has to" return True (so as not to contradict itself)

### Functions for the REPL

#### The id Function

- Returns an integer that serves as an object's **identity**. 
- Every object has a unique identity that does not change during the object's lifetime.
- The identity may be reused later in the program if the original object is discarded.
- In most cases, two instances of an object with the same value will always have two distinct identities. This is not always true.
- There is a process called **interning** use for optimization/performance in which string and integer values in memory are reused, so the id of both variables is the same:

```python
# Paste this code into the Python REPL
# Don't run it as a program

s = 'Hello, world!'
t = 'Hello, world!'
print(id(s) == id(t))         # False

s = 'supercalifragilisticexpialidocious'
t = 'supercalifragilisticexpialidocious'
print(id(s) == id(t))         # True

x = 5
y = 5
print(id(x) == id(y))         # True

x = 5
y = 6
print(id(x) == id(y))         # False
```

#### The dir Function

- Without arguments it returns a list of all **identifiers** in the current local scope.
- With an argument, returns a list of the object's attributes.
- Many of the names shown by `dir` begin and end with two underscores. These are called **dunder**(double-underscore) or **magic methods** and **magic variables**.
- An **identifier** is a name given to variables, functions, classes, modules, attributes and other objects.

#### The help function

- prints some basic help on how to use modules, keywords, built-in functions, classes, etc.

### Creating Functions

```python
def func_name():
    func_body
```

- **docstring** is a documentation comment written inside a triple-quoted string at the beginning of a function's block. This documentation can be accessed with the `help()` function and the `__doc__` property.

```python
def say():
    """
    The say function prints "Hi!"
    """
    print('Hi!')

print('-' * 60)
print(say.__doc__)
print('-' * 60)
help(say)
```

### Scope

- The **scope** of an identifier determines where you can use it.
- Python determines scope by looking at where you initialize the identifier.
- Identifiers have **function scope**: anything initialized inside a function is only available within the body of that function and nested functions. No code outside of the function body can access that identifier.
- **Variable Shadowing** is when a variable (assigned) in an inner scope "hides" (that is, makes inaccessible) another variable with the same name in an outer scope

```python
greeting = 'Salutations'

def well_howdy(who):
    greeting = 'Howdy'
    print(f'{greeting}, {who}')

well_howdy('Angie')
print(greeting)
```

- In the following example, Python looks for `greeting` in the **lexical scope**, which means that it searches all of outer scopes for the nearest definition of `greeting`.

```python
greeting = 'Salutations'

def well_howdy(who):
    print(f'{greeting}, {who}')

well_howdy('Angie')
print(greeting)
```

### Arguments and Parameters

- Arguments are values used when calling a function and they let you pass data from outside's function scope into the function so it can access that data.
- Parameters are the names between parentheses in the function definition. These are placeholders for potential arguments, while arguments are the values assigned to those placeholders.
- **Arguments** are objects passed to a function during invocation.
- **Parameters** are placeholders for the objects that will be passed to the function when it is invoked.
- **Function names and parameters are both considered variable names in Python**
- **Parameters** are **local variables**: they are defined localy within the function's body.
- A function's name is global or local, depending on whether it is at the program's top level or nested inside a class, module or another function.

### Return Values

- Functions return a result to the caller for later use with return values and the `return` statement.
- All Python function calls evaluate to a value (if the function doesn't raise an exception). By default the value is `None`, this is the **implicit return value**.
- When a `return` statement is used to return a specific value from a function, this is called an **explicit return value**.
- Functions that always return a Boolean value are called **predicates**.

### Default Parameters

- These are default values provided to the function's parameters, so the function can be invoked without some of its arguments.

```python
def say(text='hello'):
    print(text + '!')

say('Howdy') # Howdy!
say()        # hello!
```

- You can provide defaults for any or all of a function's parameters.
- Once you specify a default value for an argument, all subsequent positional arguments must also have default values:

```python
def say(msg1, msg2, msg3='dummy message', msg4):
    pass
# SyntaxError: non-default argument follows default argument
```

- You can't accept the default value for an argument and provide an explicit value for a subsequent argument:

```python
def say(msg1, msg2, msg3='dummy message',
                    msg4='omittted message'):
    print(msg1)
    print(msg2)
    print(msg3)
    print(msg4)

say('a', 'b', 'c', 'd')
# a
# b
# c
# d

say('a', 'b', 'c')
# a
# b
# c
# omitted message

say('a', 'b')
# a
# b
# dummy message
# omitted message

say('a', 'b', 'd')
# a
# b
# d          # oops - expecting 'dummy message'
# omitted message   # oops again - expected 'd'
```

- Python has a variety of ways to specify parameters. The easiest is with positional parameters. With positional parameters, the parameter values are taken from the corresponding argument position. Thus, if you have a function that takes 3 parameters, the first parameter is set to the first argument, the second parameter to the second argument, and the third parameter to the third argument.

### Functions vs. Methods

- We call a function by writing parentheses after its name. Any arguments are provided inside the parentheses.
- **Method invocation** occur when you prepend an object followed by a period `()` to a function invocation, i.e `"str".upper()`. This function invocations are called **method calls**.
- Methods work with specific objects. All methods are functions but not vice versa.
- Every method belongs to a class and requires an object of that class to call it.

### Mutating the Caller

- **Mutates the caller** means that the object used to invoke the method mutates. 

```python
odd_numbers = [1, 3, 5, 7, 9]
odd_numbers.pop()
print(odd_numbers)  # [1, 3, 5, 7]
```

- Mutating the caller is acceptable practice; many built-in functions and methods do just that. However, you should avoid mutating arguments since such functions can be tough to debug and is considered poor practice.


## 22.) Expressions and Statements

- An **expression** produces a value that can be assigned to a variable, passed to a function or method, or returned by a function or a method.
- Examples of **expressions**:
	- Literals: `5`, `'Karl'`, `3.141592`, `True`, `None`
	- Variable references: `foo` or `name` when these variables have been previously defined.
	- Arithmetic operations: `x + y` or `a * b - 5`.
	- Comparison operations: `'x' == 'x'` or `'x' < 'y'`.
	- String operations: `'x' + 'y'` or `'x' * 32`.
	- Function calls: `print('Hello')` or `len('Python')`.
	- Any valid combination of the above that evaluates to a single object.
- A **statement** is an instruction that tells Python to perform an action. They don't return or produce values.
- Examples:
	- Assignment: like `x = 5`. This doesn't evaluate as a value; it assigns a value to a variable.
	- Control flow: such as `if`, `else`, `while`, `for`, and so on. These determine the flow of your program but don't evaluate as a value themselves.
	- Function and class definitions: using `def` or `class`.
	- Return statements: like `return x`, which tells a function to exit and return a value. `return` itself doesn't return a value; it informs the function what value it should return.
	- Import statements: such as `import math`.

Key differences:

- Expressions always return a value; statements do not.
- Expressions are often part of statements. For example, in the statement `y = x + 5`, here `x + 5` is an expression.
- Statements often represent bigger chunks of functionality like loops or conditionals; expressions deal with determining values.

Stand-alone expressions are both expressions and statements:

```python
3 + 4            # Simple expression
print('Hello')   # Function call; returns None
my_list.sort()   # Method call; returns None
```

**IMPORTANT**

```python
my_number = 3
```

The code snippet contains both a statement and an expression:

- `my_number = 3` is a statement that assigns the value `3` to the variable `my_number`.
- The value `3` itself is an expression. (Code appearing to the right of an `=` in an assignment or reassignment is an expression.)

### Expression Evaluation

- Python evaluates most expressions from left to right (when all operators are the same)
- When the operators are mixed, precedence rules are followed.
- Parentheses have the higher precedence.


## 23.) Naming Conventions


* **idiomatic**: Names that follow Python's style convention (PEP8).
* **non-idiomatic**: Names that are legal but do not follow the naming conventions
* **illegal**: Names that are either not allowed or are not syntactically correct.

### Legal vs. Idiomatic

* **Legal Names**  are syntactically valid and do not raise a syntax error.
* **Idiomatic Names**: are those that follow Python's style convention (Python Enhancement Proposals (PEP8)).

Not every variable name that is **legal** is **idiomatic**.

```python
# Legal but non-idiomatic
firstName = "Ivan"
FirstName = "Ivan"
LASTName = "Hernandez"

# Legal and idiomatic
first_name = "Ivan"
MY_CONSTANT = 10
class MyClass():
	pass
```

### Illegal vs. non-idiomatic

* **Illegal names** are those that will raise a syntax error, either because is syntactically incorrect or is a Python's reserved word.
* **Non-idiomatic** names are legal names that do not follow the Python's style convention (PEP8)

Not every **non-idiomatic** name is **illegal**.

```python
# Illegal names
1stName = "Ivan"
first-name = "Ivan"
pass = "I will"
```

### Illegal Names

* Punctuation characters, most special characters, and whitespaces are not allowed
* Names must not begin with a digit
* Python reserved words are not allowed: `if`, `def`, `while`, `for`, `return`, `class` and `pass`






### Escape Sequences

The concept demonstrated here is escape sequences in strings, which allow us to encode special characters into strings via escape notation that would be impossible to include in another way. Examples: newlines, carriage returns, tabs, etc.



### Truthiness

Is how values evaluate in a Boolean context (conditional statements), regardless of whether they are actual Boolean values.











